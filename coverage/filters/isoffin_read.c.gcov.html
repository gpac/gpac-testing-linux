<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - filters/isoffin_read.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">filters</a> - isoffin_read.c<span style="font-size: 80%;"> (source / <a href="isoffin_read.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">620</td>
            <td class="headerCovTableEntry">784</td>
            <td class="headerCovTableEntryMed">79.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-04-29 23:48:07</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntryMed">89.5 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *                      GPAC - Multimedia Framework C SDK
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *                      Authors: Jean Le Feuvre
<span class="lineNum">       5 </span>            :  *                      Copyright (c) Telecom ParisTech 2000-2021
<span class="lineNum">       6 </span>            :  *                                      All rights reserved
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *  This file is part of GPAC / ISOBMFF reader filter
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *  GPAC is free software; you can redistribute it and/or modify
<span class="lineNum">      11 </span>            :  *  it under the terms of the GNU Lesser General Public License as published by
<span class="lineNum">      12 </span>            :  *  the Free Software Foundation; either version 2, or (at your option)
<span class="lineNum">      13 </span>            :  *  any later version.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  *  GPAC is distributed in the hope that it will be useful,
<span class="lineNum">      16 </span>            :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      17 </span>            :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      18 </span>            :  *  GNU Lesser General Public License for more details.
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  *  You should have received a copy of the GNU Lesser General Public
<span class="lineNum">      21 </span>            :  *  License along with this library; see the file COPYING.  If not, write to
<span class="lineNum">      22 </span>            :  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;isoffin.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #ifndef GPAC_DISABLE_ISOM
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;gpac/crypt_tools.h&gt;
<a name="31"><span class="lineNum">      31 </span>            : #include &lt;gpac/media_tools.h&gt;</a>
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span><span class="lineNoCov">          0 : ISOMChannel *isor_get_channel(ISOMReader *reader, GF_FilterPid *pid)</span>
<span class="lineNum">      34 </span>            : {
<span class="lineNum">      35 </span><span class="lineCov">      76195 :         u32 i=0;</span>
<span class="lineNum">      36 </span>            :         ISOMChannel *ch;
<span class="lineNum">      37 </span><span class="lineCov">     235616 :         while ((ch = (ISOMChannel *)gf_list_enum(reader-&gt;channels, &amp;i))) {</span>
<span class="lineNum">      38 </span><span class="lineCov">     162041 :                 if (ch-&gt;pid == pid) return ch;</span>
<span class="lineNum">      39 </span>            :         }
<span class="lineNum">      40 </span>            :         return NULL;
<span class="lineNum">      41 </span>            : }
<a name="42"><span class="lineNum">      42 </span>            : </a>
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineCov">        677 : static GFINLINE Bool isor_is_local(const char *url)</span>
<span class="lineNum">      45 </span>            : {
<span class="lineNum">      46 </span><span class="lineCov">        677 :         if (!strnicmp(url, &quot;file://&quot;, 7)) return GF_TRUE;</span>
<span class="lineNum">      47 </span><span class="lineCov">        677 :         if (!strnicmp(url, &quot;gmem://&quot;, 7)) return GF_TRUE;</span>
<span class="lineNum">      48 </span><span class="lineCov">        623 :         if (!strnicmp(url, &quot;gfio://&quot;, 7)) return GF_TRUE;</span>
<span class="lineNum">      49 </span><span class="lineCov">        622 :         if (!strnicmp(url, &quot;isobmff://&quot;, 10)) return GF_TRUE;</span>
<span class="lineNum">      50 </span><span class="lineCov">        617 :         if (strstr(url, &quot;://&quot;)) return GF_FALSE;</span>
<span class="lineNum">      51 </span>            :         /*the rest is local (mounted on FS)*/
<span class="lineNum">      52 </span><span class="lineCov">        617 :         return GF_TRUE;</span>
<span class="lineNum">      53 </span>            : }
<a name="54"><span class="lineNum">      54 </span>            : </a>
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span><span class="lineCov">        677 : static GF_Err isoffin_setup(GF_Filter *filter, ISOMReader *read)</span>
<span class="lineNum">      57 </span>            : {
<span class="lineNum">      58 </span>            :         char szURL[2048];
<span class="lineNum">      59 </span>            :         char *tmp, *src;
<span class="lineNum">      60 </span>            :         GF_Err e;
<span class="lineNum">      61 </span>            :         const GF_PropertyValue *prop;
<span class="lineNum">      62 </span><span class="lineCov">        677 :         if (!read) return GF_SERVICE_ERROR;</span>
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span><span class="lineCov">        677 :         if (read-&gt;pid) {</span>
<span class="lineNum">      65 </span><span class="lineCov">        677 :                 prop = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">      66 </span>            :                 assert(prop);
<span class="lineNum">      67 </span><span class="lineCov">        677 :                 src = prop-&gt;value.string;</span>
<span class="lineNum">      68 </span>            :         } else {
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :                 src = read-&gt;src;</span>
<span class="lineNum">      70 </span>            :         }
<span class="lineNum">      71 </span><span class="lineCov">        677 :         if (!src)  return GF_SERVICE_ERROR;</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineCov">        677 :         read-&gt;src_crc = gf_crc_32(src, (u32) strlen(src));</span>
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :         strcpy(szURL, src);
<span class="lineNum">      76 </span><span class="lineCov">        677 :         tmp = gf_file_ext_start(szURL);</span>
<span class="lineNum">      77 </span><span class="lineCov">        677 :         if (tmp) {</span>
<span class="lineNum">      78 </span>            :                 Bool truncate = GF_TRUE;
<span class="lineNum">      79 </span><span class="lineCov">        618 :                 tmp = strchr(tmp, '#');</span>
<span class="lineNum">      80 </span><span class="lineCov">        618 :                 if (!tmp &amp;&amp; read-&gt;pid) {</span>
<span class="lineNum">      81 </span><span class="lineCov">        617 :                         prop = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_URL);</span>
<span class="lineNum">      82 </span><span class="lineCov">        617 :                         if (prop &amp;&amp; prop-&gt;value.string) {</span>
<span class="lineNum">      83 </span><span class="lineCov">        617 :                                 tmp = gf_file_ext_start(prop-&gt;value.string);</span>
<span class="lineNum">      84 </span><span class="lineCov">        617 :                                 if (tmp) tmp = strchr(tmp, '#');</span>
<span class="lineNum">      85 </span>            :                                 truncate = GF_FALSE;
<span class="lineNum">      86 </span>            :                         }
<span class="lineNum">      87 </span>            :                 }
<span class="lineNum">      88 </span><span class="lineCov">        618 :                 if (tmp) {</span>
<span class="lineNum">      89 </span><span class="lineCov">          1 :                         if (!strnicmp(tmp, &quot;#audio&quot;, 6)) {</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :                                 read-&gt;play_only_first_media = GF_ISOM_MEDIA_AUDIO;</span>
<span class="lineNum">      91 </span><span class="lineCov">          1 :                         } else if (!strnicmp(tmp, &quot;#video&quot;, 6)) {</span>
<span class="lineNum">      92 </span><span class="lineCov">          1 :                                 read-&gt;play_only_first_media = GF_ISOM_MEDIA_VISUAL;</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :                         } else if (!strnicmp(tmp, &quot;#auxv&quot;, 5)) {</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :                                 read-&gt;play_only_first_media = GF_ISOM_MEDIA_AUXV;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :                         } else if (!strnicmp(tmp, &quot;#pict&quot;, 5)) {</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :                                 read-&gt;play_only_first_media = GF_ISOM_MEDIA_PICT;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :                         } else if (!strnicmp(tmp, &quot;#text&quot;, 5)) {</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                                 read-&gt;play_only_first_media = GF_ISOM_MEDIA_TEXT;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :                         } else if (!strnicmp(tmp, &quot;#trackID=&quot;, 9)) {</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :                                 read-&gt;play_only_track_id = atoi(tmp+9);</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :                         } else if (!strnicmp(tmp, &quot;#ID=&quot;, 4)) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                                 read-&gt;play_only_track_id = atoi(tmp+4);</span>
<span class="lineNum">     103 </span>            :                         } else {
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :                                 read-&gt;play_only_track_id = atoi(tmp+1);</span>
<span class="lineNum">     105 </span>            :                         }
<span class="lineNum">     106 </span><span class="lineCov">          1 :                         if (truncate) tmp[0] = 0;</span>
<span class="lineNum">     107 </span>            :                 }
<span class="lineNum">     108 </span>            :         }
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineCov">        677 :         if (! isor_is_local(szURL)) {</span>
<span class="lineNum">     111 </span>            :                 return GF_NOT_SUPPORTED;
<span class="lineNum">     112 </span>            :         }
<span class="lineNum">     113 </span><span class="lineCov">        677 :         read-&gt;start_range = read-&gt;end_range = 0;</span>
<span class="lineNum">     114 </span><span class="lineCov">        677 :         prop = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_FILE_RANGE);</span>
<span class="lineNum">     115 </span><span class="lineCov">        677 :         if (prop) {</span>
<span class="lineNum">     116 </span><span class="lineCov">         14 :                 read-&gt;start_range = prop-&gt;value.lfrac.num;</span>
<span class="lineNum">     117 </span><span class="lineCov">         14 :                 read-&gt;end_range = prop-&gt;value.lfrac.den;</span>
<span class="lineNum">     118 </span>            :         }
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineCov">        677 :         e = gf_isom_open_progressive(szURL, read-&gt;start_range, read-&gt;end_range, read-&gt;sigfrag, &amp;read-&gt;mov, &amp;read-&gt;missing_bytes);</span>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineCov">        677 :         if (e == GF_ISOM_INCOMPLETE_FILE) {</span>
<span class="lineNum">     123 </span><span class="lineCov">         25 :                 read-&gt;moov_not_loaded = 1;</span>
<span class="lineNum">     124 </span><span class="lineCov">         25 :                 return GF_OK;</span>
<span class="lineNum">     125 </span>            :         }
<span class="lineNum">     126 </span><span class="lineCov">        652 :         read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineCov">        652 :         if (e != GF_OK) {</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (&quot;[IsoMedia] error while opening %s, error=%s\n&quot;, szURL,gf_error_to_string(e)));</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :                 gf_filter_setup_failure(filter, e);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :                 return e;</span>
<span class="lineNum">     132 </span>            :         }
<span class="lineNum">     133 </span><span class="lineCov">        652 :         read-&gt;frag_type = gf_isom_is_fragmented(read-&gt;mov) ? 1 : 0;</span>
<span class="lineNum">     134 </span><span class="lineCov">        652 :     if (!read-&gt;frag_type &amp;&amp; read-&gt;sigfrag) {</span>
<span class="lineNum">     135 </span>            :         e = GF_BAD_PARAM;
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (&quot;[IsoMedia] sigfrag requested but file %s is not fragmented\n&quot;, szURL));</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         gf_filter_setup_failure(filter, e);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         return e;</span>
<span class="lineNum">     139 </span>            :     }
<span class="lineNum">     140 </span>            :     
<span class="lineNum">     141 </span><span class="lineCov">        652 :         read-&gt;time_scale = gf_isom_get_timescale(read-&gt;mov);</span>
<span class="lineNum">     142 </span><span class="lineCov">        652 :         if (!read-&gt;input_loaded &amp;&amp; read-&gt;frag_type)</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :                 read-&gt;refresh_fragmented = GF_TRUE;</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineCov">        652 :         if (read-&gt;strtxt)</span>
<span class="lineNum">     146 </span><span class="lineCov">          1 :                 gf_isom_text_set_streaming_mode(read-&gt;mov, GF_TRUE);</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineCov">        652 :         return isor_declare_objects(read);</span>
<a name="149"><span class="lineNum">     149 </span>            : }</a>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineCov">       1184 : static void isoffin_delete_channel(ISOMChannel *ch)</span>
<span class="lineNum">     152 </span>            : {
<span class="lineNum">     153 </span><span class="lineCov">       1184 :         isor_reset_reader(ch);</span>
<span class="lineNum">     154 </span><span class="lineCov">       1184 :         if (ch-&gt;nal_bs) gf_bs_del(ch-&gt;nal_bs);</span>
<span class="lineNum">     155 </span><span class="lineCov">       1184 :         if (ch-&gt;avcc) gf_odf_avc_cfg_del(ch-&gt;avcc);</span>
<span class="lineNum">     156 </span><span class="lineCov">       1184 :         if (ch-&gt;hvcc) gf_odf_hevc_cfg_del(ch-&gt;hvcc);</span>
<span class="lineNum">     157 </span><span class="lineCov">       1184 :         if (ch-&gt;vvcc) gf_odf_vvc_cfg_del(ch-&gt;vvcc);</span>
<span class="lineNum">     158 </span><span class="lineCov">       1184 :         gf_free(ch);</span>
<a name="159"><span class="lineNum">     159 </span><span class="lineCov">       1184 : }</span></a>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineCov">         13 : static void isoffin_disconnect(ISOMReader *read)</span>
<span class="lineNum">     162 </span>            : {
<span class="lineNum">     163 </span><span class="lineCov">         13 :         read-&gt;disconnected = GF_TRUE;</span>
<span class="lineNum">     164 </span><span class="lineCov">         57 :         while (gf_list_count(read-&gt;channels)) {</span>
<span class="lineNum">     165 </span><span class="lineCov">         31 :                 ISOMChannel *ch = (ISOMChannel *)gf_list_get(read-&gt;channels, 0);</span>
<span class="lineNum">     166 </span><span class="lineCov">         31 :                 gf_list_rem(read-&gt;channels, 0);</span>
<span class="lineNum">     167 </span><span class="lineCov">         31 :                 if (ch-&gt;pid)</span>
<span class="lineNum">     168 </span><span class="lineCov">         31 :                         gf_filter_pid_remove(ch-&gt;pid);</span>
<span class="lineNum">     169 </span><span class="lineCov">         31 :                 isoffin_delete_channel(ch);</span>
<span class="lineNum">     170 </span>            :         }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineCov">         13 :         if (read-&gt;mov) gf_isom_close(read-&gt;mov);</span>
<span class="lineNum">     173 </span><span class="lineCov">         13 :         read-&gt;mov = NULL;</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineCov">         13 :         read-&gt;pid = NULL;</span>
<a name="176"><span class="lineNum">     176 </span><span class="lineCov">         13 : }</span></a>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineCov">       3013 : static GF_Err isoffin_reconfigure(GF_Filter *filter, ISOMReader *read, const char *next_url)</span>
<span class="lineNum">     179 </span>            : {
<span class="lineNum">     180 </span>            :         const GF_PropertyValue *prop;
<span class="lineNum">     181 </span>            :         u32 i, count;
<span class="lineNum">     182 </span>            :         Bool is_new_mov = GF_FALSE;
<span class="lineNum">     183 </span>            :         u64 tfdt;
<span class="lineNum">     184 </span>            : //      GF_ISOTrackID trackID;
<span class="lineNum">     185 </span>            :         GF_ISOSegOpenMode flags=0;
<span class="lineNum">     186 </span>            :         GF_Err e;
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineCov">       3013 :         prop = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_FILE_CACHED);</span>
<span class="lineNum">     189 </span><span class="lineCov">       3013 :         if (prop &amp;&amp; prop-&gt;value.boolean)</span>
<span class="lineNum">     190 </span><span class="lineCov">       2515 :                 read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineCov">       3013 :         read-&gt;refresh_fragmented = GF_FALSE;</span>
<span class="lineNum">     193 </span><span class="lineCov">       3013 :         read-&gt;full_segment_flush = GF_TRUE;</span>
<span class="lineNum">     194 </span><span class="lineCov">       3013 :         GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] reconfigure triggered, URL %s\n&quot;, next_url));</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :         //no need to lock blob if next_url is a blob, all parsing and probing functions below will lock the blob if any
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineCov">       3013 :         switch (gf_isom_probe_file_range(next_url, read-&gt;start_range, read-&gt;end_range)) {</span>
<span class="lineNum">     199 </span>            :         //this is a fragment
<span class="lineNum">     200 </span><span class="lineCov">       2961 :         case 3:</span>
<span class="lineNum">     201 </span><span class="lineCov">       2961 :                 gf_isom_release_segment(read-&gt;mov, 1);</span>
<span class="lineNum">     202 </span><span class="lineCov">       2961 :                 gf_isom_reset_fragment_info(read-&gt;mov, GF_TRUE);</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineCov">       2961 :                 if (read-&gt;no_order_check) flags |= GF_ISOM_SEGMENT_NO_ORDER_FLAG;</span>
<span class="lineNum">     205 </span>            : #ifdef FILTER_FIXME
<span class="lineNum">     206 </span>            :                 if (scalable_segment) flags |= GF_ISOM_SEGMENT_SCALABLE_FLAG;
<span class="lineNum">     207 </span>            : #endif
<span class="lineNum">     208 </span><span class="lineCov">       2961 :                 e = gf_isom_open_segment(read-&gt;mov, next_url, read-&gt;start_range, read-&gt;end_range, flags);</span>
<span class="lineNum">     209 </span><span class="lineCov">       2961 :                 if (!read-&gt;input_loaded &amp;&amp; (e==GF_ISOM_INCOMPLETE_FILE)) {</span>
<span class="lineNum">     210 </span>            :                         e = GF_OK;
<span class="lineNum">     211 </span>            :                 }
<span class="lineNum">     212 </span>            :                 //always refresh fragmented files, since we could have a full moof+mdat in buffer (not incomplete file)
<span class="lineNum">     213 </span>            :                 //but still further fragments to be pushed
<span class="lineNum">     214 </span><span class="lineCov">       2961 :                 if (!read-&gt;start_range &amp;&amp; !read-&gt;end_range)</span>
<span class="lineNum">     215 </span><span class="lineCov">       2680 :                         read-&gt;refresh_fragmented = GF_TRUE;</span>
<span class="lineNum">     216 </span><span class="lineCov">       2961 :                 read-&gt;seg_name_changed = GF_TRUE;</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineCov">      20516 :                 for (i=0; i&lt;gf_list_count(read-&gt;channels); i++) {</span>
<span class="lineNum">     219 </span><span class="lineCov">      17555 :                         ISOMChannel *ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">     220 </span><span class="lineCov">      17555 :                         if (ch-&gt;last_state==GF_EOS)</span>
<span class="lineNum">     221 </span><span class="lineCov">      17555 :                                 ch-&gt;last_state=GF_OK;</span>
<span class="lineNum">     222 </span>            :                 }
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : #ifndef GPAC_DISABLE_LOG
<span class="lineNum">     225 </span><span class="lineCov">       2961 :                 if (e&lt;0) {</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[IsoMedia] Error opening new segment %s at UTC &quot;LLU&quot;: %s\n&quot;, next_url, gf_net_get_utc(), gf_error_to_string(e) ));</span>
<span class="lineNum">     227 </span><span class="lineCov">       2961 :                 } else if (read-&gt;end_range) {</span>
<span class="lineNum">     228 </span><span class="lineCov">        281 :                         GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] Playing new range in %s: &quot;LLU&quot;-&quot;LLU&quot;\n&quot;, next_url, read-&gt;start_range, read-&gt;end_range));</span>
<span class="lineNum">     229 </span>            :                 } else {
<span class="lineNum">     230 </span><span class="lineCov">       2680 :                         GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] playing new segment %s\n&quot;, next_url));</span>
<span class="lineNum">     231 </span>            :                 }
<span class="lineNum">     232 </span>            : #endif
<span class="lineNum">     233 </span>            :                 break;
<span class="lineNum">     234 </span>            :         //this is a movie, reload
<span class="lineNum">     235 </span><span class="lineCov">         52 :         case 2:</span>
<span class="lineNum">     236 </span>            :         case 1:
<span class="lineNum">     237 </span>            :                 //get tfdt of next segment (cumulated sample dur since moov load)
<span class="lineNum">     238 </span>            :                 //if the next segment has a tfdt or a tfrx, this will be ignored
<span class="lineNum">     239 </span>            :                 //otherwise this value will be used as base tfdt for next segment
<span class="lineNum">     240 </span><span class="lineCov">         52 :                 tfdt = gf_isom_get_smooth_next_tfdt(read-&gt;mov, 1);</span>
<span class="lineNum">     241 </span><span class="lineCov">         52 :                 GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] Switching between files - opening new init segment %s (time offset=&quot;LLU&quot;) - range &quot;LLU&quot;-&quot;LLU&quot;\n&quot;, next_url, tfdt, read-&gt;start_range, read-&gt;end_range));</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineCov">         52 :                 if (gf_isom_is_smooth_streaming_moov(read-&gt;mov)) {</span>
<span class="lineNum">     244 </span><span class="lineCov">          1 :                         char *tfdt_val = strstr(next_url, &quot;tfdt=&quot;);</span>
<span class="lineNum">     245 </span>            :                         //smooth addressing, replace tfdt=0000000000000000 with proper value
<span class="lineNum">     246 </span><span class="lineCov">          1 :                         if (tfdt_val) {</span>
<span class="lineNum">     247 </span><span class="lineCov">          1 :                                 sprintf(tfdt_val+5, LLX, tfdt);</span>
<span class="lineNum">     248 </span>            :                         } else {
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[IsoMedia] Error finding init time for init segment %s at UTC &quot;LLU&quot;\n&quot;, next_url, gf_net_get_utc() ));</span>
<span class="lineNum">     250 </span>            :                         }
<span class="lineNum">     251 </span>            :                 }
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineCov">         52 :                 if (read-&gt;mov) gf_isom_close(read-&gt;mov);</span>
<span class="lineNum">     254 </span><span class="lineCov">         52 :                 e = gf_isom_open_progressive(next_url, read-&gt;start_range, read-&gt;end_range, read-&gt;sigfrag, &amp;read-&gt;mov, &amp;read-&gt;missing_bytes);</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :                 //init seg not completely downloaded, retry at next packet
<span class="lineNum">     257 </span><span class="lineCov">         52 :                 if (!read-&gt;input_loaded &amp;&amp; (e==GF_ISOM_INCOMPLETE_FILE)) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :                         read-&gt;src_crc = 0;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :                         read-&gt;moov_not_loaded = 2;</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :                         return GF_OK;</span>
<span class="lineNum">     261 </span>            :                 }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineCov">         52 :                 read-&gt;moov_not_loaded = 0;</span>
<span class="lineNum">     264 </span><span class="lineCov">         52 :                 if (e &lt; 0) {</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[IsoMedia] Error opening init segment %s at UTC &quot;LLU&quot;: %s\n&quot;, next_url, gf_net_get_utc(), gf_error_to_string(e) ));</span>
<span class="lineNum">     266 </span>            :                 }
<span class="lineNum">     267 </span><span class="lineCov">         52 :                 if (read-&gt;sigfrag)</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :                         gf_isom_enable_traf_map_templates(read-&gt;mov);</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :                 is_new_mov = GF_TRUE;
<span class="lineNum">     271 </span>            :                 break;
<span class="lineNum">     272 </span>            :         //empty file
<span class="lineNum">     273 </span>            :         case 4:
<span class="lineNum">     274 </span>            :                 return GF_OK;
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 if (!read-&gt;mov) {</span>
<span class="lineNum">     277 </span>            :             return GF_NOT_SUPPORTED;
<span class="lineNum">     278 </span>            :                 }
<span class="lineNum">     279 </span>            :         e = GF_ISOM_INVALID_FILE;
<span class="lineNum">     280 </span>            :         break;
<span class="lineNum">     281 </span>            :         }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineCov">       3013 :         gf_filter_post_process_task(filter);</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineCov">       3013 :         count = gf_list_count(read-&gt;channels);</span>
<span class="lineNum">     286 </span>            :         
<span class="lineNum">     287 </span><span class="lineCov">       3013 :         if (e&lt;0) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 count = gf_list_count(read-&gt;channels);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                 gf_isom_release_segment(read-&gt;mov, 1);</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         read-&gt;invalid_segment = GF_TRUE;</span>
<span class="lineNum">     291 </span>            :                 //error opening the segment, reset everything ...
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :                 gf_isom_reset_fragment_info(read-&gt;mov, GF_FALSE);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :                         ISOMChannel *ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :             if (ch) {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :                 ch-&gt;sample_num = 0;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                 ch-&gt;eos_sent = GF_FALSE;</span>
<span class="lineNum">     298 </span>            :             }
<span class="lineNum">     299 </span>            :                 }
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[IsoMedia] Error opening current segment %s: %s\n&quot;, next_url, gf_error_to_string(e) ));</span>
<span class="lineNum">     301 </span>            :                 return GF_OK;
<span class="lineNum">     302 </span>            :         }
<span class="lineNum">     303 </span>            :         //segment is the first in our cache, we may need a refresh
<span class="lineNum">     304 </span><span class="lineCov">       3013 :         if (!read-&gt;input_loaded) {</span>
<span class="lineNum">     305 </span><span class="lineCov">        498 :                 GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] Opening current segment in progressive mode (download in progress)\n&quot;));</span>
<span class="lineNum">     306 </span>            :         } else {
<span class="lineNum">     307 </span><span class="lineCov">       2515 :                 GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] Opening current segment in non-progressive mode (completely downloaded)\n&quot;));</span>
<span class="lineNum">     308 </span>            :         }
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineCov">       3013 :         isor_check_producer_ref_time(read);</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineCov">      20620 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">     313 </span><span class="lineCov">      17607 :                 ISOMChannel *ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">     314 </span><span class="lineCov">      17607 :                 ch-&gt;last_state = GF_OK;</span>
<span class="lineNum">     315 </span><span class="lineCov">      17607 :                 ch-&gt;eos_sent = GF_FALSE;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :                 //old code from master, currently no longer used
<span class="lineNum">     318 </span>            :                 //in filters we don't use extractors for the time being, we only do implicit reconstruction at the decoder side
<span class="lineNum">     319 </span>            : #if 0
<span class="lineNum">     320 </span>            :                 if (ch-&gt;base_track) {
<span class="lineNum">     321 </span>            :                         if (scalable_segment)
<span class="lineNum">     322 </span>            :                                 trackID = gf_isom_get_highest_track_in_scalable_segment(read-&gt;mov, ch-&gt;base_track);
<span class="lineNum">     323 </span>            :                                 if (trackID) {
<span class="lineNum">     324 </span>            :                                         ch-&gt;track_id = trackID;
<span class="lineNum">     325 </span>            :                                         ch-&gt;track = gf_isom_get_track_by_id(read-&gt;mov, ch-&gt;track_id);
<span class="lineNum">     326 </span>            :                                 }
<span class="lineNum">     327 </span>            :                         } else {
<span class="lineNum">     328 </span>            :                                 ch-&gt;track = ch-&gt;base_track;
<span class="lineNum">     329 </span>            :                                 ch-&gt;track_id = gf_isom_get_track_id(read-&gt;mov, ch-&gt;track);
<span class="lineNum">     330 </span>            :                         }
<span class="lineNum">     331 </span>            :                 }
<span class="lineNum">     332 </span>            : #endif
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineCov">      17607 :                 GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] Track %d - cur sample %d - new sample count %d\n&quot;, ch-&gt;track, ch-&gt;sample_num, gf_isom_get_sample_count(ch-&gt;owner-&gt;mov, ch-&gt;track) ));</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :                 //TODO: signal all discontinuities here
<span class="lineNum">     337 </span><span class="lineCov">      17607 :                 if (is_new_mov) {</span>
<span class="lineNum">     338 </span><span class="lineCov">         52 :                         ch-&gt;track = gf_isom_get_track_by_id(read-&gt;mov, ch-&gt;track_id);</span>
<span class="lineNum">     339 </span><span class="lineCov">         52 :                         if (!ch-&gt;track) {</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                                 if (gf_isom_get_track_count(read-&gt;mov)==1) {</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] Mismatch between track IDs of different representations\n&quot;));</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                                         ch-&gt;track = 1;</span>
<span class="lineNum">     343 </span>            :                                 } else {
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[IsoMedia] Mismatch between track IDs of different representations\n&quot;));</span>
<span class="lineNum">     345 </span>            :                                 }
<span class="lineNum">     346 </span>            :                         }
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :                         /*we changed our moov structure, sample_num now starts from 0*/
<span class="lineNum">     349 </span><span class="lineCov">         52 :                         ch-&gt;sample_num = 0;</span>
<span class="lineNum">     350 </span>            :                         //this may happen if we reload moov before initializing the channel
<span class="lineNum">     351 </span><span class="lineCov">         52 :                         if (!ch-&gt;last_sample_desc_index)</span>
<span class="lineNum">     352 </span><span class="lineCov">          1 :                                 ch-&gt;last_sample_desc_index = 1;</span>
<span class="lineNum">     353 </span>            :                         //and update channel config
<span class="lineNum">     354 </span><span class="lineCov">         52 :                         isor_update_channel_config(ch);</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :                         /*restore NAL extraction mode*/
<span class="lineNum">     357 </span><span class="lineCov">         52 :                         gf_isom_set_nalu_extract_mode(read-&gt;mov, ch-&gt;track, ch-&gt;nalu_extract_mode);</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineCov">         52 :                         if (ch-&gt;is_cenc) {</span>
<span class="lineNum">     360 </span><span class="lineCov">          7 :                                 isor_set_crypt_config(ch);</span>
<span class="lineNum">     361 </span>            :                         }
<span class="lineNum">     362 </span>            :                 }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineCov">      17607 :                 ch-&gt;last_state = GF_OK;</span>
<span class="lineNum">     365 </span>            :         }
<span class="lineNum">     366 </span>            :         return e;
<a name="367"><span class="lineNum">     367 </span>            : }</a>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineCov">       3682 : GF_Err isoffin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)</span>
<span class="lineNum">     370 </span>            : {
<span class="lineNum">     371 </span>            :         const GF_PropertyValue *prop;
<span class="lineNum">     372 </span><span class="lineCov">       3682 :         ISOMReader *read = gf_filter_get_udta(filter);</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineCov">       3682 :         if (is_remove) {</span>
<span class="lineNum">     375 </span><span class="lineCov">         13 :                 isoffin_disconnect(read);</span>
<span class="lineNum">     376 </span><span class="lineCov">         13 :                 return GF_OK;</span>
<span class="lineNum">     377 </span>            :         }
<span class="lineNum">     378 </span>            :         //check if we  have a file path; if not, this is a pure stream of boxes (no local file cache)
<span class="lineNum">     379 </span><span class="lineCov">       3669 :         prop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">     380 </span><span class="lineCov">       3669 :         if (!prop || !prop-&gt;value.string) {</span>
<span class="lineNum">     381 </span><span class="lineCov">          4 :                 if (!read-&gt;mem_load_mode)</span>
<span class="lineNum">     382 </span><span class="lineCov">          4 :                         read-&gt;mem_load_mode = 1;</span>
<span class="lineNum">     383 </span><span class="lineCov">          4 :                 if (!read-&gt;pid) read-&gt;pid = pid;</span>
<span class="lineNum">     384 </span><span class="lineCov">          4 :                 read-&gt;input_loaded = GF_FALSE;</span>
<span class="lineNum">     385 </span><span class="lineCov">          4 :                 return GF_OK;</span>
<span class="lineNum">     386 </span>            :         }
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineCov">       3665 :         if (read-&gt;pid &amp;&amp; prop-&gt;value.string) {</span>
<span class="lineNum">     389 </span>            :                 const char *next_url = prop-&gt;value.string;
<span class="lineNum">     390 </span>            :                 u64 sr, er;
<span class="lineNum">     391 </span><span class="lineCov">       3013 :                 u32 crc = gf_crc_32(next_url, (u32) strlen(next_url) );</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :                 sr = er = 0;
<span class="lineNum">     394 </span><span class="lineCov">       3013 :                 prop = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_FILE_RANGE);</span>
<span class="lineNum">     395 </span><span class="lineCov">       3013 :                 if (prop) {</span>
<span class="lineNum">     396 </span><span class="lineCov">        281 :                         sr = prop-&gt;value.lfrac.num;</span>
<span class="lineNum">     397 </span><span class="lineCov">        281 :                         er = prop-&gt;value.lfrac.den;</span>
<span class="lineNum">     398 </span>            :                 }
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :                 //if eos is signaled, don't check for crc since we might have the same blob address (same alloc)
<span class="lineNum">     401 </span><span class="lineCov">       3013 :                 if (!read-&gt;eos_signaled &amp;&amp; (read-&gt;src_crc == crc) &amp;&amp; (read-&gt;start_range==sr) &amp;&amp; (read-&gt;end_range==er)) {</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] same URL crc and range for %s, skipping reconfigure\n&quot;, next_url));</span>
<span class="lineNum">     403 </span>            :                         return GF_OK;
<span class="lineNum">     404 </span>            :                 }
<span class="lineNum">     405 </span><span class="lineCov">       3013 :                 read-&gt;src_crc = crc;</span>
<span class="lineNum">     406 </span><span class="lineCov">       3013 :                 read-&gt;start_range = sr;</span>
<span class="lineNum">     407 </span><span class="lineCov">       3013 :                 read-&gt;end_range = er;</span>
<span class="lineNum">     408 </span><span class="lineCov">       3013 :                 read-&gt;input_loaded = GF_FALSE;</span>
<span class="lineNum">     409 </span><span class="lineCov">       3013 :                 read-&gt;eos_signaled = GF_FALSE;</span>
<span class="lineNum">     410 </span>            :                 
<span class="lineNum">     411 </span>            :                 //we need to reconfigure
<span class="lineNum">     412 </span><span class="lineCov">       3013 :                 return isoffin_reconfigure(filter, read, next_url);</span>
<span class="lineNum">     413 </span>            :         }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineCov">        652 :         read-&gt;pid = pid;</span>
<span class="lineNum">     416 </span><span class="lineCov">        652 :         prop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_CACHED);</span>
<span class="lineNum">     417 </span><span class="lineCov">        652 :         if (prop &amp;&amp; prop-&gt;value.boolean) {</span>
<span class="lineNum">     418 </span>            :                 GF_FilterEvent evt;
<span class="lineNum">     419 </span><span class="lineCov">        588 :                 read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">     420 </span><span class="lineCov">        588 :                 GF_FEVT_INIT(evt, GF_FEVT_PLAY_HINT, pid);</span>
<span class="lineNum">     421 </span><span class="lineCov">        588 :                 evt.play.full_file_only=1;</span>
<span class="lineNum">     422 </span><span class="lineCov">        588 :                 gf_filter_pid_send_event(pid, &amp;evt);</span>
<span class="lineNum">     423 </span>            :         }
<span class="lineNum">     424 </span><span class="lineCov">        652 :         return isoffin_setup(filter, read);</span>
<a name="425"><span class="lineNum">     425 </span>            : }</a>
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span><span class="lineCov">        947 : GF_Err isoffin_initialize(GF_Filter *filter)</span>
<span class="lineNum">     428 </span>            : {
<span class="lineNum">     429 </span><span class="lineCov">        947 :         ISOMReader *read = gf_filter_get_udta(filter);</span>
<span class="lineNum">     430 </span>            :         GF_Err e = GF_OK;
<span class="lineNum">     431 </span><span class="lineCov">        947 :         read-&gt;filter = filter;</span>
<span class="lineNum">     432 </span><span class="lineCov">        947 :         read-&gt;channels = gf_list_new();</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">        947 :         if (read-&gt;xps_check==MP4DMX_XPS_AUTO) {</span>
<span class="lineNum">     435 </span><span class="lineCov">        947 :                 read-&gt;xps_check = (read-&gt;smode==MP4DMX_SPLIT_EXTRACTORS) ? MP4DMX_XPS_KEEP : MP4DMX_XPS_REMOVE;</span>
<span class="lineNum">     436 </span>            :         }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineCov">        947 :         if (read-&gt;src) {</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :                 read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                 return isoffin_setup(filter, read);</span>
<span class="lineNum">     441 </span>            :         }
<span class="lineNum">     442 </span><span class="lineCov">        947 :         else if (read-&gt;mov) {</span>
<span class="lineNum">     443 </span><span class="lineCov">        291 :                 read-&gt;extern_mov = GF_TRUE;</span>
<span class="lineNum">     444 </span><span class="lineCov">        291 :                 read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">     445 </span><span class="lineCov">        291 :                 read-&gt;frag_type = gf_isom_is_fragmented(read-&gt;mov) ? 1 : 0;</span>
<span class="lineNum">     446 </span><span class="lineCov">        291 :                 read-&gt;time_scale = gf_isom_get_timescale(read-&gt;mov);</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">        291 :                 if (read-&gt;sigfrag) {</span>
<span class="lineNum">     449 </span><span class="lineCov">          3 :                         gf_isom_enable_traf_map_templates(read-&gt;mov);</span>
<span class="lineNum">     450 </span>            :                 }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span><span class="lineCov">        291 :                 if (read-&gt;catseg) {</span>
<span class="lineNum">     453 </span><span class="lineCov">          3 :                         e = gf_isom_open_segment(read-&gt;mov, read-&gt;catseg, 0, 0, 0);</span>
<span class="lineNum">     454 </span>            :                 }
<span class="lineNum">     455 </span><span class="lineCov">          3 :                 if (!e)</span>
<span class="lineNum">     456 </span><span class="lineCov">        291 :                         e = isor_declare_objects(read);</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">        291 :                 gf_filter_post_process_task(filter);</span>
<span class="lineNum">     459 </span>            :         }
<span class="lineNum">     460 </span>            :         return e;
<span class="lineNum">     461 </span>            : }
<a name="462"><span class="lineNum">     462 </span>            : </a>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineCov">        947 : static void isoffin_finalize(GF_Filter *filter)</span>
<span class="lineNum">     465 </span>            : {
<span class="lineNum">     466 </span><span class="lineCov">        947 :         ISOMReader *read = (ISOMReader *) gf_filter_get_udta(filter);</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineCov">        947 :         read-&gt;disconnected = GF_TRUE;</span>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">       3047 :         while (gf_list_count(read-&gt;channels)) {</span>
<span class="lineNum">     471 </span><span class="lineCov">       1153 :                 ISOMChannel *ch = (ISOMChannel *)gf_list_get(read-&gt;channels, 0);</span>
<span class="lineNum">     472 </span><span class="lineCov">       1153 :                 gf_list_rem(read-&gt;channels, 0);</span>
<span class="lineNum">     473 </span><span class="lineCov">       1153 :                 isoffin_delete_channel(ch);</span>
<span class="lineNum">     474 </span>            :         }
<span class="lineNum">     475 </span><span class="lineCov">        947 :         gf_list_del(read-&gt;channels);</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineCov">        947 :         if (!read-&gt;extern_mov &amp;&amp; read-&gt;mov) gf_isom_close(read-&gt;mov);</span>
<span class="lineNum">     478 </span><span class="lineCov">        947 :         read-&gt;mov = NULL;</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineCov">        947 :         if (read-&gt;mem_blob.data) gf_free(read-&gt;mem_blob.data);</span>
<span class="lineNum">     481 </span><span class="lineCov">        947 :         if (read-&gt;mem_url) gf_free(read-&gt;mem_url);</span>
<a name="482"><span class="lineNum">     482 </span><span class="lineCov">        947 : }</span></a>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span><span class="lineCov">        206 : void isor_declare_pssh(ISOMChannel *ch)</span>
<span class="lineNum">     485 </span>            : {
<span class="lineNum">     486 </span>            :         u32 i, PSSH_count;
<span class="lineNum">     487 </span>            :         u8 *psshd;
<span class="lineNum">     488 </span><span class="lineCov">        206 :         GF_BitStream *pssh_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);</span>
<span class="lineNum">     489 </span>            :         u32 s;
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineCov">        206 :         PSSH_count = gf_isom_get_pssh_count(ch-&gt;owner-&gt;mov);</span>
<span class="lineNum">     492 </span><span class="lineCov">        206 :         gf_bs_write_u32(pssh_bs, PSSH_count);</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :         /*fill PSSH in the structure. We will free it in CENC_Setup*/
<span class="lineNum">     495 </span><span class="lineCov">        688 :         for (i=0; i&lt;PSSH_count; i++) {</span>
<span class="lineNum">     496 </span>            :                 bin128 SystemID;
<span class="lineNum">     497 </span>            :                 u32 version;
<span class="lineNum">     498 </span>            :                 u32 KID_count;
<span class="lineNum">     499 </span>            :                 bin128 *KIDs;
<span class="lineNum">     500 </span>            :                 u32 private_data_size;
<span class="lineNum">     501 </span>            :                 u8 *private_data;
<span class="lineNum">     502 </span><span class="lineCov">        276 :                 gf_isom_get_pssh_info(ch-&gt;owner-&gt;mov, i+1, SystemID, &amp;version, &amp;KID_count, (const bin128 **) &amp; KIDs, (const u8 **) &amp;private_data, &amp;private_data_size);</span>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span><span class="lineCov">        276 :                 gf_bs_write_data(pssh_bs, SystemID, 16);</span>
<span class="lineNum">     505 </span><span class="lineCov">        276 :                 gf_bs_write_u32(pssh_bs, version);</span>
<span class="lineNum">     506 </span><span class="lineCov">        276 :                 gf_bs_write_u32(pssh_bs, KID_count);</span>
<span class="lineNum">     507 </span><span class="lineCov">        535 :                 for (s=0; s&lt;KID_count; s++) {</span>
<span class="lineNum">     508 </span><span class="lineCov">        259 :                         gf_bs_write_data(pssh_bs, KIDs[s], 16);</span>
<span class="lineNum">     509 </span>            :                 }
<span class="lineNum">     510 </span><span class="lineCov">        276 :                 gf_bs_write_u32(pssh_bs, private_data_size);</span>
<span class="lineNum">     511 </span><span class="lineCov">        276 :                 gf_bs_write_data(pssh_bs, private_data, private_data_size);</span>
<span class="lineNum">     512 </span>            :         }
<span class="lineNum">     513 </span><span class="lineCov">        206 :         gf_bs_get_content(pssh_bs, &amp;psshd, &amp;s);</span>
<span class="lineNum">     514 </span><span class="lineCov">        206 :         gf_bs_del(pssh_bs);</span>
<span class="lineNum">     515 </span><span class="lineCov">        206 :         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_CENC_PSSH, &amp; PROP_DATA_NO_COPY(psshd, s) );</span>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">        206 : }</span></a>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineCov">        215 : void isor_set_crypt_config(ISOMChannel *ch)</span>
<span class="lineNum">     519 </span>            : {
<span class="lineNum">     520 </span><span class="lineCov">        215 :         GF_ISOFile *mov = ch-&gt;owner-&gt;mov;</span>
<span class="lineNum">     521 </span><span class="lineCov">        215 :         u32 track = ch-&gt;track;</span>
<span class="lineNum">     522 </span>            :         u32 scheme_type, scheme_version, i, count;
<span class="lineNum">     523 </span>            :         const char *kms_uri, *scheme_uri;
<span class="lineNum">     524 </span><span class="lineCov">        215 :         Bool selectiveEncryption=0;</span>
<span class="lineNum">     525 </span><span class="lineCov">        215 :         u32 IVLength=0;</span>
<span class="lineNum">     526 </span><span class="lineCov">        215 :         u32 KeyIndicationLength=0;</span>
<span class="lineNum">     527 </span><span class="lineCov">        215 :         const char *txtHdr=NULL;</span>
<span class="lineNum">     528 </span><span class="lineCov">        215 :         const char *contentID=NULL;</span>
<span class="lineNum">     529 </span><span class="lineCov">        215 :         u32 txtHdrLen=0;</span>
<span class="lineNum">     530 </span><span class="lineCov">        215 :         u64 plainTextLen=0;</span>
<span class="lineNum">     531 </span><span class="lineCov">        215 :         u32 crypt_type=0;</span>
<span class="lineNum">     532 </span><span class="lineCov">        215 :         u32 stsd_idx = ch-&gt;owner-&gt;stsd ? ch-&gt;owner-&gt;stsd : 1;</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineCov">        215 :         if (!ch-&gt;is_encrypted) return;</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineCov">        215 :         scheme_type = scheme_version = 0;</span>
<span class="lineNum">     537 </span><span class="lineCov">        215 :         kms_uri = scheme_uri = NULL;</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :         /*ugly fix to detect when an stsd uses both clear and encrypted sample descriptions*/
<span class="lineNum">     540 </span><span class="lineCov">        215 :         count = gf_isom_get_sample_description_count(ch-&gt;owner-&gt;mov, ch-&gt;track);</span>
<span class="lineNum">     541 </span><span class="lineCov">        215 :         if (count&gt;1) {</span>
<span class="lineNum">     542 </span>            :                 u32 first_crypted_stsd = 0;
<span class="lineNum">     543 </span>            :                 u32 nb_same_mtype = 1;
<span class="lineNum">     544 </span>            :                 u32 nb_clear=0, nb_encrypted=0;
<span class="lineNum">     545 </span>            :                 u32 base_subtype = 0;
<span class="lineNum">     546 </span>            :                 Bool first_is_clear = GF_FALSE;
<span class="lineNum">     547 </span><span class="lineCov">         18 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">     548 </span><span class="lineCov">         12 :                         u32 mtype = gf_isom_get_media_subtype(ch-&gt;owner-&gt;mov, ch-&gt;track, i+1);</span>
<span class="lineNum">     549 </span><span class="lineCov">         12 :                         if ( gf_isom_is_media_encrypted(ch-&gt;owner-&gt;mov, track, i+1)) {</span>
<span class="lineNum">     550 </span><span class="lineCov">          6 :                                 gf_isom_get_original_format_type(ch-&gt;owner-&gt;mov, ch-&gt;track, i+1, &amp;mtype);</span>
<span class="lineNum">     551 </span><span class="lineCov">          6 :                                 nb_encrypted++;</span>
<span class="lineNum">     552 </span><span class="lineCov">          6 :                                 if (!first_crypted_stsd) first_crypted_stsd = i+1;</span>
<span class="lineNum">     553 </span>            :                         } else {
<span class="lineNum">     554 </span><span class="lineCov">          6 :                                 nb_clear++;</span>
<span class="lineNum">     555 </span><span class="lineCov">          6 :                                 if (!i) first_is_clear = GF_TRUE;</span>
<span class="lineNum">     556 </span>            :                         }
<span class="lineNum">     557 </span><span class="lineCov">         12 :                         if (!i) base_subtype = mtype;</span>
<span class="lineNum">     558 </span><span class="lineCov">          6 :                         else if (base_subtype==mtype) {</span>
<span class="lineNum">     559 </span><span class="lineCov">          6 :                                 nb_same_mtype++;</span>
<span class="lineNum">     560 </span>            :                         }
<span class="lineNum">     561 </span>            :                 }
<span class="lineNum">     562 </span><span class="lineCov">          6 :                 if ((nb_same_mtype==count) &amp;&amp; (nb_clear==nb_encrypted)) {</span>
<span class="lineNum">     563 </span><span class="lineCov">          6 :                         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_CENC_STSD_MODE, &amp;PROP_UINT(first_is_clear ? 1 : 2) );</span>
<span class="lineNum">     564 </span>            :                         stsd_idx = first_crypted_stsd;
<span class="lineNum">     565 </span>            :                 }
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            :         }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineCov">        215 :         if (gf_isom_is_ismacryp_media(mov, track, stsd_idx)) {</span>
<span class="lineNum">     570 </span><span class="lineCov">         12 :                 gf_isom_get_ismacryp_info(mov, track, stsd_idx, NULL, &amp;scheme_type, &amp;scheme_version, &amp;scheme_uri, &amp;kms_uri, &amp;selectiveEncryption, &amp;IVLength, &amp;KeyIndicationLength);</span>
<span class="lineNum">     571 </span><span class="lineCov">        203 :         } else if (gf_isom_is_omadrm_media(mov, track, stsd_idx)) {</span>
<span class="lineNum">     572 </span>            :                 //u8 hash[20];
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                 gf_isom_get_omadrm_info(mov, track, stsd_idx, NULL, &amp;scheme_type, &amp;scheme_version, &amp;contentID, &amp;kms_uri, &amp;txtHdr, &amp;txtHdrLen, &amp;plainTextLen, &amp;crypt_type, &amp;selectiveEncryption, &amp;IVLength, &amp;KeyIndicationLength);</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            :                 //gf_media_get_file_hash(gf_isom_get_filename(mov), hash);
<span class="lineNum">     576 </span><span class="lineCov">        203 :         } else if (gf_isom_is_cenc_media(mov, track, stsd_idx)) {</span>
<span class="lineNum">     577 </span><span class="lineCov">        193 :                 ch-&gt;is_cenc = GF_TRUE;</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">        193 :                 gf_isom_get_cenc_info(ch-&gt;owner-&gt;mov, ch-&gt;track, stsd_idx, NULL, &amp;scheme_type, &amp;scheme_version);</span>
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            :                 //if no PSSH declared, DO update the properties (PSSH is not mandatory)
<span class="lineNum">     582 </span><span class="lineCov">         10 :         } else if (gf_isom_is_adobe_protection_media(mov, track, stsd_idx)) {</span>
<span class="lineNum">     583 </span>            :                 u32 ofmt;
<span class="lineNum">     584 </span><span class="lineCov">         10 :                 scheme_version = 1;</span>
<span class="lineNum">     585 </span><span class="lineCov">         10 :                 scheme_type = GF_ISOM_ADOBE_SCHEME;</span>
<span class="lineNum">     586 </span><span class="lineCov">         10 :                 const char *metadata = NULL;</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineCov">         10 :                 gf_isom_get_adobe_protection_info(mov, track, stsd_idx, &amp;ofmt, &amp;scheme_type, &amp;scheme_version, &amp;metadata);</span>
<span class="lineNum">     589 </span><span class="lineCov">         10 :                 if (metadata)</span>
<span class="lineNum">     590 </span><span class="lineCov">         10 :                         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_ADOBE_CRYPT_META, &amp;PROP_DATA((char *)metadata, (u32) strlen(metadata) ) );</span>
<span class="lineNum">     591 </span>            :         }
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineCov">        215 :         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &amp;PROP_4CC(scheme_type) );</span>
<span class="lineNum">     594 </span><span class="lineCov">        215 :         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION, &amp;PROP_UINT(scheme_version) );</span>
<span class="lineNum">     595 </span><span class="lineCov">        215 :         if (scheme_uri) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_PROTECTION_SCHEME_URI, &amp;PROP_STRING((char*) scheme_uri) );</span>
<span class="lineNum">     596 </span><span class="lineCov">        215 :         if (kms_uri) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_PROTECTION_KMS_URI, &amp;PROP_STRING((char*) kms_uri) );</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineCov">        215 :         if (selectiveEncryption) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_ISMA_SELECTIVE_ENC, &amp;PROP_BOOL(GF_TRUE) );</span>
<span class="lineNum">     599 </span><span class="lineCov">        215 :         if (IVLength) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_ISMA_IV_LENGTH, &amp;PROP_UINT(IVLength) );</span>
<span class="lineNum">     600 </span><span class="lineCov">        215 :         if (KeyIndicationLength) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_ISMA_KI_LENGTH, &amp;PROP_UINT(KeyIndicationLength) );</span>
<span class="lineNum">     601 </span><span class="lineCov">        215 :         if (crypt_type) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_OMA_CRYPT_TYPE, &amp;PROP_UINT(crypt_type) );</span>
<span class="lineNum">     602 </span><span class="lineCov">        215 :         if (contentID) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_OMA_CID, &amp;PROP_STRING(contentID) );</span>
<span class="lineNum">     603 </span><span class="lineCov">        215 :         if (txtHdr) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_OMA_TXT_HDR, &amp;PROP_STRING(txtHdr) );</span>
<span class="lineNum">     604 </span><span class="lineCov">        215 :         if (plainTextLen) gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_OMA_CLEAR_LEN, &amp;PROP_LONGUINT(plainTextLen) );</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineCov">        215 :         if (ch-&gt;is_cenc) {</span>
<span class="lineNum">     607 </span>            :                 const u8 *key_info;
<span class="lineNum">     608 </span>            :                 u32 key_info_size;
<span class="lineNum">     609 </span>            :                 u32 container_type;
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span><span class="lineCov">        193 :                 isor_declare_pssh(ch);</span>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineCov">        193 :                 gf_isom_cenc_get_default_info(ch-&gt;owner-&gt;mov, ch-&gt;track, stsd_idx, &amp;container_type, &amp;ch-&gt;pck_encrypted, &amp;ch-&gt;crypt_byte_block, &amp;ch-&gt;skip_byte_block, &amp;key_info, &amp;key_info_size);</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">        193 :                 gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_CENC_STORE, &amp;PROP_4CC(container_type) );</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineCov">        193 :                 gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_ENCRYPTED, &amp;PROP_BOOL(ch-&gt;pck_encrypted) );</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">        193 :                 if (ch-&gt;skip_byte_block || ch-&gt;crypt_byte_block) {</span>
<span class="lineNum">     620 </span><span class="lineCov">         39 :                         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_CENC_PATTERN, &amp;PROP_FRAC_INT(ch-&gt;skip_byte_block, ch-&gt;crypt_byte_block) );</span>
<span class="lineNum">     621 </span>            :                 }
<span class="lineNum">     622 </span><span class="lineCov">        193 :                 gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_CENC_KEY_INFO, &amp;PROP_DATA((u8 *)key_info, key_info_size) );</span>
<span class="lineNum">     623 </span><span class="lineCov">        193 :                 ch-&gt;key_info_crc = gf_crc_32(key_info, key_info_size);</span>
<span class="lineNum">     624 </span>            :         }
<span class="lineNum">     625 </span>            : }
<a name="626"><span class="lineNum">     626 </span>            : </a>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineCov">       1184 : ISOMChannel *isor_create_channel(ISOMReader *read, GF_FilterPid *pid, u32 track, u32 item_id, Bool force_no_extractors)</span>
<span class="lineNum">     629 </span>            : {
<span class="lineNum">     630 </span>            :         ISOMChannel *ch;
<span class="lineNum">     631 </span>            :         const GF_PropertyValue *p;
<span class="lineNum">     632 </span>            :         s64 ts_shift;
<span class="lineNum">     633 </span><span class="lineCov">       1184 :         if (!read-&gt;mov) return NULL;</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineCov">       1184 :         GF_SAFEALLOC(ch, ISOMChannel);</span>
<span class="lineNum">     636 </span><span class="lineCov">       1184 :         if (!ch) {</span>
<span class="lineNum">     637 </span>            :                 return NULL;
<span class="lineNum">     638 </span>            :         }
<span class="lineNum">     639 </span><span class="lineCov">       1184 :         ch-&gt;owner = read;</span>
<span class="lineNum">     640 </span><span class="lineCov">       1184 :         ch-&gt;pid = pid;</span>
<span class="lineNum">     641 </span><span class="lineCov">       1184 :         ch-&gt;to_init = GF_TRUE;</span>
<span class="lineNum">     642 </span><span class="lineCov">       1184 :         gf_list_add(read-&gt;channels, ch);</span>
<span class="lineNum">     643 </span><span class="lineCov">       1184 :         ch-&gt;track = track;</span>
<span class="lineNum">     644 </span><span class="lineCov">       1184 :         ch-&gt;item_id = item_id;</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineCov">       1184 :         ch-&gt;nalu_extract_mode = 0;</span>
<span class="lineNum">     647 </span><span class="lineCov">       1184 :         ch-&gt;track_id = gf_isom_get_track_id(read-&gt;mov, ch-&gt;track);</span>
<span class="lineNum">     648 </span><span class="lineCov">       1184 :         switch (gf_isom_get_media_type(ch-&gt;owner-&gt;mov, ch-&gt;track)) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         case GF_ISOM_MEDIA_OCR:</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :                 ch-&gt;streamType = GF_STREAM_OCR;</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     652 </span><span class="lineCov">         20 :         case GF_ISOM_MEDIA_SCENE:</span>
<span class="lineNum">     653 </span><span class="lineCov">         20 :                 ch-&gt;streamType = GF_STREAM_SCENE;</span>
<span class="lineNum">     654 </span><span class="lineCov">         20 :                 break;</span>
<span class="lineNum">     655 </span><span class="lineCov">        751 :         case GF_ISOM_MEDIA_VISUAL:</span>
<span class="lineNum">     656 </span>            :         case GF_ISOM_MEDIA_AUXV:
<span class="lineNum">     657 </span>            :         case GF_ISOM_MEDIA_PICT:
<span class="lineNum">     658 </span><span class="lineCov">        751 :                 gf_isom_get_reference(ch-&gt;owner-&gt;mov, ch-&gt;track, GF_ISOM_REF_BASE, 1, &amp;ch-&gt;base_track);</span>
<span class="lineNum">     659 </span>            :                 //use base track only if avc/svc or hevc/lhvc. If avc+lhvc we need different rules
<span class="lineNum">     660 </span><span class="lineCov">        751 :                 if ( gf_isom_get_avc_svc_type(ch-&gt;owner-&gt;mov, ch-&gt;base_track, 1) == GF_ISOM_AVCTYPE_AVC_ONLY) {</span>
<span class="lineNum">     661 </span><span class="lineCov">          4 :                         if ( gf_isom_get_hevc_lhvc_type(ch-&gt;owner-&gt;mov, ch-&gt;track, 1) &gt;= GF_ISOM_HEVCTYPE_HEVC_ONLY) {</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :                                 ch-&gt;base_track=0;</span>
<span class="lineNum">     663 </span>            :                         }
<span class="lineNum">     664 </span>            :                 }
<span class="lineNum">     665 </span><span class="lineCov">        751 :                 ch-&gt;next_track = 0;</span>
<span class="lineNum">     666 </span>            :                 /*in scalable mode add SPS/PPS in-band*/
<span class="lineNum">     667 </span><span class="lineCov">        751 :                 if (ch-&gt;base_track)</span>
<span class="lineNum">     668 </span><span class="lineCov">          6 :                         ch-&gt;nalu_extract_mode = GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG /*| GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG*/;</span>
<span class="lineNum">     669 </span>            :                 break;
<span class="lineNum">     670 </span>            :         }
<span class="lineNum">     671 </span><span class="lineCov">       1184 :         if (!read-&gt;noedit) {</span>
<span class="lineNum">     672 </span><span class="lineCov">       1107 :                 ch-&gt;ts_offset = 0;</span>
<span class="lineNum">     673 </span><span class="lineCov">       1107 :                 ch-&gt;has_edit_list = gf_isom_get_edit_list_type(ch-&gt;owner-&gt;mov, ch-&gt;track, &amp;ch-&gt;ts_offset) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">     674 </span><span class="lineCov">       1107 :                 if (!ch-&gt;has_edit_list &amp;&amp; ch-&gt;ts_offset) {</span>
<span class="lineNum">     675 </span>            :                         //if &gt;0 this is a hold, we signal positive delay
<span class="lineNum">     676 </span>            :                         //if &lt;0 this is a skip, we signal negative delay
<span class="lineNum">     677 </span><span class="lineCov">        218 :                         gf_filter_pid_set_property(pid, GF_PROP_PID_DELAY, &amp;PROP_LONGSINT( ch-&gt;ts_offset) );</span>
<span class="lineNum">     678 </span>            :                 }
<span class="lineNum">     679 </span>            :         } else
<span class="lineNum">     680 </span><span class="lineCov">         77 :                 ch-&gt;has_edit_list = GF_FALSE;</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineCov">       1184 :         ch-&gt;has_rap = (gf_isom_has_sync_points(ch-&gt;owner-&gt;mov, ch-&gt;track)==1) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">     683 </span><span class="lineCov">       1184 :         gf_filter_pid_set_property(pid, GF_PROP_PID_HAS_SYNC, &amp;PROP_BOOL(ch-&gt;has_rap) );</span>
<span class="lineNum">     684 </span>            :         //some fragmented files do not advertize a sync sample table (legal) so we need to update as soon as we fetch a fragment
<span class="lineNum">     685 </span>            :         //to see if we are all-intra (as detected here) or not
<span class="lineNum">     686 </span><span class="lineCov">       1184 :         if (!ch-&gt;has_rap &amp;&amp; ch-&gt;owner-&gt;frag_type)</span>
<span class="lineNum">     687 </span><span class="lineCov">        255 :                 ch-&gt;check_has_rap = GF_TRUE;</span>
<span class="lineNum">     688 </span><span class="lineCov">       1184 :         ch-&gt;time_scale = gf_isom_get_media_timescale(ch-&gt;owner-&gt;mov, ch-&gt;track);</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineCov">       1184 :         ts_shift = gf_isom_get_cts_to_dts_shift(ch-&gt;owner-&gt;mov, ch-&gt;track);</span>
<span class="lineNum">     691 </span><span class="lineCov">       1184 :         if (ts_shift) {</span>
<span class="lineNum">     692 </span><span class="lineCov">          6 :                 gf_filter_pid_set_property(pid, GF_PROP_PID_CTS_SHIFT, &amp;PROP_UINT((u32) ts_shift) );</span>
<span class="lineNum">     693 </span>            :         }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineCov">       1184 :         if (!track || !gf_isom_is_track_encrypted(read-&gt;mov, track)) {</span>
<span class="lineNum">     696 </span><span class="lineCov">        976 :                 if (force_no_extractors) {</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                         ch-&gt;nalu_extract_mode = GF_ISOM_NALU_EXTRACT_LAYER_ONLY;</span>
<span class="lineNum">     698 </span>            :                 } else {
<span class="lineNum">     699 </span><span class="lineCov">        976 :                         switch (read-&gt;smode) {</span>
<span class="lineNum">     700 </span><span class="lineCov">        132 :                         case MP4DMX_SPLIT_EXTRACTORS:</span>
<span class="lineNum">     701 </span><span class="lineCov">        132 :                                 ch-&gt;nalu_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT | GF_ISOM_NALU_EXTRACT_TILE_ONLY;</span>
<span class="lineNum">     702 </span><span class="lineCov">        132 :                                 break;</span>
<span class="lineNum">     703 </span><span class="lineCov">        844 :                         case MP4DMX_SPLIT:</span>
<span class="lineNum">     704 </span><span class="lineCov">        844 :                                 ch-&gt;nalu_extract_mode = GF_ISOM_NALU_EXTRACT_LAYER_ONLY | GF_ISOM_NALU_EXTRACT_TILE_ONLY;</span>
<span class="lineNum">     705 </span><span class="lineCov">        844 :                                 break;</span>
<span class="lineNum">     706 </span>            :                         default:
<span class="lineNum">     707 </span>            :                                 break;
<span class="lineNum">     708 </span>            :                         }
<span class="lineNum">     709 </span>            :                 }
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">        976 :                 if (ch-&gt;nalu_extract_mode) {</span>
<span class="lineNum">     712 </span><span class="lineCov">        976 :                         gf_isom_set_nalu_extract_mode(ch-&gt;owner-&gt;mov, ch-&gt;track, ch-&gt;nalu_extract_mode);</span>
<span class="lineNum">     713 </span>            :                 }
<span class="lineNum">     714 </span>            :                 return ch;
<span class="lineNum">     715 </span>            :         }
<span class="lineNum">     716 </span><span class="lineCov">        208 :         if (ch-&gt;owner-&gt;nocrypt) {</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :                 ch-&gt;is_encrypted = GF_FALSE;</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :                 return ch;</span>
<span class="lineNum">     719 </span>            :         }
<span class="lineNum">     720 </span><span class="lineCov">        208 :         ch-&gt;is_encrypted = GF_TRUE;</span>
<span class="lineNum">     721 </span><span class="lineCov">        208 :         p = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);</span>
<span class="lineNum">     722 </span><span class="lineCov">        208 :         if (p) gf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_STREAM_TYPE, &amp;PROP_UINT(p-&gt;value.uint) );</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">        208 :         gf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &amp;PROP_UINT(GF_STREAM_ENCRYPTED) );</span>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">        208 :         isor_set_crypt_config(ch);</span>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineCov">        208 :         if (ch-&gt;nalu_extract_mode) {</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :                 if (ch-&gt;is_encrypted) {</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (&quot;[IsoMedia] using sample NAL rewrite with encryption is not yet supported, patch welcome\n&quot;));</span>
<span class="lineNum">     731 </span>            :                 } else {
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :                         gf_isom_set_nalu_extract_mode(ch-&gt;owner-&gt;mov, ch-&gt;track, ch-&gt;nalu_extract_mode);</span>
<span class="lineNum">     733 </span>            :                 }
<span class="lineNum">     734 </span>            :         }
<span class="lineNum">     735 </span>            :         return ch;
<span class="lineNum">     736 </span>            : }
<span class="lineNum">     737 </span>            : 
<a name="738"><span class="lineNum">     738 </span>            : /*switch channel quality. Return next channel or current channel if error*/</a>
<span class="lineNum">     739 </span>            : static
<span class="lineNum">     740 </span><span class="lineNoCov">          0 : u32 isoffin_channel_switch_quality(ISOMChannel *ch, GF_ISOFile *the_file, Bool switch_up)</span>
<span class="lineNum">     741 </span>            : {
<span class="lineNum">     742 </span>            :         u32 i, count, next_track, trackID, cur_track;
<span class="lineNum">     743 </span>            :         s32 ref_count;
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         cur_track = ch-&gt;next_track ? ch-&gt;next_track : ch-&gt;track;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         count = gf_isom_get_track_count(the_file);</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         trackID = gf_isom_get_track_id(the_file, cur_track);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         next_track = 0;</span>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :         if (switch_up) {</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; count; i++) {</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :                         ref_count = gf_isom_get_reference_count(the_file, i+1, GF_ISOM_REF_SCAL);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :                         if (ref_count &lt; 0)</span>
<span class="lineNum">     754 </span>            :                                 return cur_track; //error
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :                         if (ref_count == 0)</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">     757 </span>            :                         /*next track is the one that has the last reference of type GF_ISOM_REF_SCAL refers to this current track*/
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :                         if ((u32)ref_count == gf_isom_has_track_reference(the_file, i+1, GF_ISOM_REF_SCAL, trackID)) {</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                                 next_track = i+1;</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">     761 </span>            :                         }
<span class="lineNum">     762 </span>            :                 }
<span class="lineNum">     763 </span>            :                 /*this is the highest quality*/
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :                 if (!next_track) {</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                         ch-&gt;playing = GF_TRUE;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                         ref_count = gf_isom_get_reference_count(the_file, ch-&gt;track, GF_ISOM_REF_BASE);</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :                         trackID = 0;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :                         if (ref_count) {</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :                                 gf_isom_get_reference(the_file, ch-&gt;track, GF_ISOM_REF_BASE, 1, &amp;trackID);</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :                                 for (i=0; i&lt;gf_list_count(ch-&gt;owner-&gt;channels) &amp;&amp; trackID; i++) {</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :                                         ISOMChannel *base = gf_list_get(ch-&gt;owner-&gt;channels, i);</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :                                         if (base-&gt;track_id==trackID) {</span>
<span class="lineNum">     773 </span>            :                                                 u32 sample_desc_index;
<span class="lineNum">     774 </span>            :                                                 u64 resume_at;
<span class="lineNum">     775 </span>            :                                                 GF_Err e;
<span class="lineNum">     776 </span>            :                                                 //try to locate sync after current time in base
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                                                 resume_at = base-&gt;static_sample-&gt;DTS;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :                                                 resume_at *= ch-&gt;time_scale;</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :                                                 resume_at /= base-&gt;time_scale;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :                                                 e = gf_isom_get_sample_for_media_time(ch-&gt;owner-&gt;mov, ch-&gt;track, resume_at, &amp;sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &amp;ch-&gt;static_sample, &amp;ch-&gt;sample_num, &amp;ch-&gt;sample_data_offset);</span>
<span class="lineNum">     781 </span>            :                                                 //found, rewind so that next fetch is the sync
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :                                                 if (e==GF_OK) {</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :                                                         ch-&gt;sample = NULL;</span>
<span class="lineNum">     784 </span>            :                                                 }
<span class="lineNum">     785 </span>            :                                                 //no further sync found, realign with base timescale
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                                                 else if (e==GF_EOS) {</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :                                                         e = gf_isom_get_sample_for_media_time(ch-&gt;owner-&gt;mov, ch-&gt;track, resume_at, &amp;sample_desc_index, GF_ISOM_SEARCH_FORWARD, &amp;ch-&gt;static_sample, &amp;ch-&gt;sample_num, &amp;ch-&gt;sample_data_offset);</span>
<span class="lineNum">     788 </span>            :                                                 }
<span class="lineNum">     789 </span>            :                                                 //unknown state, realign sample num with base
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :                                                 if (e&lt;0) {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :                                                         ch-&gt;sample_num = base-&gt;sample_num;</span>
<span class="lineNum">     792 </span>            :                                                 }
<span class="lineNum">     793 </span>            :                                                 break;
<span class="lineNum">     794 </span>            :                                         }
<span class="lineNum">     795 </span>            :                                 }
<span class="lineNum">     796 </span>            :                         }
<span class="lineNum">     797 </span>            :                         return cur_track;
<span class="lineNum">     798 </span>            :                 }
<span class="lineNum">     799 </span>            :         } else {
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :                 if (cur_track == ch-&gt;base_track)</span>
<span class="lineNum">     801 </span>            :                         return cur_track;
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :                 ref_count = gf_isom_get_reference_count(the_file, cur_track, GF_ISOM_REF_SCAL);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :                 if (ref_count &lt;= 0)</span>
<span class="lineNum">     804 </span>            :                         return cur_track;
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :                 gf_isom_get_reference(the_file, cur_track, GF_ISOM_REF_SCAL, ref_count, &amp;next_track);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :                 if (!next_track)</span>
<span class="lineNum">     807 </span>            :                         return cur_track;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                 if (ch-&gt;track != next_track) {</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :                         ch-&gt;playing = GF_FALSE;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                         ch-&gt;eos_sent = GF_TRUE;</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :                         gf_filter_pid_set_eos(ch-&gt;pid);</span>
<span class="lineNum">     813 </span>            :                 }
<span class="lineNum">     814 </span>            :         }
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :         /*in scalable mode add SPS/PPS in-band*/
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         if (ch-&gt;owner-&gt;smode)</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :                 gf_isom_set_nalu_extract_mode(the_file, next_track, ch-&gt;nalu_extract_mode);</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         return next_track;</span>
<a name="821"><span class="lineNum">     821 </span>            : }</a>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineCov">      76195 : static Bool isoffin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)</span>
<span class="lineNum">     824 </span>            : {
<span class="lineNum">     825 </span>            :         u32 count, i;
<span class="lineNum">     826 </span>            :         Bool cancel_event = GF_TRUE;
<span class="lineNum">     827 </span>            :         ISOMChannel *ch;
<span class="lineNum">     828 </span><span class="lineCov">      76195 :         ISOMReader *read = gf_filter_get_udta(filter);</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineCov">      76195 :         if (!read || read-&gt;disconnected) return GF_FALSE;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineCov">      76195 :         if (evt-&gt;base.type == GF_FEVT_QUALITY_SWITCH) {</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :                 count = gf_list_count(read-&gt;channels);</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; count; i++) {</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :                         ch = (ISOMChannel *)gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :                         if (ch-&gt;base_track &amp;&amp; gf_isom_needs_layer_reconstruction(read-&gt;mov)) {</span>
<span class="lineNum">     837 </span>            :                                 /*ch-&gt;next_track = */ //old code, see not in isoffin_reconfigure
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :                                 isoffin_channel_switch_quality(ch, read-&gt;mov, evt-&gt;quality_switch.up);</span>
<span class="lineNum">     839 </span>            :                         }
<span class="lineNum">     840 </span>            :                 }
<span class="lineNum">     841 </span>            :                 return GF_TRUE;
<span class="lineNum">     842 </span>            :         }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineCov">      76195 :         if (!evt-&gt;base.on_pid) return GF_FALSE;</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :         ch = isor_get_channel(read, evt-&gt;base.on_pid);
<span class="lineNum">     847 </span><span class="lineCov">      76195 :         if (!ch)</span>
<span class="lineNum">     848 </span>            :                 return GF_FALSE;
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineCov">       2620 :         switch (evt-&gt;base.type) {</span>
<span class="lineNum">     851 </span><span class="lineCov">       1207 :         case GF_FEVT_PLAY:</span>
<span class="lineNum">     852 </span><span class="lineCov">       1207 :                 isor_reset_reader(ch);</span>
<span class="lineNum">     853 </span><span class="lineCov">       1207 :                 ch-&gt;eos_sent = GF_FALSE;</span>
<span class="lineNum">     854 </span><span class="lineCov">       1207 :                 ch-&gt;speed = evt-&gt;play.speed;</span>
<span class="lineNum">     855 </span><span class="lineCov">       1207 :                 ch-&gt;initial_play_seen = GF_TRUE;</span>
<span class="lineNum">     856 </span><span class="lineCov">       1207 :                 read-&gt;reset_frag_state = 1;</span>
<span class="lineNum">     857 </span>            :                 //it can happen that input_is_stop is still TRUE because we did not get called back after the stop - reset to FALSE since we now play
<span class="lineNum">     858 </span><span class="lineCov">       1207 :                 read-&gt;input_is_stop = GF_FALSE;</span>
<span class="lineNum">     859 </span><span class="lineCov">       1207 :                 if (read-&gt;frag_type)</span>
<span class="lineNum">     860 </span><span class="lineCov">        262 :                         read-&gt;frag_type = 1;</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineCov">       1207 :                 ch-&gt;start = ch-&gt;end = 0;</span>
<span class="lineNum">     863 </span><span class="lineCov">       1207 :                 if (evt-&gt;play.speed&gt;=0) {</span>
<span class="lineNum">     864 </span>            :                         Double t;
<span class="lineNum">     865 </span><span class="lineCov">       1205 :                         if (evt-&gt;play.start_range&gt;=0) {</span>
<span class="lineNum">     866 </span>            :                                 t = evt-&gt;play.start_range;
<span class="lineNum">     867 </span><span class="lineCov">       1205 :                                 t *= ch-&gt;time_scale;</span>
<span class="lineNum">     868 </span><span class="lineCov">       1205 :                                 ch-&gt;start = (u64) t;</span>
<span class="lineNum">     869 </span>            :                         }
<span class="lineNum">     870 </span><span class="lineCov">       1205 :                         if (evt-&gt;play.end_range &gt;= evt-&gt;play.start_range) {</span>
<span class="lineNum">     871 </span><span class="lineCov">       1197 :                                 ch-&gt;end = (u64) -1;</span>
<span class="lineNum">     872 </span><span class="lineCov">       1197 :                                 if (evt-&gt;play.end_range&lt;FLT_MAX) {</span>
<span class="lineNum">     873 </span>            :                                         t = evt-&gt;play.end_range;
<span class="lineNum">     874 </span><span class="lineCov">       1191 :                                         t *= ch-&gt;time_scale;</span>
<span class="lineNum">     875 </span><span class="lineCov">       1191 :                                         ch-&gt;end = (u64) t;</span>
<span class="lineNum">     876 </span>            :                                 }
<span class="lineNum">     877 </span>            :                         }
<span class="lineNum">     878 </span>            :                 } else {
<span class="lineNum">     879 </span><span class="lineCov">          2 :                         Double end = evt-&gt;play.end_range;</span>
<span class="lineNum">     880 </span><span class="lineCov">          2 :                         if (end==-1) end = 0;</span>
<span class="lineNum">     881 </span><span class="lineCov">          2 :                         ch-&gt;start = (u64) (s64) (evt-&gt;play.start_range * ch-&gt;time_scale);</span>
<span class="lineNum">     882 </span><span class="lineCov">          2 :                         if (end &lt;= evt-&gt;play.start_range)</span>
<span class="lineNum">     883 </span><span class="lineCov">          2 :                                 ch-&gt;end = (u64) (s64) (end  * ch-&gt;time_scale);</span>
<span class="lineNum">     884 </span>            :                 }
<span class="lineNum">     885 </span><span class="lineCov">       1207 :                 ch-&gt;playing = GF_TRUE;</span>
<span class="lineNum">     886 </span><span class="lineCov">       1207 :                 ch-&gt;sample_num = evt-&gt;play.from_pck;</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineCov">       1207 :                 ch-&gt;sap_only = evt-&gt;play.drop_non_ref ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">       1207 :                 GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (&quot;[IsoMedia] Starting channel playback &quot;LLD&quot; to &quot;LLD&quot; (%g to %g)\n&quot;, ch-&gt;start, ch-&gt;end, evt-&gt;play.start_range, evt-&gt;play.end_range));</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineCov">       1207 :                 if (!read-&gt;nb_playing)</span>
<span class="lineNum">     893 </span><span class="lineCov">       1005 :                         gf_isom_reset_seq_num(read-&gt;mov);</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineCov">       1207 :                 if (read-&gt;is_partial_download) read-&gt;input_loaded = GF_FALSE;</span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineCov">       1207 :                 if (evt-&gt;play.no_byterange_forward) {</span>
<span class="lineNum">     898 </span>            :                         //new segment will be loaded, reset
<span class="lineNum">     899 </span><span class="lineCov">        242 :                         gf_isom_reset_tables(read-&gt;mov, GF_TRUE);</span>
<span class="lineNum">     900 </span><span class="lineCov">        242 :                         gf_isom_reset_data_offset(read-&gt;mov, NULL);</span>
<span class="lineNum">     901 </span><span class="lineCov">        242 :                         read-&gt;refresh_fragmented = GF_TRUE;</span>
<span class="lineNum">     902 </span><span class="lineCov">        242 :                         read-&gt;mem_blob.size = 0;</span>
<span class="lineNum">     903 </span>            :                         //send play event
<span class="lineNum">     904 </span>            :                         cancel_event = GF_FALSE;
<span class="lineNum">     905 </span><span class="lineCov">        965 :                 } else if (!read-&gt;nb_playing &amp;&amp; read-&gt;pid &amp;&amp; !read-&gt;input_loaded) {</span>
<span class="lineNum">     906 </span>            :                         GF_FilterEvent fevt;
<span class="lineNum">     907 </span>            :                         Bool is_sidx_seek = GF_FALSE;
<span class="lineNum">     908 </span><span class="lineCov">          4 :                         u64 max_offset = GF_FILTER_NO_BO;</span>
<span class="lineNum">     909 </span><span class="lineCov">          4 :                         count = gf_list_count(read-&gt;channels);</span>
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            :                         //try sidx
<span class="lineNum">     912 </span><span class="lineCov">          4 :                         if (read-&gt;frag_type) {</span>
<span class="lineNum">     913 </span>            :                                 u32 ts;
<span class="lineNum">     914 </span><span class="lineCov">          1 :                                 u64 dur=0;</span>
<span class="lineNum">     915 </span><span class="lineCov">          1 :                                 GF_Err e = gf_isom_get_file_offset_for_time(read-&gt;mov, evt-&gt;play.start_range, &amp;max_offset);</span>
<span class="lineNum">     916 </span><span class="lineCov">          1 :                                 if (e==GF_OK) {</span>
<span class="lineNum">     917 </span><span class="lineCov">          1 :                                         if (evt-&gt;play.start_range&gt;0)</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                                                 gf_isom_reset_tables(read-&gt;mov, GF_TRUE);</span>
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :                                         is_sidx_seek = GF_TRUE;
<span class="lineNum">     921 </span>            :                                         //in case we loaded moov but not sidx, update duration
<span class="lineNum">     922 </span><span class="lineCov">          1 :                                         if ((gf_isom_get_sidx_duration(read-&gt;mov, &amp;dur, &amp;ts)==GF_OK) &amp;&amp; dur) {</span>
<span class="lineNum">     923 </span><span class="lineCov">          1 :                                                 dur *= read-&gt;time_scale;</span>
<span class="lineNum">     924 </span><span class="lineCov">          1 :                                                 dur /= ts;</span>
<span class="lineNum">     925 </span><span class="lineCov">          1 :                                                 if (ch-&gt;duration != dur) {</span>
<span class="lineNum">     926 </span><span class="lineCov">          1 :                                                         ch-&gt;duration = dur;</span>
<span class="lineNum">     927 </span><span class="lineCov">          1 :                                                         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_DURATION, &amp;PROP_FRAC64_INT(ch-&gt;duration, read-&gt;time_scale));</span>
<span class="lineNum">     928 </span>            :                                                 }
<span class="lineNum">     929 </span>            :                                         }
<span class="lineNum">     930 </span>            :                                 }
<span class="lineNum">     931 </span>            :                         }
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            :                         if (!is_sidx_seek) {
<span class="lineNum">     934 </span><span class="lineCov">          3 :                                 for (i=0; i&lt; count; i++) {</span>
<span class="lineNum">     935 </span>            :                                         u32 mode, sample_desc_index, sample_num;
<span class="lineNum">     936 </span>            :                                         u64 data_offset;
<span class="lineNum">     937 </span>            :                                         GF_Err e;
<span class="lineNum">     938 </span>            :                                         u64 time;
<span class="lineNum">     939 </span><span class="lineCov">          3 :                                         ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">     940 </span><span class="lineCov">          3 :                                         mode = ch-&gt;disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;</span>
<span class="lineNum">     941 </span><span class="lineCov">          3 :                                         time = (u64) (evt-&gt;play.start_range * ch-&gt;time_scale);</span>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            :                                         /*take care of seeking out of the track range*/
<span class="lineNum">     944 </span><span class="lineCov">          3 :                                         if (!read-&gt;frag_type &amp;&amp; (ch-&gt;duration &lt; time)) {</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                                                 e = gf_isom_get_sample_for_movie_time(read-&gt;mov, ch-&gt;track, ch-&gt;duration,      &amp;sample_desc_index, mode, NULL, &amp;sample_num, &amp;data_offset);</span>
<span class="lineNum">     946 </span>            :                                         } else {
<span class="lineNum">     947 </span><span class="lineCov">          3 :                                                 e = gf_isom_get_sample_for_movie_time(read-&gt;mov, ch-&gt;track, time, &amp;sample_desc_index, mode, NULL, &amp;sample_num, &amp;data_offset);</span>
<span class="lineNum">     948 </span>            :                                         }
<span class="lineNum">     949 </span><span class="lineCov">          3 :                                         if ((e == GF_OK) &amp;&amp; (data_offset&lt;max_offset))</span>
<span class="lineNum">     950 </span><span class="lineCov">          3 :                                                 max_offset = data_offset;</span>
<span class="lineNum">     951 </span>            :                                 }
<span class="lineNum">     952 </span>            :                         }
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineCov">          4 :                         if ((evt-&gt;play.start_range || read-&gt;is_partial_download)  &amp;&amp; (max_offset != GF_FILTER_NO_BO) ) {</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            :                                 //send a seek request
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :                                 read-&gt;is_partial_download = GF_TRUE;</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :                                 read-&gt;wait_for_source = GF_TRUE;</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                                 read-&gt;refresh_fragmented = GF_TRUE;</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                                 GF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, read-&gt;pid);</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :                                 fevt.seek.start_offset = max_offset;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                                 gf_filter_pid_send_event(read-&gt;pid, &amp;fevt);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                                 gf_isom_set_byte_offset(read-&gt;mov, is_sidx_seek ? 0 : max_offset);</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :                         }
<span class="lineNum">     967 </span>            :                 }
<span class="lineNum">     968 </span>            :                 //always request a process task upon a play
<span class="lineNum">     969 </span><span class="lineCov">       1207 :                 gf_filter_post_process_task(read-&gt;filter);</span>
<span class="lineNum">     970 </span><span class="lineCov">       1207 :                 read-&gt;nb_playing++;</span>
<span class="lineNum">     971 </span>            :                 //cancel event unless dash mode
<span class="lineNum">     972 </span><span class="lineCov">       1207 :                 return cancel_event;</span>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineCov">        285 :         case GF_FEVT_STOP:</span>
<span class="lineNum">     975 </span><span class="lineCov">        285 :                 if (read-&gt;nb_playing) read-&gt;nb_playing--;</span>
<span class="lineNum">     976 </span><span class="lineCov">        285 :                 isor_reset_reader(ch);</span>
<span class="lineNum">     977 </span>            :                 //don't send a stop if some of our channels are still waiting for initial play
<span class="lineNum">     978 </span><span class="lineCov">        764 :                 for (i=0; i&lt;gf_list_count(read-&gt;channels); i++) {</span>
<span class="lineNum">     979 </span><span class="lineCov">        517 :                         ISOMChannel *a_ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">     980 </span><span class="lineCov">        517 :                         if (ch==a_ch) continue;</span>
<span class="lineNum">     981 </span><span class="lineCov">        251 :                         if (!a_ch-&gt;initial_play_seen) return GF_TRUE;</span>
<span class="lineNum">     982 </span>            :                 }
<span class="lineNum">     983 </span>            :                 //cancel event if nothing playing
<span class="lineNum">     984 </span><span class="lineCov">        247 :                 if (read-&gt;nb_playing) return GF_TRUE;</span>
<span class="lineNum">     985 </span><span class="lineCov">        215 :                 read-&gt;input_is_stop = GF_TRUE;</span>
<span class="lineNum">     986 </span><span class="lineCov">        215 :                 return GF_FALSE;</span>
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span><span class="lineCov">        214 :         case GF_FEVT_SET_SPEED:</span>
<span class="lineNum">     989 </span>            :         case GF_FEVT_RESUME:
<span class="lineNum">     990 </span><span class="lineCov">        214 :                 ch-&gt;speed = evt-&gt;play.speed;</span>
<span class="lineNum">     991 </span><span class="lineCov">        214 :                 if (ch-&gt;sap_only &amp;&amp; !evt-&gt;play.drop_non_ref) {</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :                         ch-&gt;sap_only = 2;</span>
<span class="lineNum">     993 </span>            :                 } else {
<span class="lineNum">     994 </span><span class="lineCov">        214 :                         ch-&gt;sap_only = evt-&gt;play.drop_non_ref ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">     995 </span>            :                 }
<span class="lineNum">     996 </span>            :                 //cancel event
<span class="lineNum">     997 </span>            :                 return GF_TRUE;
<span class="lineNum">     998 </span>            :         default:
<span class="lineNum">     999 </span>            :                 break;
<span class="lineNum">    1000 </span>            :         }
<span class="lineNum">    1001 </span>            :         //by default don't cancel event
<span class="lineNum">    1002 </span>            :         return GF_FALSE;
<a name="1003"><span class="lineNum">    1003 </span>            : }</a>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineCov">       3981 : static void isoffin_push_buffer(GF_Filter *filter, ISOMReader *read, const u8 *pck_data, u32 data_size)</span>
<span class="lineNum">    1006 </span>            : {
<span class="lineNum">    1007 </span>            :         u64 bytes_missing;
<span class="lineNum">    1008 </span>            :         GF_Err e;
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span><span class="lineCov">       3981 :         if (!read-&gt;mem_url) {</span>
<span class="lineNum">    1011 </span>            :                 char szPath[200];
<span class="lineNum">    1012 </span><span class="lineCov">          4 :                 sprintf(szPath, &quot;gmem://%p&quot;, &amp;read-&gt;mem_blob);</span>
<span class="lineNum">    1013 </span><span class="lineCov">          4 :                 read-&gt;mem_url = gf_strdup(szPath);</span>
<span class="lineNum">    1014 </span>            :         }
<span class="lineNum">    1015 </span><span class="lineCov">       3981 :         read-&gt;mem_blob.data = gf_realloc(read-&gt;mem_blob.data, read-&gt;mem_blob.size + data_size);</span>
<span class="lineNum">    1016 </span><span class="lineCov">       3981 :         memcpy(read-&gt;mem_blob.data + read-&gt;mem_blob.size, pck_data, data_size);</span>
<span class="lineNum">    1017 </span><span class="lineCov">       3981 :         read-&gt;mem_blob.size += data_size;</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineCov">       3981 :         if (read-&gt;mem_load_mode==1) {</span>
<span class="lineNum">    1020 </span>            :                 u32 box_type;
<span class="lineNum">    1021 </span><span class="lineCov">          8 :                 e = gf_isom_open_progressive_ex(read-&gt;mem_url, 0, 0, GF_FALSE, &amp;read-&gt;mov, &amp;bytes_missing, &amp;box_type);</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span><span class="lineCov">          8 :                 if (e &amp;&amp; (e != GF_ISOM_INCOMPLETE_FILE)) {</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                         gf_filter_setup_failure(filter, e);</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :                         read-&gt;mem_load_mode = 0;</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :                         read-&gt;in_error = e;</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    1028 </span>            :                 }
<span class="lineNum">    1029 </span><span class="lineCov">          8 :                 if (!read-&gt;mov) {</span>
<span class="lineNum">    1030 </span><span class="lineCov">          4 :                         switch (box_type) {</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                         case GF_4CC('m','d','a','t'):</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (&quot;[IsoMedia] non fragmented ISOBMFF with moof after mdat and no underlying file cache (pipe or other stream input), not supported !\n&quot;));</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                                 gf_filter_setup_failure(filter, GF_NOT_SUPPORTED);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                                 read-&gt;mem_load_mode = 0;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                                 read-&gt;in_error = GF_NOT_SUPPORTED;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1037 </span><span class="lineCov">          4 :                         default:</span>
<span class="lineNum">    1038 </span><span class="lineCov">          4 :                                 read-&gt;moov_not_loaded = 1;</span>
<span class="lineNum">    1039 </span><span class="lineCov">          4 :                                 break;</span>
<span class="lineNum">    1040 </span>            :                         }
<span class="lineNum">    1041 </span>            :                         return;
<span class="lineNum">    1042 </span>            :                 }
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span><span class="lineCov">          4 :                 read-&gt;frag_type = gf_isom_is_fragmented(read-&gt;mov) ? 1 : 0;</span>
<span class="lineNum">    1045 </span><span class="lineCov">          4 :                 read-&gt;time_scale = gf_isom_get_timescale(read-&gt;mov);</span>
<span class="lineNum">    1046 </span><span class="lineCov">          4 :                 isor_declare_objects(read);</span>
<span class="lineNum">    1047 </span><span class="lineCov">          4 :                 read-&gt;mem_load_mode = 2;</span>
<span class="lineNum">    1048 </span><span class="lineCov">          4 :                 read-&gt;moov_not_loaded = 0;</span>
<span class="lineNum">    1049 </span><span class="lineCov">          4 :                 return;</span>
<span class="lineNum">    1050 </span>            :         }
<span class="lineNum">    1051 </span>            :         //refresh file
<span class="lineNum">    1052 </span><span class="lineCov">       3973 :         gf_isom_refresh_fragmented(read-&gt;mov, &amp;bytes_missing, read-&gt;mem_url);</span>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span><span class="lineCov">       3973 :         if ((read-&gt;mem_load_mode==2) &amp;&amp; bytes_missing)</span>
<span class="lineNum">    1055 </span><span class="lineCov">       3756 :                 read-&gt;force_fetch = GF_TRUE;</span>
<span class="lineNum">    1056 </span>            : 
<a name="1057"><span class="lineNum">    1057 </span>            : }</a>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineCov">      30768 : static void isoffin_purge_mem(ISOMReader *read, u64 min_offset)</span>
<span class="lineNum">    1060 </span>            : {
<span class="lineNum">    1061 </span>            :         u32 i, count;
<span class="lineNum">    1062 </span>            :         u64 top_offset;
<span class="lineNum">    1063 </span>            :         u32 nb_bytes_to_purge;
<span class="lineNum">    1064 </span>            :         u64 bytes_missing;
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :         //purge every
<span class="lineNum">    1067 </span><span class="lineCov">      30768 :         if (read-&gt;mstore_purge &amp;&amp; (min_offset - read-&gt;last_min_offset &lt; read-&gt;mstore_purge))</span>
<span class="lineNum">    1068 </span><span class="lineCov">      30693 :                 return;</span>
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span><span class="lineCov">        361 :         if (read-&gt;frag_type) {</span>
<span class="lineNum">    1071 </span>            :                 //get position of current box being parsed - if new offset is greater than this box we cannot remove
<span class="lineNum">    1072 </span>            :                 //bytes (we would trash the top-level box header)
<span class="lineNum">    1073 </span><span class="lineCov">         82 :                 gf_isom_get_current_top_box_offset(read-&gt;mov, &amp;top_offset);</span>
<span class="lineNum">    1074 </span><span class="lineCov">         82 :                 if (top_offset&lt;min_offset) {</span>
<span class="lineNum">    1075 </span>            :                         return;
<span class="lineNum">    1076 </span>            :                 }
<span class="lineNum">    1077 </span>            :         }
<span class="lineNum">    1078 </span><span class="lineCov">        354 :         read-&gt;last_min_offset = min_offset;</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :         assert(min_offset&gt;=read-&gt;bytes_removed);
<span class="lineNum">    1081 </span>            :         //min_offset is given in absolute file position
<span class="lineNum">    1082 </span><span class="lineCov">        354 :         nb_bytes_to_purge = (u32) (min_offset - read-&gt;bytes_removed);</span>
<span class="lineNum">    1083 </span>            :         assert(nb_bytes_to_purge&lt;=read-&gt;mem_blob.size);
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span><span class="lineCov">        354 :         memmove(read-&gt;mem_blob.data, read-&gt;mem_blob.data+nb_bytes_to_purge, read-&gt;mem_blob.size - nb_bytes_to_purge);</span>
<span class="lineNum">    1086 </span><span class="lineCov">        354 :         read-&gt;mem_blob.size -= nb_bytes_to_purge;</span>
<span class="lineNum">    1087 </span><span class="lineCov">        354 :         read-&gt;bytes_removed += nb_bytes_to_purge;</span>
<span class="lineNum">    1088 </span><span class="lineCov">        354 :         gf_isom_set_removed_bytes(read-&gt;mov, read-&gt;bytes_removed);</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineCov">        354 :         GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (&quot;[IsoMedia] mem mode %d bytes in mem, &quot;LLU&quot; bytes trashed since start\n&quot;, read-&gt;mem_blob.size, read-&gt;bytes_removed));</span>
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :         //force a refresh
<span class="lineNum">    1093 </span><span class="lineCov">        354 :         gf_isom_refresh_fragmented(read-&gt;mov, &amp;bytes_missing, read-&gt;mem_url);</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineCov">        354 :         if (!read-&gt;frag_type)</span>
<span class="lineNum">    1096 </span>            :                 return;
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            :         //fragmented file, cleanup sample tables
<span class="lineNum">    1099 </span><span class="lineCov">         75 :         count = gf_list_count(read-&gt;channels);</span>
<span class="lineNum">    1100 </span><span class="lineCov">        150 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1101 </span><span class="lineCov">         75 :                 ISOMChannel *ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">    1102 </span>            :                 u32 num_samples;
<span class="lineNum">    1103 </span><span class="lineCov">         75 :                 u32 prev_samples = gf_isom_get_sample_count(read-&gt;mov, ch-&gt;track);</span>
<span class="lineNum">    1104 </span>            :                 //don't run this too often
<span class="lineNum">    1105 </span><span class="lineCov">         75 :                 if (ch-&gt;sample_num&lt;=1+read-&gt;mstore_samples) continue;</span>
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span><span class="lineCov">         75 :                 num_samples = ch-&gt;sample_num-1;</span>
<span class="lineNum">    1108 </span><span class="lineCov">         75 :                 if (num_samples&gt;=prev_samples) continue;</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineCov">         75 :                 if (gf_isom_purge_samples(read-&gt;mov, ch-&gt;track, num_samples) == GF_OK)</span>
<span class="lineNum">    1111 </span><span class="lineCov">         75 :                         ch-&gt;sample_num = 1;</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineCov">         75 :                 num_samples = gf_isom_get_sample_count(read-&gt;mov, ch-&gt;track);</span>
<span class="lineNum">    1114 </span>            :                 assert(ch-&gt;sample_num&lt;=num_samples);
<span class="lineNum">    1115 </span><span class="lineCov">         75 :                 GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (&quot;[IsoMedia] mem mode %d samples now in track %d (prev %d)\n&quot;, num_samples, ch-&gt;track_id, prev_samples));</span>
<span class="lineNum">    1116 </span>            :         }
<a name="1117"><span class="lineNum">    1117 </span>            : }</a>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineCov">     293308 : static GF_Err isoffin_process(GF_Filter *filter)</span>
<span class="lineNum">    1120 </span>            : {
<span class="lineNum">    1121 </span><span class="lineCov">     293308 :         ISOMReader *read = gf_filter_get_udta(filter);</span>
<span class="lineNum">    1122 </span><span class="lineCov">     293308 :         u32 i, count = gf_list_count(read-&gt;channels);</span>
<span class="lineNum">    1123 </span>            :         Bool is_active = GF_FALSE;
<span class="lineNum">    1124 </span>            :         Bool in_is_eos = GF_FALSE;
<span class="lineNum">    1125 </span>            :         Bool check_forced_end = GF_FALSE;
<span class="lineNum">    1126 </span>            :         Bool has_new_data = GF_FALSE;
<span class="lineNum">    1127 </span>            :         u64 min_offset_plus_one = 0;
<span class="lineNum">    1128 </span>            :         u32 nb_forced_end=0;
<span class="lineNum">    1129 </span><span class="lineCov">     293308 :         if (read-&gt;in_error)</span>
<span class="lineNum">    1130 </span>            :                 return read-&gt;in_error;
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineCov">     293308 :         if (read-&gt;pid) {</span>
<span class="lineNum">    1133 </span>            :                 Bool fetch_input = GF_TRUE;
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            :                 //we failed at loading the init segment during a dash switch, retry
<span class="lineNum">    1136 </span><span class="lineCov">     245291 :                 if (!read-&gt;is_partial_download &amp;&amp; !read-&gt;mem_load_mode &amp;&amp; (read-&gt;moov_not_loaded==2) ) {</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                         isoffin_configure_pid(filter, read-&gt;pid, GF_FALSE);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                         if (read-&gt;moov_not_loaded) return GF_OK;</span>
<span class="lineNum">    1139 </span>            :                 }
<span class="lineNum">    1140 </span><span class="lineCov">     245291 :                 if (read-&gt;mem_load_mode==2) {</span>
<span class="lineNum">    1141 </span><span class="lineCov">      30771 :                         if (!read-&gt;force_fetch &amp;&amp; read-&gt;mem_blob.size &gt; read-&gt;mstore_size) {</span>
<span class="lineNum">    1142 </span>            :                                 fetch_input = GF_FALSE;
<span class="lineNum">    1143 </span>            :                         }
<span class="lineNum">    1144 </span><span class="lineCov">      30771 :                         read-&gt;force_fetch = GF_FALSE;</span>
<span class="lineNum">    1145 </span>            :                 }
<span class="lineNum">    1146 </span><span class="lineCov">     319305 :                 while (fetch_input) {</span>
<span class="lineNum">    1147 </span><span class="lineCov">     308624 :                         GF_FilterPacket *pck = gf_filter_pid_get_packet(read-&gt;pid);</span>
<span class="lineNum">    1148 </span><span class="lineCov">     308624 :                         if (!pck) {</span>
<span class="lineNum">    1149 </span>            :                                 //we issued a seek, wait for the first packet to be received before fetching channels
<span class="lineNum">    1150 </span>            :                                 //otherwise we could end up reading from the wrong cache
<span class="lineNum">    1151 </span><span class="lineCov">     234610 :                                 if (read-&gt;wait_for_source) {</span>
<span class="lineNum">    1152 </span>            :                                         //something went wrong during the seek request
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                                         if (gf_filter_pid_is_eos(read-&gt;pid))</span>
<span class="lineNum">    1154 </span>            :                                                 return GF_EOS;
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                                         return GF_OK;</span>
<span class="lineNum">    1156 </span>            :                                 }
<span class="lineNum">    1157 </span>            :                                 break;
<span class="lineNum">    1158 </span>            :                         }
<span class="lineNum">    1159 </span><span class="lineCov">      74014 :                         read-&gt;wait_for_source = GF_FALSE;</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineCov">      74014 :                         if (read-&gt;mem_load_mode) {</span>
<span class="lineNum">    1162 </span>            :                                 u32 data_size;
<span class="lineNum">    1163 </span><span class="lineCov">       3981 :                                 const u8 *pck_data = gf_filter_pck_get_data(pck, &amp;data_size);</span>
<span class="lineNum">    1164 </span><span class="lineCov">       3981 :                                 isoffin_push_buffer(filter, read, pck_data, data_size);</span>
<span class="lineNum">    1165 </span>            :                         }
<span class="lineNum">    1166 </span>            :                         //we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it
<span class="lineNum">    1167 </span><span class="lineCov">      70033 :                         else if (read-&gt;moov_not_loaded==2) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :                                 gf_filter_pid_drop_packet(read-&gt;pid);</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :                                 return GF_OK;</span>
<span class="lineNum">    1170 </span>            :                         }
<span class="lineNum">    1171 </span><span class="lineCov">      74014 :                         gf_filter_pid_drop_packet(read-&gt;pid);</span>
<span class="lineNum">    1172 </span>            :                         has_new_data = GF_TRUE;
<span class="lineNum">    1173 </span><span class="lineCov">      74014 :                         if (read-&gt;in_error)</span>
<span class="lineNum">    1174 </span>            :                                 return read-&gt;in_error;
<span class="lineNum">    1175 </span>            :                 }
<span class="lineNum">    1176 </span><span class="lineCov">     245291 :                 if (gf_filter_pid_is_eos(read-&gt;pid)) {</span>
<span class="lineNum">    1177 </span><span class="lineCov">     132820 :                         read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">    1178 </span>            :                         in_is_eos = GF_TRUE;
<span class="lineNum">    1179 </span>            :                 }
<span class="lineNum">    1180 </span><span class="lineCov">     245291 :                 if (read-&gt;input_is_stop) {</span>
<span class="lineNum">    1181 </span><span class="lineCov">        121 :                         read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">    1182 </span>            :                         in_is_eos = GF_TRUE;
<span class="lineNum">    1183 </span><span class="lineCov">        121 :                         read-&gt;input_is_stop = GF_FALSE;</span>
<span class="lineNum">    1184 </span>            :                 }
<span class="lineNum">    1185 </span><span class="lineCov">     245291 :                 if (!read-&gt;frag_type &amp;&amp; read-&gt;input_loaded) {</span>
<span class="lineNum">    1186 </span>            :                         in_is_eos = GF_TRUE;
<span class="lineNum">    1187 </span>            :                 }
<span class="lineNum">    1188 </span>            :         //segment is invalid, wait for eos on input an send eos on all channels
<span class="lineNum">    1189 </span><span class="lineCov">     245291 :         if (read-&gt;invalid_segment) {</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :             if (!in_is_eos) return GF_OK;</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :             read-&gt;invalid_segment = GF_FALSE;</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :             for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                 ISOMChannel *ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                 if (!ch-&gt;playing) {</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1197 </span>            :                 }
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                 if (!ch-&gt;eos_sent) {</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :                     ch-&gt;eos_sent = GF_TRUE;</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :                     gf_filter_pid_set_eos(ch-&gt;pid);</span>
<span class="lineNum">    1201 </span>            :                 }
<span class="lineNum">    1202 </span>            :             }
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :             read-&gt;eos_signaled = GF_TRUE;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :             return GF_EOS;</span>
<span class="lineNum">    1205 </span>            :         }
<span class="lineNum">    1206 </span><span class="lineCov">      48017 :         } else if (read-&gt;extern_mov) {</span>
<span class="lineNum">    1207 </span>            :                 in_is_eos = GF_TRUE;
<span class="lineNum">    1208 </span><span class="lineCov">      48017 :                 read-&gt;input_loaded = GF_TRUE;</span>
<span class="lineNum">    1209 </span>            :         }
<span class="lineNum">    1210 </span><span class="lineCov">     293308 :         if (read-&gt;moov_not_loaded==1) {</span>
<span class="lineNum">    1211 </span><span class="lineCov">         29 :                 if (read-&gt;mem_load_mode)</span>
<span class="lineNum">    1212 </span>            :                         return GF_OK;
<span class="lineNum">    1213 </span><span class="lineCov">         25 :                 read-&gt;moov_not_loaded = GF_FALSE;</span>
<span class="lineNum">    1214 </span><span class="lineCov">         25 :                 return isoffin_setup(filter, read);</span>
<span class="lineNum">    1215 </span>            :         }
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineCov">     293279 :         if (read-&gt;refresh_fragmented) {</span>
<span class="lineNum">    1218 </span>            :                 const GF_PropertyValue *prop;
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineCov">       3959 :                 if (in_is_eos) {</span>
<span class="lineNum">    1221 </span><span class="lineCov">       1251 :                         read-&gt;refresh_fragmented = GF_FALSE;</span>
<span class="lineNum">    1222 </span>            :                 } else {
<span class="lineNum">    1223 </span><span class="lineCov">       2708 :                         prop = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_FILE_CACHED);</span>
<span class="lineNum">    1224 </span><span class="lineCov">       2708 :                         if (prop &amp;&amp; prop-&gt;value.boolean)</span>
<span class="lineNum">    1225 </span><span class="lineCov">       1595 :                                 read-&gt;refresh_fragmented = GF_FALSE;</span>
<span class="lineNum">    1226 </span>            :                 }
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineCov">       3959 :                 if (has_new_data) {</span>
<span class="lineNum">    1229 </span><span class="lineCov">       3366 :                         u64 bytesMissing=0;</span>
<span class="lineNum">    1230 </span>            :                         GF_Err e;
<span class="lineNum">    1231 </span>            :                         const char *new_url = NULL;
<span class="lineNum">    1232 </span><span class="lineCov">       3366 :                         prop = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">    1233 </span><span class="lineCov">       3366 :                         if (prop) new_url = prop-&gt;value.string;</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineCov">       3366 :                         e = gf_isom_refresh_fragmented(read-&gt;mov, &amp;bytesMissing, new_url);</span>
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineCov">       3366 :                         if (e &amp;&amp; (e!= GF_ISOM_INCOMPLETE_FILE)) {</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[IsoMedia] Failed to refresh current segment: %s\n&quot;, gf_error_to_string(e) ));</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :                                 read-&gt;refresh_fragmented = GF_FALSE;</span>
<span class="lineNum">    1240 </span>            :                         } else {
<span class="lineNum">    1241 </span><span class="lineCov">       3366 :                                 GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] Refreshing current segment at UTC &quot;LLU&quot; - &quot;LLU&quot; bytes still missing - input is EOS %d\n&quot;, gf_net_get_utc(), bytesMissing, in_is_eos));</span>
<span class="lineNum">    1242 </span>            :                         }
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineCov">       3366 :                         if (!read-&gt;refresh_fragmented &amp;&amp; (e==GF_ISOM_INCOMPLETE_FILE)) {</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[IsoMedia] Incomplete Segment received - &quot;LLU&quot; bytes missing but EOF found\n&quot;, bytesMissing ));</span>
<span class="lineNum">    1246 </span>            :                         }
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            : #ifndef GPAC_DISABLE_LOG
<span class="lineNum">    1249 </span><span class="lineCov">       3366 :                         if (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {</span>
<span class="lineNum">    1250 </span><span class="lineCov">         71 :                                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1251 </span><span class="lineCov">         71 :                                         ISOMChannel *ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">    1252 </span><span class="lineCov">         71 :                                         GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\n&quot;, ch-&gt;track, ch-&gt;sample_num, gf_isom_get_sample_count(ch-&gt;owner-&gt;mov, ch-&gt;track) ));</span>
<span class="lineNum">    1253 </span>            :                                 }
<span class="lineNum">    1254 </span>            :                         }
<span class="lineNum">    1255 </span>            : #endif
<span class="lineNum">    1256 </span><span class="lineCov">       3366 :                         isor_check_producer_ref_time(read);</span>
<span class="lineNum">    1257 </span><span class="lineCov">       3366 :                         if (!read-&gt;frag_type)</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                                 read-&gt;refresh_fragmented = GF_FALSE;</span>
<span class="lineNum">    1259 </span>            :                 }
<span class="lineNum">    1260 </span>            :         }
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span><span class="lineCov">     503094 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1263 </span>            :                 u8 *data;
<span class="lineNum">    1264 </span>            :                 u32 nb_pck=50;
<span class="lineNum">    1265 </span>            :                 ISOMChannel *ch;
<span class="lineNum">    1266 </span><span class="lineCov">     503094 :                 ch = gf_list_get(read-&gt;channels, i);</span>
<span class="lineNum">    1267 </span><span class="lineCov">     503094 :                 if (!ch-&gt;playing) {</span>
<span class="lineNum">    1268 </span><span class="lineCov">       5553 :                         nb_forced_end++;</span>
<span class="lineNum">    1269 </span><span class="lineCov">       5553 :                         continue;</span>
<span class="lineNum">    1270 </span>            :                 }
<span class="lineNum">    1271 </span>            :                 //eos not sent on this channel, we are active
<span class="lineNum">    1272 </span><span class="lineCov">     497541 :                 if (!ch-&gt;eos_sent)</span>
<span class="lineNum">    1273 </span>            :                         is_active = GF_TRUE;
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span><span class="lineCov">     894459 :                 while (nb_pck) {</span>
<span class="lineNum">    1276 </span><span class="lineCov">     893993 :                         ch-&gt;sample_data_offset = 0;</span>
<span class="lineNum">    1277 </span><span class="lineCov">     893993 :                         if (!read-&gt;full_segment_flush &amp;&amp; gf_filter_pid_would_block(ch-&gt;pid) )</span>
<span class="lineNum">    1278 </span>            :                                 break;
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span><span class="lineCov">     642432 :                         if (ch-&gt;item_id) {</span>
<span class="lineNum">    1281 </span><span class="lineCov">        118 :                                 isor_reader_get_sample_from_item(ch);</span>
<span class="lineNum">    1282 </span>            :                         } else {
<span class="lineNum">    1283 </span><span class="lineCov">     642314 :                                 isor_reader_get_sample(ch);</span>
<span class="lineNum">    1284 </span>            :                         }
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineCov">     642432 :                         if (read-&gt;stsd &amp;&amp; (ch-&gt;last_sample_desc_index != read-&gt;stsd) &amp;&amp; ch-&gt;sample) {</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :                                 isor_reader_release_sample(ch);</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1289 </span>            :                         }
<span class="lineNum">    1290 </span><span class="lineCov">     642432 :                         if (ch-&gt;sample) {</span>
<span class="lineNum">    1291 </span>            :                                 u32 sample_dur;
<span class="lineNum">    1292 </span>            :                                 u8 dep_flags;
<span class="lineNum">    1293 </span>            :                                 u8 *subs_buf;
<span class="lineNum">    1294 </span>            :                                 u32 subs_buf_size;
<span class="lineNum">    1295 </span>            :                                 GF_FilterPacket *pck;
<span class="lineNum">    1296 </span><span class="lineCov">     396918 :                                 if (ch-&gt;needs_pid_reconfig) {</span>
<span class="lineNum">    1297 </span><span class="lineCov">          5 :                                         isor_update_channel_config(ch);</span>
<span class="lineNum">    1298 </span><span class="lineCov">          5 :                                         ch-&gt;needs_pid_reconfig = GF_FALSE;</span>
<span class="lineNum">    1299 </span>            :                                 }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :                                 //we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed
<span class="lineNum">    1302 </span><span class="lineCov">     396918 :                                 if (ch-&gt;check_has_rap &amp;&amp; (gf_isom_get_sample_count(ch-&gt;owner-&gt;mov, ch-&gt;track)&gt;1) &amp;&amp; (gf_isom_has_sync_points(ch-&gt;owner-&gt;mov, ch-&gt;track)==1)) {</span>
<span class="lineNum">    1303 </span><span class="lineCov">        187 :                                         ch-&gt;check_has_rap = GF_FALSE;</span>
<span class="lineNum">    1304 </span><span class="lineCov">        187 :                                         ch-&gt;has_rap = GF_TRUE;</span>
<span class="lineNum">    1305 </span><span class="lineCov">        187 :                                         gf_filter_pid_set_property(ch-&gt;pid, GF_PROP_PID_HAS_SYNC, &amp;PROP_BOOL(ch-&gt;has_rap) );</span>
<span class="lineNum">    1306 </span>            :                                 }
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span>            :                                 //strip param sets from payload, trigger reconfig if needed
<span class="lineNum">    1309 </span><span class="lineCov">     396918 :                                 isor_reader_check_config(ch);</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineCov">     396918 :                                 if (read-&gt;nodata) {</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                                         pck = gf_filter_pck_new_shared(ch-&gt;pid, NULL, ch-&gt;sample-&gt;dataLength, NULL);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :                                         if (!pck) return GF_OUT_OF_MEM;</span>
<span class="lineNum">    1314 </span>            :                                 } else {
<span class="lineNum">    1315 </span><span class="lineCov">     396918 :                                         pck = gf_filter_pck_new_alloc(ch-&gt;pid, ch-&gt;sample-&gt;dataLength, &amp;data);</span>
<span class="lineNum">    1316 </span><span class="lineCov">     396918 :                                         if (!pck) return GF_OUT_OF_MEM;</span>
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span><span class="lineCov">     396918 :                                         memcpy(data, ch-&gt;sample-&gt;data, ch-&gt;sample-&gt;dataLength);</span>
<span class="lineNum">    1319 </span>            :                                 }
<span class="lineNum">    1320 </span><span class="lineCov">     396918 :                                 gf_filter_pck_set_dts(pck, ch-&gt;dts);</span>
<span class="lineNum">    1321 </span><span class="lineCov">     396918 :                                 gf_filter_pck_set_cts(pck, ch-&gt;cts);</span>
<span class="lineNum">    1322 </span><span class="lineCov">     396918 :                                 if (ch-&gt;sample-&gt;IsRAP==-1) {</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                                         gf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :                                         ch-&gt;redundant = 1;</span>
<span class="lineNum">    1325 </span>            :                                 } else {
<span class="lineNum">    1326 </span><span class="lineCov">     396918 :                                         gf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch-&gt;sample-&gt;IsRAP);</span>
<span class="lineNum">    1327 </span>            :                                 }
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineCov">     396918 :                                 if (ch-&gt;sap_3)</span>
<span class="lineNum">    1330 </span><span class="lineCov">        355 :                                         gf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);</span>
<span class="lineNum">    1331 </span><span class="lineCov">     396563 :                                 else if (ch-&gt;sap_4_type) {</span>
<span class="lineNum">    1332 </span><span class="lineCov">         93 :                                         gf_filter_pck_set_sap(pck, (ch-&gt;sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);</span>
<span class="lineNum">    1333 </span><span class="lineCov">         93 :                                         gf_filter_pck_set_roll_info(pck, ch-&gt;roll);</span>
<span class="lineNum">    1334 </span>            :                                 }
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span><span class="lineCov">     396918 :                                 sample_dur = ch-&gt;au_duration;</span>
<span class="lineNum">    1337 </span><span class="lineCov">     396918 :                                 if (ch-&gt;sample-&gt;nb_pack)</span>
<span class="lineNum">    1338 </span><span class="lineCov">        482 :                                         sample_dur *= ch-&gt;sample-&gt;nb_pack;</span>
<span class="lineNum">    1339 </span><span class="lineCov">     396918 :                                 gf_filter_pck_set_duration(pck, sample_dur);</span>
<span class="lineNum">    1340 </span><span class="lineCov">     396918 :                                 gf_filter_pck_set_seek_flag(pck, ch-&gt;seek_flag);</span>
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span><span class="lineCov">     396918 :                                 dep_flags = ch-&gt;isLeading;</span>
<span class="lineNum">    1343 </span><span class="lineCov">     396918 :                                 dep_flags &lt;&lt;= 2;</span>
<span class="lineNum">    1344 </span><span class="lineCov">     396918 :                                 dep_flags |= ch-&gt;dependsOn;</span>
<span class="lineNum">    1345 </span><span class="lineCov">     396918 :                                 dep_flags &lt;&lt;= 2;</span>
<span class="lineNum">    1346 </span><span class="lineCov">     396918 :                                 dep_flags |= ch-&gt;dependedOn;</span>
<span class="lineNum">    1347 </span><span class="lineCov">     396918 :                                 dep_flags &lt;&lt;= 2;</span>
<span class="lineNum">    1348 </span><span class="lineCov">     396918 :                                 dep_flags |= ch-&gt;redundant;</span>
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span><span class="lineCov">     396918 :                                 if (dep_flags)</span>
<span class="lineNum">    1351 </span><span class="lineCov">      26972 :                                         gf_filter_pck_set_dependency_flags(pck, dep_flags);</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span><span class="lineCov">     396918 :                                 gf_filter_pck_set_crypt_flags(pck, ch-&gt;pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);</span>
<span class="lineNum">    1354 </span><span class="lineCov">     396918 :                                 gf_filter_pck_set_seq_num(pck, ch-&gt;sample_num);</span>
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineCov">     396918 :                                 subs_buf = gf_isom_sample_get_subsamples_buffer(read-&gt;mov, ch-&gt;track, ch-&gt;sample_num, &amp;subs_buf_size);</span>
<span class="lineNum">    1358 </span><span class="lineCov">     396918 :                                 if (subs_buf) {</span>
<span class="lineNum">    1359 </span><span class="lineCov">        768 :                                         gf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &amp;PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );</span>
<span class="lineNum">    1360 </span>            :                                 }
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineCov">     396918 :                                 if (ch-&gt;sai_buffer &amp;&amp; ch-&gt;pck_encrypted) {</span>
<span class="lineNum">    1363 </span>            :                                         assert(ch-&gt;sai_buffer_size);
<span class="lineNum">    1364 </span><span class="lineCov">      33013 :                                         gf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &amp;PROP_DATA(ch-&gt;sai_buffer, ch-&gt;sai_buffer_size) );</span>
<span class="lineNum">    1365 </span>            :                                 }
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span><span class="lineCov">     396918 :                                 if (read-&gt;sigfrag) {</span>
<span class="lineNum">    1368 </span>            :                                         GF_ISOFragmentBoundaryInfo finfo;
<span class="lineNum">    1369 </span><span class="lineCov">       7323 :                                         if (gf_isom_sample_is_fragment_start(read-&gt;mov, ch-&gt;track, ch-&gt;sample_num, &amp;finfo) ) {</span>
<span class="lineNum">    1370 </span>            :                                                 u64 start=0;
<span class="lineNum">    1371 </span><span class="lineCov">        195 :                                                 u32 traf_start = finfo.seg_start_plus_one ? 2 : 1;</span>
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineCov">        195 :                                                 if (finfo.seg_start_plus_one)</span>
<span class="lineNum">    1374 </span><span class="lineCov">         87 :                                                         gf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &amp;PROP_BOOL(GF_TRUE));</span>
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span><span class="lineCov">        195 :                                                 gf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &amp;PROP_UINT(traf_start));</span>
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span><span class="lineCov">        195 :                                                 start = finfo.frag_start;</span>
<span class="lineNum">    1379 </span><span class="lineCov">        195 :                                                 if (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;</span>
<span class="lineNum">    1380 </span><span class="lineCov">        195 :                                                 gf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &amp;PROP_FRAC64_INT(start, finfo.mdat_end));</span>
<span class="lineNum">    1381 </span><span class="lineCov">        195 :                                                 if (finfo.moof_template) {</span>
<span class="lineNum">    1382 </span><span class="lineCov">         87 :                                                         gf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &amp;PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));</span>
<span class="lineNum">    1383 </span>            :                                                 }
<span class="lineNum">    1384 </span><span class="lineCov">        195 :                                                 if (finfo.sidx_end) {</span>
<span class="lineNum">    1385 </span><span class="lineCov">         87 :                                                         gf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &amp;PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));</span>
<span class="lineNum">    1386 </span>            :                                                 }
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineCov">        195 :                                                 if (read-&gt;seg_name_changed) {</span>
<span class="lineNum">    1389 </span><span class="lineCov">         81 :                                                         const GF_PropertyValue *p = gf_filter_pid_get_property(read-&gt;pid, GF_PROP_PID_URL);</span>
<span class="lineNum">    1390 </span><span class="lineCov">         81 :                                                         read-&gt;seg_name_changed = GF_FALSE;</span>
<span class="lineNum">    1391 </span><span class="lineCov">         81 :                                                         if (p &amp;&amp; p-&gt;value.string) {</span>
<span class="lineNum">    1392 </span><span class="lineCov">         81 :                                                                 gf_filter_pck_set_property(pck, GF_PROP_PID_URL, &amp;PROP_STRING(p-&gt;value.string));</span>
<span class="lineNum">    1393 </span>            :                                                         }
<span class="lineNum">    1394 </span>            :                                                 }
<span class="lineNum">    1395 </span>            :                                         }
<span class="lineNum">    1396 </span>            :                                 }
<span class="lineNum">    1397 </span><span class="lineCov">     396918 :                                 if (ch-&gt;sender_ntp) {</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :                                         gf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &amp;PROP_LONGUINT(ch-&gt;sender_ntp));</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :                                         if (ch-&gt;ntp_at_server_ntp) {</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :                                                 gf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &amp;PROP_LONGUINT(ch-&gt;ntp_at_server_ntp));</span>
<span class="lineNum">    1401 </span>            :                                         }
<span class="lineNum">    1402 </span>            :                                 }
<span class="lineNum">    1403 </span><span class="lineCov">     396918 :                                 ch-&gt;eos_sent = GF_FALSE;</span>
<span class="lineNum">    1404 </span><span class="lineCov">     396918 :                                 gf_filter_pck_send(pck);</span>
<span class="lineNum">    1405 </span><span class="lineCov">     396918 :                                 isor_reader_release_sample(ch);</span>
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span><span class="lineCov">     396918 :                                 ch-&gt;last_valid_sample_data_offset = ch-&gt;sample_data_offset;</span>
<span class="lineNum">    1408 </span><span class="lineCov">     396918 :                                 nb_pck--;</span>
<span class="lineNum">    1409 </span><span class="lineCov">     245514 :                         } else if (ch-&gt;last_state==GF_EOS) {</span>
<span class="lineNum">    1410 </span><span class="lineCov">     243981 :                                 if (ch-&gt;playing == 2) {</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                                         if (in_is_eos) {</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                                                 ch-&gt;playing = GF_FALSE;</span>
<span class="lineNum">    1413 </span>            :                                         } else {
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :                                                 nb_forced_end++;</span>
<span class="lineNum">    1415 </span>            :                                                 check_forced_end = GF_TRUE;
<span class="lineNum">    1416 </span>            :                                         }
<span class="lineNum">    1417 </span>            :                                 }
<span class="lineNum">    1418 </span><span class="lineCov">     243981 :                                 if (in_is_eos &amp;&amp; !ch-&gt;eos_sent) {</span>
<span class="lineNum">    1419 </span>            :                                         void *tfrf;
<span class="lineNum">    1420 </span>            :                                         const void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span><span class="lineCov">      18669 :                                         ch-&gt;eos_sent = GF_TRUE;</span>
<span class="lineNum">    1423 </span><span class="lineCov">      18669 :                                         read-&gt;eos_signaled = GF_TRUE;</span>
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span><span class="lineCov">      18669 :                                         tfrf = (void *) gf_isom_get_tfrf(read-&gt;mov, ch-&gt;track);</span>
<span class="lineNum">    1426 </span><span class="lineCov">      18669 :                                         if (tfrf) {</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :                                                 gf_filter_pid_set_info_str(ch-&gt;pid, &quot;smooth_tfrf&quot;, &amp;PROP_POINTER(tfrf) );</span>
<span class="lineNum">    1428 </span>            :                                         } else {
<span class="lineNum">    1429 </span><span class="lineCov">      18669 :                                                 gf_filter_pid_set_info_str(ch-&gt;pid, &quot;smooth_tfrf&quot;, NULL );</span>
<span class="lineNum">    1430 </span>            :                                         }
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span><span class="lineCov">      18669 :                                         gf_filter_pid_set_eos(ch-&gt;pid);</span>
<span class="lineNum">    1433 </span>            :                                 }
<span class="lineNum">    1434 </span>            :                                 break;
<span class="lineNum">    1435 </span>            :                         } else {
<span class="lineNum">    1436 </span><span class="lineCov">       1533 :                                 read-&gt;force_fetch = GF_TRUE;</span>
<span class="lineNum">    1437 </span><span class="lineCov">       1533 :                                 break;</span>
<span class="lineNum">    1438 </span>            :                         }
<span class="lineNum">    1439 </span>            :                 }
<span class="lineNum">    1440 </span><span class="lineCov">     497541 :                 if (!min_offset_plus_one || (min_offset_plus_one - 1 &gt; ch-&gt;last_valid_sample_data_offset))</span>
<span class="lineNum">    1441 </span><span class="lineCov">     300245 :                         min_offset_plus_one = 1 + ch-&gt;last_valid_sample_data_offset;</span>
<span class="lineNum">    1442 </span>            :         }
<span class="lineNum">    1443 </span><span class="lineCov">     293279 :         if (read-&gt;mem_load_mode &amp;&amp; min_offset_plus_one) {</span>
<span class="lineNum">    1444 </span><span class="lineCov">      30768 :                 isoffin_purge_mem(read, min_offset_plus_one-1);</span>
<span class="lineNum">    1445 </span>            :         }
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            :         //we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input
<span class="lineNum">    1448 </span><span class="lineCov">     293279 :         if (read-&gt;pid &amp;&amp; check_forced_end &amp;&amp; (nb_forced_end==count)) {</span>
<span class="lineNum">    1449 </span>            :                 //abort input
<span class="lineNum">    1450 </span>            :                 GF_FilterEvent evt;
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :                 GF_FEVT_INIT(evt, GF_FEVT_STOP, read-&gt;pid);</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                 gf_filter_pid_send_event(read-&gt;pid, &amp;evt);</span>
<span class="lineNum">    1453 </span>            :         }
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span><span class="lineCov">     293279 :         if (!is_active) {</span>
<span class="lineNum">    1457 </span>            :                 return GF_EOS;
<span class="lineNum">    1458 </span>            :         }
<span class="lineNum">    1459 </span>            :         //if (in_is_eos)
<span class="lineNum">    1460 </span>            : //      gf_filter_ask_rt_reschedule(filter, 1);
<span class="lineNum">    1461 </span><span class="lineCov">     279774 :         return GF_OK;</span>
<span class="lineNum">    1462 </span>            : 
<a name="1463"><span class="lineNum">    1463 </span>            : }</a>
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span><span class="lineCov">       3074 : static const char *isoffin_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)</span>
<span class="lineNum">    1466 </span>            : {
<span class="lineNum">    1467 </span><span class="lineCov">       3074 :         if (gf_isom_probe_data(data, size)) {</span>
<span class="lineNum">    1468 </span><span class="lineCov">        715 :                 *score = GF_FPROBE_SUPPORTED;</span>
<span class="lineNum">    1469 </span><span class="lineCov">        715 :                 return &quot;video/mp4&quot;;</span>
<span class="lineNum">    1470 </span>            :         }
<span class="lineNum">    1471 </span>            :         return NULL;
<span class="lineNum">    1472 </span>            : }
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            : #define OFFS(_n)        #_n, offsetof(ISOMReader, _n)
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            : static const GF_FilterArgs ISOFFInArgs[] =
<span class="lineNum">    1477 </span>            : {
<span class="lineNum">    1478 </span>            :         { OFFS(src), &quot;location of source content (only used when explicitly loading the demuxer)&quot;, GF_PROP_NAME, NULL, NULL, 0},
<span class="lineNum">    1479 </span>            :         { OFFS(allt), &quot;load all tracks even if unknown&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1480 </span>            :         { OFFS(noedit), &quot;do not use edit lists&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1481 </span>            :         { OFFS(itt), &quot;convert all items of root meta into a single PID&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1482 </span>            :         { OFFS(itemid), &quot;keep item IDs in PID properties&quot;, GF_PROP_BOOL, &quot;true&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1483 </span>            :         { OFFS(smode), &quot;load mode for scalable/tile tracks\n&quot;
<span class="lineNum">    1484 </span>            :         &quot;- split: each track is declared, extractors are removed\n&quot;
<span class="lineNum">    1485 </span>            :         &quot;- splitx: each track is declared, extractors are kept\n&quot;
<span class="lineNum">    1486 </span>            :         &quot;- single: a single track is declared (highest level for scalable, tile base for tiling)&quot;, GF_PROP_UINT, &quot;split&quot;, &quot;split|splitx|single&quot;, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1487 </span>            :         { OFFS(alltk), &quot;declare all tracks even disabled ones&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1488 </span>            :         { OFFS(frame_size), &quot;frame size for raw audio samples (dispatches frame_size samples per packet)&quot;, GF_PROP_UINT, &quot;1024&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1489 </span>            :         { OFFS(expart), &quot;expose cover art as a dedicated video pid&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1490 </span>            :         { OFFS(sigfrag), &quot;signal fragment and segment boundaries of source on output packets&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            :         { OFFS(tkid), &quot;declare only track based on given param\n&quot;
<span class="lineNum">    1493 </span>            :         &quot;- integer value: declares track with the given ID\n&quot;
<span class="lineNum">    1494 </span>            :         &quot;- audio: declares first audio track\n&quot;
<span class="lineNum">    1495 </span>            :         &quot;- video: declares first video track\n&quot;
<span class="lineNum">    1496 </span>            :         &quot;- 4CC: declares first track with matching 4CC for handler type&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1497 </span>            :         { OFFS(stsd), &quot;only extract sample mapped to the given sample description index. 0 means no filter&quot;, GF_PROP_UINT, &quot;0&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1498 </span>            :         { OFFS(mov), &quot;pointer to a read/edit ISOBMF file used internally by importers and exporters&quot;, GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},
<span class="lineNum">    1499 </span>            :         { OFFS(analyze), &quot;skip reformat of decoder config and SEI and dispatch all NAL in input order - shall only be used with inspect filter analyze mode!&quot;, GF_PROP_UINT, &quot;off&quot;, &quot;off|on|bs|full&quot;, GF_FS_ARG_HINT_HIDE},
<span class="lineNum">    1500 </span>            :         { OFFS(catseg), &quot;append the given segment to the movie at init time (only local file supported)&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_HIDE},
<span class="lineNum">    1501 </span>            :         { OFFS(nocrypt), &quot;signal encrypted tracks as non encrypted (mostly used for export)&quot;, GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1502 </span>            :         { OFFS(mstore_size), &quot;target buffer size in bytes&quot;, GF_PROP_UINT, &quot;1000000&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1503 </span>            :         { OFFS(mstore_purge), &quot;minimum size in bytes between memory purges when reading from memory stream (pipe etc...), 0 means purge as soon as possible&quot;, GF_PROP_UINT, &quot;50000&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1504 </span>            :         { OFFS(mstore_samples), &quot;minimum number of samples to be present before purging sample tables when reading from memory stream (pipe etc...), 0 means purge as soon as possible&quot;, GF_PROP_UINT, &quot;50&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1505 </span>            :         { OFFS(strtxt), &quot;load text tracks (apple/tx3g) as MPEG-4 streaming text tracks&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1506 </span>            :         { OFFS(xps_check), &quot;parameter sets extraction mode from AVC/HEVC/VVC samples\n&quot;
<span class="lineNum">    1507 </span>            :         &quot;- keep: do not inspect sample (assumes input file is compliant when generating DASH/HLS/CMAF)\n&quot;
<span class="lineNum">    1508 </span>            :         &quot;- rem: removes all inband xPS and notify configuration changes accordingly\n&quot;
<span class="lineNum">    1509 </span>            :         &quot;- auto: resolves to `keep` for `smode=splix` (dasher mode), `rem` otherwise&quot;
<span class="lineNum">    1510 </span>            :         , GF_PROP_UINT, &quot;auto&quot;, &quot;auto|keep|rem&quot;, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1511 </span>            :         { OFFS(nodata), &quot;do not load sample data&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    1512 </span>            :         {0}
<span class="lineNum">    1513 </span>            : };
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            : static const GF_FilterCapability ISOFFInCaps[] =
<span class="lineNum">    1516 </span>            : {
<span class="lineNum">    1517 </span>            :         CAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    1518 </span>            :         CAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, &quot;mp4|mpg4|m4a|m4i|3gp|3gpp|3g2|3gp2|iso|m4s|heif|heic|avci|mj2|mov|qt&quot;),
<span class="lineNum">    1519 </span>            :         CAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, &quot;application/x-isomedia|application/mp4|video/mp4|audio/mp4|video/3gpp|audio/3gpp|video/3gp2|audio/3gp2|video/iso.segment|audio/iso.segment|image/heif|image/heic|image/avci|video/quicktime&quot;),
<span class="lineNum">    1520 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),
<span class="lineNum">    1521 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),
<span class="lineNum">    1522 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),
<span class="lineNum">    1523 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),
<span class="lineNum">    1524 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),
<span class="lineNum">    1525 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_METADATA),
<span class="lineNum">    1526 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_ENCRYPTED),
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            :         CAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),
<span class="lineNum">    1529 </span>            :         //we don't set output cap for streamtype FILE for now.
<span class="lineNum">    1530 </span>            : };
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            : GF_FilterRegister ISOFFInRegister = {
<span class="lineNum">    1533 </span>            :         .name = &quot;mp4dmx&quot;,
<span class="lineNum">    1534 </span>            :         GF_FS_SET_DESCRIPTION(&quot;ISOBMFF/QT demuxer&quot;)
<span class="lineNum">    1535 </span>            :         GF_FS_SET_HELP(&quot;This filter demultiplexes ISOBMF and QT files (regular or fragmented).\n&quot;
<span class="lineNum">    1536 </span>            :                 &quot;# Track Selection\n&quot;
<span class="lineNum">    1537 </span>            :                 &quot;The filter can use fragment identifiers of source to select a single track for playback. The allowed fragments are:\n&quot;
<span class="lineNum">    1538 </span>            :                 &quot; - #audio: only use the first audio track\n&quot;
<span class="lineNum">    1539 </span>            :                 &quot; - #video: only use the first video track\n&quot;
<span class="lineNum">    1540 </span>            :                 &quot; - #auxv: only use the first auxiliary video track\n&quot;
<span class="lineNum">    1541 </span>            :                 &quot; - #pict: only use the first picture track\n&quot;
<span class="lineNum">    1542 </span>            :                 &quot; - #text: only use the first text track\n&quot;
<span class="lineNum">    1543 </span>            :                 &quot; - #trackID=VAL: only use the track with given ID\n&quot;
<span class="lineNum">    1544 </span>            :                 &quot; - #ID=VAL: only use the track with given ID\n&quot;
<span class="lineNum">    1545 </span>            :                 &quot; - #VAL: only use the track with given ID\n&quot;
<span class="lineNum">    1546 </span>            :                 &quot;\n&quot;
<span class="lineNum">    1547 </span>            :                 &quot;# Scalable Tracks\n&quot;
<span class="lineNum">    1548 </span>            :                 &quot;When scalable tracks are present in a file, the reader can operate in 3 modes using [-smode]() option:\n&quot;\
<span class="lineNum">    1549 </span>            :                 &quot;- smode=single: resolves all extractors to extract a single bitstream from a scalable set. The highest level is used\n&quot;\
<span class="lineNum">    1550 </span>            :                 &quot;In this mode, there is no enhancement decoder config, only a base one resulting from the merge of the configs\n&quot;\
<span class="lineNum">    1551 </span>            :                 &quot;- smode=split: all extractors are removed and every track of the scalable set is declared. In this mode, each enhancement track has no base decoder config\n&quot;
<span class="lineNum">    1552 </span>            :                 &quot;and an enhancement decoder config.\n&quot;\
<span class="lineNum">    1553 </span>            :                 &quot;- smode=splitx: extractors are kept in the bitstream, and every track of the scalable set is declared. In this mode, each enhancement track has a base decoder config\n&quot;
<span class="lineNum">    1554 </span>            :                 &quot; (copied from base) and an enhancement decoder config. This is mostly used for DASHing content.\n&quot;\
<span class="lineNum">    1555 </span>            :                 &quot;Warning: smode=splitx will result in extractor NAL units still present in the output bitstream, which shall only be true if the output is ISOBMFF based\n&quot;)
<span class="lineNum">    1556 </span>            :         .private_size = sizeof(ISOMReader),
<span class="lineNum">    1557 </span>            :         .args = ISOFFInArgs,
<span class="lineNum">    1558 </span>            :         .initialize = isoffin_initialize,
<span class="lineNum">    1559 </span>            :         .finalize = isoffin_finalize,
<span class="lineNum">    1560 </span>            :         .process = isoffin_process,
<span class="lineNum">    1561 </span>            :         .configure_pid = isoffin_configure_pid,
<span class="lineNum">    1562 </span>            :         SETCAPS(ISOFFInCaps),
<span class="lineNum">    1563 </span>            :         .process_event = isoffin_process_event,
<span class="lineNum">    1564 </span>            :         .probe_data = isoffin_probe_data
<span class="lineNum">    1565 </span>            : };
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span>            : 
<a name="1568"><span class="lineNum">    1568 </span>            : #endif /*GPAC_DISABLE_ISOM*/</a>
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineCov">       2877 : const GF_FilterRegister *isoffin_register(GF_FilterSession *session)</span>
<span class="lineNum">    1571 </span>            : {
<span class="lineNum">    1572 </span>            : #ifdef GPAC_DISABLE_ISOM
<span class="lineNum">    1573 </span>            :         return NULL;
<span class="lineNum">    1574 </span>            : #else
<span class="lineNum">    1575 </span><span class="lineCov">       2877 :         return &amp;ISOFFInRegister;</span>
<span class="lineNum">    1576 </span>            : #endif /*GPAC_DISABLE_ISOM*/
<span class="lineNum">    1577 </span>            : }
<span class="lineNum">    1578 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
