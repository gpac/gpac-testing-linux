<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - filters/dasher.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">filters</a> - dasher.c<span style="font-size: 80%;"> (source / <a href="dasher.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3306</td>
            <td class="headerCovTableEntry">4411</td>
            <td class="headerCovTableEntryLo">74.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-04-29 23:48:07</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">69</td>
            <td class="headerCovTableEntry">73</td>
            <td class="headerCovTableEntryHi">94.5 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *                      GPAC - Multimedia Framework C SDK
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *                      Authors: Jean Le Feuvre
<span class="lineNum">       5 </span>            :  *                      Copyright (c) Telecom ParisTech 2018-2021
<span class="lineNum">       6 </span>            :  *                                      All rights reserved
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *  This file is part of GPAC / MPEG-DASH/HLS segmenter
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *  GPAC is free software; you can redistribute it and/or modify
<span class="lineNum">      11 </span>            :  *  it under the terms of the GNU Lesser General Public License as published by
<span class="lineNum">      12 </span>            :  *  the Free Software Foundation; either version 2, or (at your option)
<span class="lineNum">      13 </span>            :  *  any later version.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  *  GPAC is distributed in the hope that it will be useful,
<span class="lineNum">      16 </span>            :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      17 </span>            :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      18 </span>            :  *  GNU Lesser General Public License for more details.
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  *  You should have received a copy of the GNU Lesser General Public
<span class="lineNum">      21 </span>            :  *  License along with this library; see the file COPYING.  If not, write to
<span class="lineNum">      22 </span>            :  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &lt;gpac/filters.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;gpac/constants.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;gpac/iso639.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;gpac/mpd.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;gpac/internal/media_dev.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;gpac/base_coding.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;gpac/network.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;gpac/crypt_tools.h&gt;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #define DEFAULT_PERIOD_ID        &quot;_gf_dash_def_period&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : typedef struct
<span class="lineNum">      38 </span>            : {
<span class="lineNum">      39 </span>            :         GF_List *streams;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :         //period element we will fill
<span class="lineNum">      42 </span>            :         GF_MPD_Period *period;
<span class="lineNum">      43 </span>            : } GF_DasherPeriod;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : enum
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span>            :         DASHER_BS_SWITCH_DEF=0,
<span class="lineNum">      48 </span>            :         DASHER_BS_SWITCH_OFF,
<span class="lineNum">      49 </span>            :         DASHER_BS_SWITCH_ON,
<span class="lineNum">      50 </span>            :         DASHER_BS_SWITCH_INBAND,
<span class="lineNum">      51 </span>            :         DASHER_BS_SWITCH_FORCE,
<span class="lineNum">      52 </span>            :         DASHER_BS_SWITCH_MULTI,
<span class="lineNum">      53 </span>            : };
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : typedef enum
<span class="lineNum">      56 </span>            : {
<span class="lineNum">      57 </span>            :         DASHER_UTCREF_NONE=0,
<span class="lineNum">      58 </span>            :         DASHER_UTCREF_NTP,
<span class="lineNum">      59 </span>            :         DASHER_UTCREF_HTTP_HEAD,
<span class="lineNum">      60 </span>            :         DASHER_UTCREF_ISO,
<span class="lineNum">      61 </span>            :         DASHER_UTCREF_XSDATE,
<span class="lineNum">      62 </span>            :         DASHER_UTCREF_INBAND,
<span class="lineNum">      63 </span>            : } DasherUTCTimingType;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : enum
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span>            :         DASHER_NTP_REM=0,
<span class="lineNum">      68 </span>            :         DASHER_NTP_YES,
<span class="lineNum">      69 </span>            :         DASHER_NTP_KEEP,
<span class="lineNum">      70 </span>            : };
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : enum
<span class="lineNum">      73 </span>            : {
<span class="lineNum">      74 </span>            :         DASHER_SAP_OFF=0,
<span class="lineNum">      75 </span>            :         DASHER_SAP_SIG,
<span class="lineNum">      76 </span>            :         DASHER_SAP_ON,
<span class="lineNum">      77 </span>            : };
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : enum
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span>            :         DASHER_BOUNDS_OUT=0,
<span class="lineNum">      82 </span>            :         DASHER_BOUNDS_CLOSEST,
<span class="lineNum">      83 </span>            :         DASHER_BOUNDS_IN,
<span class="lineNum">      84 </span>            : };
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : enum
<span class="lineNum">      87 </span>            : {
<span class="lineNum">      88 </span>            :         DASHER_MUX_ISOM=0,
<span class="lineNum">      89 </span>            :         DASHER_MUX_TS,
<span class="lineNum">      90 </span>            :         DASHER_MUX_MKV,
<span class="lineNum">      91 </span>            :         DASHER_MUX_WEBM,
<span class="lineNum">      92 </span>            :         DASHER_MUX_OGG,
<span class="lineNum">      93 </span>            :         DASHER_MUX_RAW,
<span class="lineNum">      94 </span>            :         DASHER_MUX_AUTO,
<span class="lineNum">      95 </span>            : };
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : enum
<span class="lineNum">      98 </span>            : {
<span class="lineNum">      99 </span>            :         DASHER_MPHA_NO=0,
<span class="lineNum">     100 </span>            :         DASHER_MPHA_COMP_ONLY,
<span class="lineNum">     101 </span>            :         DASHER_MPHA_ALL
<span class="lineNum">     102 </span>            : };
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : enum
<span class="lineNum">     105 </span>            : {
<span class="lineNum">     106 </span>            :         DASHER_FWD_NO = 0,
<span class="lineNum">     107 </span>            :         DASHER_FWD_SEGS,
<span class="lineNum">     108 </span>            :         DASHER_FWD_ALL,
<span class="lineNum">     109 </span>            : };
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : enum
<span class="lineNum">     112 </span>            : {
<span class="lineNum">     113 </span>            :         //unknown samples sync state at startup
<span class="lineNum">     114 </span>            :         DASHER_SYNC_UNKNOWN=0,
<span class="lineNum">     115 </span>            :         //all samples sync
<span class="lineNum">     116 </span>            :         DASHER_SYNC_NONE,
<span class="lineNum">     117 </span>            :         //some samples sync
<span class="lineNum">     118 </span>            :         DASHER_SYNC_PRESENT,
<span class="lineNum">     119 </span>            : };
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : enum
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span>            :         DASHER_CMAF_NONE=0,
<span class="lineNum">     124 </span>            :         DASHER_CMAF_CMFC,
<span class="lineNum">     125 </span>            :         DASHER_CMAF_CMF2
<span class="lineNum">     126 </span>            : };
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : typedef struct
<span class="lineNum">     129 </span>            : {
<span class="lineNum">     130 </span>            :         u32 bs_switch, profile, cp, ntp;
<span class="lineNum">     131 </span>            :         s32 subs_sidx;
<span class="lineNum">     132 </span>            :         s32 buf, timescale;
<span class="lineNum">     133 </span>            :         Bool sfile, sseg, no_sar, mix_codecs, stl, tpl, align, sap, no_frag_def, sidx, split, hlsc, strict_cues, force_flush, last_seg_merge;
<span class="lineNum">     134 </span>            :         u32 mha_compat;
<span class="lineNum">     135 </span>            :         u32 strict_sap;
<span class="lineNum">     136 </span>            :         u32 pssh;
<span class="lineNum">     137 </span>            :         u32 cmaf;
<span class="lineNum">     138 </span>            :         GF_Fraction segdur;
<span class="lineNum">     139 </span>            :         u32 dmode;
<span class="lineNum">     140 </span>            :         char *template;
<span class="lineNum">     141 </span>            :         char *segext;
<span class="lineNum">     142 </span>            :         char *initext;
<span class="lineNum">     143 </span>            :         u32 muxtype;
<span class="lineNum">     144 </span>            :         char *profX;
<span class="lineNum">     145 </span>            :         Double asto;
<span class="lineNum">     146 </span>            :         char *ast;
<span class="lineNum">     147 </span>            :         char *state;
<span class="lineNum">     148 </span>            :         char *cues;
<span class="lineNum">     149 </span>            :         char *title, *source, *info, *cprt, *lang;
<span class="lineNum">     150 </span>            :         GF_PropStringList location, base;
<span class="lineNum">     151 </span>            :         Bool check_dur, skip_seg, loop, reschedule, scope_deps;
<span class="lineNum">     152 </span>            :         Double refresh, tsb, subdur;
<span class="lineNum">     153 </span>            :         u64 *_p_gentime, *_p_mpdtime;
<span class="lineNum">     154 </span>            :         Bool m2ts;
<span class="lineNum">     155 </span>            :         Bool cmpd, dual, sreg, pswitch;
<span class="lineNum">     156 </span>            :         char *styp;
<span class="lineNum">     157 </span>            :         Bool sigfrag;
<span class="lineNum">     158 </span>            :         u32 sbound;
<span class="lineNum">     159 </span>            :         char *utcs;
<span class="lineNum">     160 </span>            :         char *mname;
<span class="lineNum">     161 </span>            :         char *hlsdrm;
<span class="lineNum">     162 </span>            :         u32 llhls;
<span class="lineNum">     163 </span>            :         //inherited from mp4mx
<span class="lineNum">     164 </span>            :         GF_Fraction cdur;
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :         //internal
<span class="lineNum">     167 </span>            :         Bool in_error;
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :         //Manifest output pid
<span class="lineNum">     170 </span>            :         GF_FilterPid *opid;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :         GF_FilterPid *opid_alt;
<span class="lineNum">     173 </span>            :         GF_Filter *alt_dst;
<span class="lineNum">     174 </span>            :         Bool opid_alt_m3u8;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :         GF_MPD *mpd;
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :         GF_DasherPeriod *current_period, *next_period;
<span class="lineNum">     179 </span>            :         GF_List *pids;
<span class="lineNum">     180 </span>            :         Bool template_use_source;
<span class="lineNum">     181 </span>            :         s32 period_idx;
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :         GF_List *tpl_records;
<span class="lineNum">     184 </span>            :         Bool use_xlink, use_cenc, check_main_role;
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :         //options for muxers, constrained by profile
<span class="lineNum">     187 </span>            :         Bool no_fragments_defaults;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :         Bool is_eos;
<span class="lineNum">     190 </span>            :         u32 nb_seg_url_pending;
<span class="lineNum">     191 </span>            :         u64 last_evt_check_time;
<span class="lineNum">     192 </span>            :         Bool on_demand_done;
<span class="lineNum">     193 </span>            :         Bool subdur_done;
<span class="lineNum">     194 </span>            :         char *out_path;
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :         GF_Err setup_failure;
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :         Double nb_secs_to_discard;
<span class="lineNum">     199 </span>            :         Bool first_context_load, store_init_params;
<span class="lineNum">     200 </span>            :         Bool do_m3u8, do_mpd;
<span class="lineNum">     201 </span>            :         Bool is_period_restore, is_empty_period;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :         Bool store_seg_states;
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :         GF_List *postponed_pids;
<span class="lineNum">     206 </span>            :         u32 last_dyn_period_id;
<span class="lineNum">     207 </span>            :         u32 next_pid_id_in_period;
<span class="lineNum">     208 </span>            :         Bool post_play_events;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :         Bool force_period_switch;
<span class="lineNum">     211 </span>            :         Bool period_not_ready;
<span class="lineNum">     212 </span>            :         Bool check_connections;
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :         //-1 forces report update, otherwise this is a packet count
<span class="lineNum">     215 </span>            :         s32 update_report;
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :         Bool purge_segments;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :         Bool is_playing;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :         Bool no_seg_dur;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :         Bool utc_initialized;
<span class="lineNum">     224 </span>            :         DasherUTCTimingType utc_timing_type;
<span class="lineNum">     225 </span>            :         s32 utc_diff;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :         Bool is_route;
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :         Bool force_hls_ll_manifest;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :         u32 forward_mode;
<span class="lineNum">     232 </span>            :         
<span class="lineNum">     233 </span>            :         u8 last_hls_signature[GF_SHA1_DIGEST_SIZE], last_mpd_signature[GF_SHA1_DIGEST_SIZE], last_hls2_signature[GF_SHA1_DIGEST_SIZE];
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :         GF_CryptInfo *cinfo;
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :         Bool use_cues;
<span class="lineNum">     238 </span>            :         Bool dyn_rate;
<span class="lineNum">     239 </span>            : } GF_DasherCtx;
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : typedef enum
<span class="lineNum">     242 </span>            : {
<span class="lineNum">     243 </span>            :         DASHER_HDR_NONE=0,
<span class="lineNum">     244 </span>            :         DASHER_HDR_PQ10,
<span class="lineNum">     245 </span>            :         DASHER_HDR_HLG,
<span class="lineNum">     246 </span>            : } DasherHDRType;
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : typedef struct _dash_stream
<span class="lineNum">     249 </span>            : {
<span class="lineNum">     250 </span>            :         GF_FilterPid *ipid, *opid;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :         //stream properties
<span class="lineNum">     253 </span>            :         u32 codec_id, timescale, stream_type, dsi_crc, dsi_enh_crc, id, dep_id, src_id;
<span class="lineNum">     254 </span>            :         GF_Fraction sar, fps;
<span class="lineNum">     255 </span>            :         u32 width, height;
<span class="lineNum">     256 </span>            :         u32 sr, nb_ch;
<span class="lineNum">     257 </span>            :         char *lang;
<span class="lineNum">     258 </span>            :         Bool interlaced;
<span class="lineNum">     259 </span>            :         const GF_PropertyValue *p_role;
<span class="lineNum">     260 </span>            :         const GF_PropertyValue *p_period_desc;
<span class="lineNum">     261 </span>            :         const GF_PropertyValue *p_as_desc;
<span class="lineNum">     262 </span>            :         const GF_PropertyValue *p_as_any_desc;
<span class="lineNum">     263 </span>            :         const GF_PropertyValue *p_rep_desc;
<span class="lineNum">     264 </span>            :         const GF_PropertyValue *p_base_url;
<span class="lineNum">     265 </span>            :         char *template;
<span class="lineNum">     266 </span>            :         char *xlink;
<span class="lineNum">     267 </span>            :         char *hls_vp_name;
<span class="lineNum">     268 </span>            :         u32 nb_surround, nb_lfe;
<span class="lineNum">     269 </span>            :         u64 ch_layout;
<span class="lineNum">     270 </span>            :         GF_PropVec4i srd;
<span class="lineNum">     271 </span>            :         DasherHDRType hdr_type;
<span class="lineNum">     272 </span>            :         Bool sscale;
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :         //TODO: get the values for all below
<span class="lineNum">     275 </span>            :         u32 view_id;
<span class="lineNum">     276 </span>            :         //end of TODO
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :         u32 bitrate;
<span class="lineNum">     280 </span>            :         GF_DasherPeriod *period;
<span class="lineNum">     281 </span>            :         GF_MPD_Period *last_period;
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :         GF_Fraction dash_dur;
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :         char *period_id;
<span class="lineNum">     286 </span>            :         char *period_continuity_id;
<span class="lineNum">     287 </span>            :         GF_Fraction64 period_start;
<span class="lineNum">     288 </span>            :         GF_Fraction64 period_dur;
<span class="lineNum">     289 </span>            :         //0: not done, 1: eos/abort, 2: subdur exceeded
<span class="lineNum">     290 </span>            :         u32 done;
<span class="lineNum">     291 </span>            :         Bool seg_done;
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :         u32 nb_comp, nb_comp_done;
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :         u32 nb_rep, nb_rep_done;
<span class="lineNum">     296 </span>            :         Double set_seg_duration;
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :         //repID for this stream, generated if not found
<span class="lineNum">     299 </span>            :         char *rep_id;
<span class="lineNum">     300 </span>            :         //AS ID for this stream, may be 0
<span class="lineNum">     301 </span>            :         u32 as_id;
<span class="lineNum">     302 </span>            :         u32 sync_as_id;
<span class="lineNum">     303 </span>            :         struct _dash_stream *muxed_base;
<span class="lineNum">     304 </span>            :         GF_List *complementary_streams;
<span class="lineNum">     305 </span>            :         GF_List *comp_pids;
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :         //the one and only representation element
<span class="lineNum">     308 </span>            :         GF_MPD_Representation *rep;
<span class="lineNum">     309 </span>            :         //the parent adaptation set
<span class="lineNum">     310 </span>            :         GF_MPD_AdaptationSet *set;
<span class="lineNum">     311 </span>            :         Bool owns_set;
<span class="lineNum">     312 </span>            :         //set to true to use inband params
<span class="lineNum">     313 </span>            :         Bool inband_params;
<span class="lineNum">     314 </span>            :         GF_List *multi_pids;
<span class="lineNum">     315 </span>            :         GF_List *multi_tracks;
<span class="lineNum">     316 </span>            :         //in case we share the same init segment, we MUST use the same timescale
<span class="lineNum">     317 </span>            :         u32 force_timescale;
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :         u32 startNumber, seg_number;
<span class="lineNum">     321 </span>            :         Bool rep_init;
<span class="lineNum">     322 </span>            :         u64 first_cts;
<span class="lineNum">     323 </span>            :         u64 first_dts;
<span class="lineNum">     324 </span>            :         s64 pts_minus_cts;
<span class="lineNum">     325 </span>            :         Bool is_encrypted;
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :         //target MPD timescale
<span class="lineNum">     328 </span>            :         u32 mpd_timescale;
<span class="lineNum">     329 </span>            :         //segment start time in target MPD timescale
<span class="lineNum">     330 </span>            :         u64 seg_start_time;
<span class="lineNum">     331 </span>            :         Bool split_set_names;
<span class="lineNum">     332 </span>            :         Bool skip_tpl_reuse;
<span class="lineNum">     333 </span>            :         u64 max_period_dur;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :         GF_Filter *dst_filter;
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :         char *src_url;
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :         char *init_seg, *seg_template, *idx_template;
<span class="lineNum">     340 </span>            :         u32 nb_sap_3, nb_sap_4;
<span class="lineNum">     341 </span>            :         //ID of output pid (renumbered), used for content component and making sure output muxers use the same IDs
<span class="lineNum">     342 </span>            :         u32 pid_id;
<span class="lineNum">     343 </span>            :         //dependency ID of output pid (renumbered)
<span class="lineNum">     344 </span>            :         u32 dep_pid_id;
<span class="lineNum">     345 </span>            :         u32 nb_samples_in_source;
<span class="lineNum">     346 </span>            :         u32 sync_points_type;
<span class="lineNum">     347 </span>            :         //seg urls not yet handled (waiting for size/index callbacks)
<span class="lineNum">     348 </span>            :         GF_List *pending_segment_urls;
<span class="lineNum">     349 </span>            :         //segment states not yet handled (waiting for size/index/etc callbacks), used for M3U8 and state mode
<span class="lineNum">     350 </span>            :         GF_List *pending_segment_states;
<span class="lineNum">     351 </span>            :         //next segment start time in this stream timescale (NOT MPD timescale)
<span class="lineNum">     352 </span>            :         u64 next_seg_start;
<span class="lineNum">     353 </span>            :         //adjusted next segment start time in this stream timescale (NOT MPD timescale)
<span class="lineNum">     354 </span>            :         //the value is the same as next_seg_start until the end of segment is found (SAP)
<span class="lineNum">     355 </span>            :         //in which case it is adjusted to the SAP time
<span class="lineNum">     356 </span>            :         u64 adjusted_next_seg_start;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :         //force representation time end in this stream timescale (NOT MPD timescale)
<span class="lineNum">     359 </span>            :         u64 force_rep_end;
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :         Bool segment_started;
<span class="lineNum">     362 </span>            :         u64 first_cts_in_seg;
<span class="lineNum">     363 </span>            :         u64 first_cts_in_next_seg;
<span class="lineNum">     364 </span>            :         //used for last segment computation of segmentTimeline
<span class="lineNum">     365 </span>            :         u64 est_first_cts_in_next_seg;
<span class="lineNum">     366 </span>            :         u64 last_cts, last_dts;
<span class="lineNum">     367 </span>            :         u64 cumulated_dur;
<span class="lineNum">     368 </span>            :         Double cumulated_subdur;
<span class="lineNum">     369 </span>            :         Bool subdur_done;
<span class="lineNum">     370 </span>            :         u64 subdur_forced_use_period_dur;
<span class="lineNum">     371 </span>            :         u64 nb_pck;
<span class="lineNum">     372 </span>            :         u64 est_next_dts;
<span class="lineNum">     373 </span>            :         u64 seek_to_pck;
<span class="lineNum">     374 </span>            :         u64 ts_offset;
<span class="lineNum">     375 </span>            :         u32 nb_repeat;
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :         Bool splitable;
<span class="lineNum">     378 </span>            :         u32 loop_state;
<span class="lineNum">     379 </span>            :         u32 split_dur_next;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :         u32 moof_sn_inc, moof_sn;
<span class="lineNum">     382 </span>            :         GF_Fraction64 clamped_dur;
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :         u32 nb_segments_purged;
<span class="lineNum">     385 </span>            :         Double dur_purged;
<span class="lineNum">     386 </span>            :         Bool tile_base;
<span class="lineNum">     387 </span>            :         Bool tile_dep_id_merged;
<span class="lineNum">     388 </span>            :         struct _dash_stream *merged_tile_dep;
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :         u32 cues_timescale;
<span class="lineNum">     391 </span>            :         u32 nb_cues;
<span class="lineNum">     392 </span>            :         GF_DASHCueInfo *cues;
<span class="lineNum">     393 </span>            :         Bool cues_use_edits;
<span class="lineNum">     394 </span>            :         s32 cues_ts_offset;
<span class="lineNum">     395 </span>            :         Bool inband_cues;
<span class="lineNum">     396 </span>            :         
<span class="lineNum">     397 </span>            :         Bool clamp_done;
<span class="lineNum">     398 </span>            :         u32 dcd_not_ready;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :         Bool reschedule;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :         GF_Fraction64 duration;
<span class="lineNum">     403 </span>            :         GF_List *packet_queue;
<span class="lineNum">     404 </span>            :         u32 nb_sap_in_queue;
<span class="lineNum">     405 </span>            :         u32 sbound;
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :         u32 request_period_switch;
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :         //gm_ for gen manifest
<span class="lineNum">     410 </span>            :         Double gm_duration_total, gm_duration_min, gm_duration_max;
<span class="lineNum">     411 </span>            :         u32 gm_nb_segments;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :         Bool no_seg_dur;
<span class="lineNum">     414 </span>            :         //for route
<span class="lineNum">     415 </span>            :         u64 hls_ref_id;
<span class="lineNum">     416 </span>            :         GF_DASH_SegmentContext *current_seg_state;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :         Bool transcode_detected;
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :         //HLS full seg encryption
<span class="lineNum">     421 </span>            :         GF_CryptInfo *cinfo;
<span class="lineNum">     422 </span>            :         GF_TrackCryptInfo *tci;
<span class="lineNum">     423 </span>            :         u64 iv_low, iv_high;
<span class="lineNum">     424 </span>            :         u32 key_idx;
<span class="lineNum">     425 </span>            :         u32 nb_crypt_seg;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :         Bool dyn_bitrate;
<span class="lineNum">     428 </span>            :         u64 rate_first_dts_plus_one, rate_last_dts;
<span class="lineNum">     429 </span>            :         u64 rate_media_size;
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :         u64 period_continuity_next_cts;
<span class="lineNum">     432 </span>            : } GF_DashStream;
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            : static void dasher_flush_segment(GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_last_in_period);
<span class="lineNum">     435 </span>            : static void dasher_update_rep(GF_DasherCtx *ctx, GF_DashStream *ds);
<span class="lineNum">     436 </span>            : static void dasher_reset_stream(GF_Filter *filter, GF_DashStream *ds, Bool is_destroy);
<span class="lineNum">     437 </span>            : static void dasher_update_period_duration(GF_DasherCtx *ctx, Bool is_period_switch);
<a name="438"><span class="lineNum">     438 </span>            : static GF_Err dasher_setup_period(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *for_ds);</a>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineCov">        488 : static GF_DasherPeriod *dasher_new_period()</span>
<span class="lineNum">     441 </span>            : {
<span class="lineNum">     442 </span>            :         GF_DasherPeriod *period;
<span class="lineNum">     443 </span><span class="lineCov">        488 :         GF_SAFEALLOC(period, GF_DasherPeriod);</span>
<span class="lineNum">     444 </span><span class="lineCov">        488 :         if (period)</span>
<span class="lineNum">     445 </span><span class="lineCov">        488 :                 period-&gt;streams = gf_list_new();</span>
<span class="lineNum">     446 </span><span class="lineCov">        488 :         return period;</span>
<span class="lineNum">     447 </span>            : }
<a name="448"><span class="lineNum">     448 </span>            : </a>
<span class="lineNum">     449 </span>            : #ifndef GPAC_DISABLE_AV_PARSERS
<span class="lineNum">     450 </span><span class="lineCov">        126 : static GF_Err dasher_get_audio_info_with_m4a_sbr_ps(GF_DashStream *ds, const GF_PropertyValue *dsi, u32 *SampleRate, u32 *Channels)</span>
<span class="lineNum">     451 </span>            : {
<span class="lineNum">     452 </span>            :         GF_M4ADecSpecInfo a_cfg;
<span class="lineNum">     453 </span>            :         GF_Err e;
<span class="lineNum">     454 </span><span class="lineCov">        126 :         if (SampleRate) *SampleRate = ds-&gt;sr;</span>
<span class="lineNum">     455 </span><span class="lineCov">        126 :         if (Channels) *Channels = ds-&gt;nb_ch;</span>
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineCov">        126 :         if (!dsi) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                 if (!ds-&gt;dcd_not_ready) {</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] missing AAC config\n&quot;));</span>
<span class="lineNum">     460 </span>            :                 }
<span class="lineNum">     461 </span>            :                 return GF_OK;
<span class="lineNum">     462 </span>            :         }
<span class="lineNum">     463 </span><span class="lineCov">        126 :         e = gf_m4a_get_config(dsi-&gt;value.data.ptr, dsi-&gt;value.data.size, &amp;a_cfg);</span>
<span class="lineNum">     464 </span><span class="lineCov">        126 :         if (e) {</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] corrupted AAC Config, %s\n&quot;, gf_error_to_string(e)));</span>
<span class="lineNum">     466 </span>            :                 return GF_NOT_SUPPORTED;
<span class="lineNum">     467 </span>            :         }
<span class="lineNum">     468 </span><span class="lineCov">        126 :         if (SampleRate &amp;&amp; a_cfg.has_sbr) {</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :                 *SampleRate = a_cfg.sbr_sr;</span>
<span class="lineNum">     470 </span>            :         }
<span class="lineNum">     471 </span><span class="lineCov">        126 :         if (Channels) *Channels = a_cfg.nb_chan;</span>
<span class="lineNum">     472 </span>            :         return e;
<span class="lineNum">     473 </span>            : }
<span class="lineNum">     474 </span>            : #endif
<a name="475"><span class="lineNum">     475 </span>            : </a>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineCov">        250 : static void dasher_check_outpath(GF_DasherCtx *ctx)</span>
<span class="lineNum">     478 </span>            : {
<span class="lineNum">     479 </span><span class="lineCov">        250 :         if (!ctx-&gt;out_path) {</span>
<span class="lineNum">     480 </span><span class="lineCov">        248 :                 ctx-&gt;out_path = gf_filter_pid_get_destination(ctx-&gt;opid);</span>
<span class="lineNum">     481 </span><span class="lineCov">        248 :                 if (!ctx-&gt;out_path) return;</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">        244 :                 if (ctx-&gt;mname) {</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                         char *sep = strstr(ctx-&gt;out_path, &quot;://&quot;);</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :                         if (sep) {</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                                 char *opath = gf_url_concatenate(ctx-&gt;out_path, ctx-&gt;mname);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                                 if (opath) {</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :                                         gf_free(ctx-&gt;out_path);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                                         ctx-&gt;out_path = opath;</span>
<span class="lineNum">     490 </span>            :                                 }
<span class="lineNum">     491 </span>            :                         }
<span class="lineNum">     492 </span>            :                 }
<span class="lineNum">     493 </span>            :                 //check if we have a route/atsc output, in which we will case assign hls ref prop
<span class="lineNum">     494 </span><span class="lineCov">        244 :                 if (!strncmp(ctx-&gt;out_path, &quot;route://&quot;, 8) || !strncmp(ctx-&gt;out_path, &quot;atsc://&quot;, 7))</span>
<span class="lineNum">     495 </span><span class="lineCov">          4 :                         ctx-&gt;is_route = GF_TRUE;</span>
<span class="lineNum">     496 </span>            :         }
<span class="lineNum">     497 </span>            :         //for routeout
<span class="lineNum">     498 </span><span class="lineCov">        246 :         if (ctx-&gt;opid)</span>
<span class="lineNum">     499 </span><span class="lineCov">        246 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_URL, &amp;PROP_STRING(ctx-&gt;out_path) );</span>
<span class="lineNum">     500 </span><span class="lineCov">        246 :         if (ctx-&gt;opid_alt)</span>
<span class="lineNum">     501 </span><span class="lineCov">          2 :                 gf_filter_pid_set_property(ctx-&gt;opid_alt, GF_PROP_PID_URL, &amp;PROP_STRING(ctx-&gt;out_path) );</span>
<span class="lineNum">     502 </span>            : }
<a name="503"><span class="lineNum">     503 </span>            : </a>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span><span class="lineCov">        577 : static GF_Err dasher_hls_setup_crypto(GF_DasherCtx *ctx, GF_DashStream *ds)</span>
<span class="lineNum">     506 </span>            : {
<span class="lineNum">     507 </span>            :         GF_Err e;
<span class="lineNum">     508 </span>            :         u32 pid_id=1;
<span class="lineNum">     509 </span>            :         u32 i, count;
<span class="lineNum">     510 </span>            :         const GF_PropertyValue *p;
<span class="lineNum">     511 </span>            :         GF_CryptInfo *cinfo = NULL;
<span class="lineNum">     512 </span><span class="lineCov">        577 :         const char *drm = ctx-&gt;hlsdrm;</span>
<span class="lineNum">     513 </span><span class="lineCov">        577 :         if (!ctx-&gt;do_m3u8) return GF_OK;</span>
<span class="lineNum">     514 </span><span class="lineCov">         60 :         if (ds-&gt;is_encrypted) return GF_OK;</span>
<span class="lineNum">     515 </span><span class="lineCov">         31 :         p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_CRYPT_INFO);</span>
<span class="lineNum">     516 </span><span class="lineCov">         31 :         if (p)</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                 drm = p-&gt;value.string;</span>
<span class="lineNum">     518 </span>            :         else
<span class="lineNum">     519 </span><span class="lineCov">         31 :                 cinfo = ctx-&gt;cinfo;</span>
<span class="lineNum">     520 </span><span class="lineCov">         31 :         if (!drm &amp;&amp; !cinfo) return GF_OK;</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :         if (ctx-&gt;sfile) {</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (&quot;[Dasher] Cannot use HLS segment encryption with single file output\n&quot;));</span>
<span class="lineNum">     524 </span>            :                 return GF_BAD_PARAM;
<span class="lineNum">     525 </span>            :         }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         if (!cinfo) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                 cinfo = gf_crypt_info_load(drm, &amp;e);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                 if (!cinfo) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (&quot;[Dasher] Cannot load HLS DRM file %s\n&quot;, drm ));</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :                         return e;</span>
<span class="lineNum">     532 </span>            :                 }
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                 if (p) {</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                         if (ds-&gt;cinfo) gf_crypt_info_del(ds-&gt;cinfo);</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                         ds-&gt;cinfo = cinfo;</span>
<span class="lineNum">     536 </span>            :                 } else {
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :                         ctx-&gt;cinfo = cinfo;</span>
<span class="lineNum">     538 </span>            :                 }
<span class="lineNum">     539 </span>            :         }
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :         ds-&gt;tci = NULL;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_ID);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         if (p) pid_id = p-&gt;value.uint;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         count = gf_list_count(cinfo-&gt;tcis);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 GF_TrackCryptInfo *tci = gf_list_get(cinfo-&gt;tcis, i);</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                 if (tci-&gt;trackID &amp;&amp; (tci-&gt;trackID != pid_id)) continue;</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                 ds-&gt;tci = tci;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     550 </span>            :         }
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         if (!ds-&gt;tci) return GF_OK;</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         ds-&gt;key_idx = 0;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         ds-&gt;iv_low = ds-&gt;iv_high = 0;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;8; i++) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :                 ds-&gt;iv_high |= ds-&gt;tci-&gt;keys[ds-&gt;key_idx].IV[i];</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :                 ds-&gt;iv_low |= ds-&gt;tci-&gt;keys[ds-&gt;key_idx].IV[i + 8];</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 if (i&lt;7) {</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                         ds-&gt;iv_high &lt;&lt;= 8;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                         ds-&gt;iv_low &lt;&lt;= 8;</span>
<span class="lineNum">     561 </span>            :                 }
<span class="lineNum">     562 </span>            :         }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :         return GF_OK;
<a name="565"><span class="lineNum">     565 </span>            : }</a>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineCov">         78 : static u32 dasher_get_dep_bitrate(GF_DasherCtx *ctx, GF_DashStream *ds)</span>
<span class="lineNum">     568 </span>            : {
<span class="lineNum">     569 </span><span class="lineCov">         78 :         u32 bitrate = ds-&gt;bitrate;</span>
<span class="lineNum">     570 </span><span class="lineCov">         78 :         if (ds-&gt;dep_id) {</span>
<span class="lineNum">     571 </span><span class="lineCov">         39 :                 u32 i, count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">     572 </span><span class="lineCov">        587 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">     573 </span><span class="lineCov">        548 :                         GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">     574 </span><span class="lineCov">        548 :                         if (a_ds == ds) continue;</span>
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span><span class="lineCov">        509 :                         if (gf_list_find(a_ds-&gt;complementary_streams, ds)&gt;=0) {</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">         39 :                                 bitrate += dasher_get_dep_bitrate(ctx, a_ds);</span>
<span class="lineNum">     579 </span>            :                         }
<span class="lineNum">     580 </span>            :                 }
<span class="lineNum">     581 </span>            :         }
<span class="lineNum">     582 </span><span class="lineCov">         78 :         return bitrate;</span>
<a name="583"><span class="lineNum">     583 </span>            : }</a>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineCov">        282 : static void dasher_update_bitrate(GF_DasherCtx *ctx, GF_DashStream *ds)</span>
<span class="lineNum">     586 </span>            : {
<span class="lineNum">     587 </span>            :         u64 rate;
<span class="lineNum">     588 </span>            :         u32 scaler;
<span class="lineNum">     589 </span><span class="lineCov">        282 :         if (!ds-&gt;dyn_bitrate || ds-&gt;bitrate) {</span>
<span class="lineNum">     590 </span>            :                 return;
<span class="lineNum">     591 </span>            :         }
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineCov">        215 :         if (!ds-&gt;rate_first_dts_plus_one) {</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't compute bitrate in time for manifest generation, please report to GPAC devs !\n&quot;));</span>
<span class="lineNum">     595 </span>            :                 return;
<span class="lineNum">     596 </span>            :         }
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineCov">        215 :         rate = ds-&gt;rate_media_size;</span>
<span class="lineNum">     599 </span><span class="lineCov">        215 :         rate *= 8;</span>
<span class="lineNum">     600 </span><span class="lineCov">        215 :         if (ds-&gt;rate_last_dts &gt; ds-&gt;rate_first_dts_plus_one - 1) {</span>
<span class="lineNum">     601 </span><span class="lineCov">        215 :                 rate *= ds-&gt;timescale;</span>
<span class="lineNum">     602 </span><span class="lineCov">        215 :                 rate /= (ds-&gt;rate_last_dts - ds-&gt;rate_first_dts_plus_one + 1);</span>
<span class="lineNum">     603 </span>            :         } else {
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :                 rate *= ds-&gt;dash_dur.den;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                 rate /= ds-&gt;dash_dur.num;</span>
<span class="lineNum">     606 </span>            :         }
<span class="lineNum">     607 </span>            :         //express rates in 100kbps or 10kbps, and if ds is done, trust the average, otherwise add 10%
<span class="lineNum">     608 </span><span class="lineCov">        215 :         scaler = (rate &gt; 1000000) ? 100000 : 10000;</span>
<span class="lineNum">     609 </span><span class="lineCov">        215 :         if (rate &gt; 10*scaler) {</span>
<span class="lineNum">     610 </span><span class="lineCov">        187 :                 rate /= scaler;</span>
<span class="lineNum">     611 </span><span class="lineCov">        187 :                 if (!ds-&gt;done) scaler = 11 * scaler / 10;</span>
<span class="lineNum">     612 </span><span class="lineCov">        187 :                 rate *= scaler;</span>
<span class="lineNum">     613 </span>            :         }
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">        215 :         ds-&gt;bitrate = (u32) rate;</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineCov">        215 :         if (ds-&gt;rep)</span>
<span class="lineNum">     618 </span><span class="lineCov">        210 :                 ds-&gt;rep-&gt;bandwidth = ds-&gt;bitrate;</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">        215 :         if (ds-&gt;dep_id) {</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                 ds-&gt;rep-&gt;bandwidth = dasher_get_dep_bitrate(ctx, ds);</span>
<span class="lineNum">     622 </span><span class="lineCov">        215 :         } else if (ds-&gt;nb_comp &amp;&amp; !ds-&gt;muxed_base) {</span>
<span class="lineNum">     623 </span><span class="lineCov">        210 :                 u32 i, count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">     624 </span><span class="lineCov">        443 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">     625 </span><span class="lineCov">        233 :                         GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">     626 </span><span class="lineCov">        233 :                         if (ds == a_ds) continue;;</span>
<span class="lineNum">     627 </span><span class="lineCov">         23 :                         if (a_ds-&gt;muxed_base != ds) continue;</span>
<span class="lineNum">     628 </span><span class="lineCov">          5 :                         if (a_ds-&gt;dyn_bitrate) {</span>
<span class="lineNum">     629 </span><span class="lineCov">          5 :                                 dasher_update_bitrate(ctx, a_ds);</span>
<span class="lineNum">     630 </span>            :                         }
<span class="lineNum">     631 </span><span class="lineCov">          5 :                         ds-&gt;rep-&gt;bandwidth += a_ds-&gt;bitrate;</span>
<span class="lineNum">     632 </span>            :                 }
<span class="lineNum">     633 </span>            :         }
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :         //keep refreshing our rate estimation
<span class="lineNum">     636 </span><span class="lineCov">        215 :         if (!ds-&gt;done &amp;&amp; (ds-&gt;dyn_bitrate==1))</span>
<span class="lineNum">     637 </span><span class="lineCov">        157 :                 ds-&gt;bitrate = 0;</span>
<span class="lineNum">     638 </span>            : }
<a name="639"><span class="lineNum">     639 </span>            : </a>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineCov">        357 : static GF_Err dasher_stream_period_changed(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_new_period_request)</span>
<span class="lineNum">     642 </span>            : {
<span class="lineNum">     643 </span>            :         //period switching, check the stream is still scheduled - if so and not done, flush it, update period duration
<span class="lineNum">     644 </span><span class="lineCov">        357 :         s32 res = gf_list_find(ctx-&gt;current_period-&gt;streams, ds);</span>
<span class="lineNum">     645 </span>            :         //force end of segment if stream is not yet done and in current period
<span class="lineNum">     646 </span><span class="lineCov">        357 :         if ((res&gt;=0) &amp;&amp; !ds-&gt;done &amp;&amp; !ds-&gt;seg_done) {</span>
<span class="lineNum">     647 </span>            :                 GF_DashStream *base_ds;
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :                 base_ds = ds-&gt;muxed_base ? ds-&gt;muxed_base : ds;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :                 if (is_new_period_request) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] New period requested during PID %s reconfiguration\n&quot;, gf_filter_pid_get_name(ds-&gt;ipid) ));</span>
<span class="lineNum">     652 </span>            :                 } else {
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] PID %s config changed during active period, forcing period switch\n&quot;, gf_filter_pid_get_name(ds-&gt;ipid) ));</span>
<span class="lineNum">     654 </span>            :                 }
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :                 ds-&gt;seg_done = GF_TRUE;</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :                 if(base_ds-&gt;nb_comp_done &gt;= base_ds-&gt;nb_comp) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Invalid new period: %u components processed (max %u expected)\n&quot;, base_ds-&gt;nb_comp_done, base_ds-&gt;nb_comp));</span>
<span class="lineNum">     658 </span>            :                         return GF_BAD_PARAM;
<span class="lineNum">     659 </span>            :                 }
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :                 base_ds-&gt;nb_comp_done ++;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :                 ds-&gt;first_cts_in_next_seg = ds-&gt;est_first_cts_in_next_seg;;</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 if (base_ds-&gt;nb_comp_done == base_ds-&gt;nb_comp) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                         dasher_flush_segment(ctx, base_ds, GF_TRUE);</span>
<span class="lineNum">     665 </span>            :                 }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                 ctx-&gt;force_period_switch = GF_TRUE;</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                 dasher_update_period_duration(ctx, GF_TRUE);</span>
<span class="lineNum">     669 </span>            :         }
<span class="lineNum">     670 </span>            :         //remove stream from period
<span class="lineNum">     671 </span><span class="lineCov">        357 :         if (res&gt;=0) {</span>
<span class="lineNum">     672 </span>            :                 //force an EOS on this stream for ondemand / side index generation flush
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :                 if (ds-&gt;opid)</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :                         gf_filter_pid_set_eos(ds-&gt;opid);</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :                 ds-&gt;rep_init = GF_FALSE;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :                 gf_list_rem(ctx-&gt;current_period-&gt;streams, res);</span>
<span class="lineNum">     677 </span>            :         }
<span class="lineNum">     678 </span><span class="lineCov">        357 :         ds-&gt;request_period_switch = 0;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :         //this is tricky, when reassigning period IDs in the middle of a stream, we may have cases where some streams
<span class="lineNum">     681 </span>            :         //are ready several packets before other streams due to processing delay, which results in period switch signal not
<span class="lineNum">     682 </span>            :         //happening at the same time
<span class="lineNum">     683 </span><span class="lineCov">        357 :         if (is_new_period_request &amp;&amp; !ds-&gt;rep &amp;&amp; ctx-&gt;current_period-&gt;period &amp;&amp; gf_list_count(ctx-&gt;current_period-&gt;streams)) {</span>
<span class="lineNum">     684 </span>            :                 Bool inject_in_period = GF_FALSE;
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :                 if (ds-&gt;period_id &amp;&amp; ctx-&gt;current_period-&gt;period-&gt;ID &amp;&amp; !strcmp(ds-&gt;period_id, ctx-&gt;current_period-&gt;period-&gt;ID))</span>
<span class="lineNum">     686 </span>            :                         inject_in_period = GF_TRUE;
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                 else if ((ctx-&gt;period_idx&gt;0) &amp;&amp; (ds-&gt;period_start.num&lt;0) &amp;&amp; ((s32) -ds-&gt;period_start.num == ctx-&gt;period_idx))</span>
<span class="lineNum">     688 </span>            :                         inject_in_period = GF_TRUE;
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :                 else if (ds-&gt;period_start.num * 1000 == ctx-&gt;current_period-&gt;period-&gt;start * ds-&gt;period_start.den)</span>
<span class="lineNum">     690 </span>            :                         inject_in_period = GF_TRUE;
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :                 if (inject_in_period) {
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :                         gf_list_add(ctx-&gt;current_period-&gt;streams, ds);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :                         ds-&gt;period = ctx-&gt;current_period;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :                         dasher_setup_period(filter, ctx, ds);</span>
<span class="lineNum">     696 </span>            :                         //force a MPD publish asap
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                         if (ctx-&gt;dmode != GF_DASH_STATIC)</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                                 ctx-&gt;mpd-&gt;publishTime = 0;</span>
<span class="lineNum">     699 </span>            :                         return GF_OK;
<span class="lineNum">     700 </span>            :                 }
<span class="lineNum">     701 </span>            :         }
<span class="lineNum">     702 </span><span class="lineCov">        357 :         gf_list_add(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">     703 </span><span class="lineCov">        357 :         ds-&gt;period = ctx-&gt;next_period;</span>
<span class="lineNum">     704 </span><span class="lineCov">        357 :         return GF_OK;</span>
<a name="705"><span class="lineNum">     705 </span>            : }</a>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineCov">         32 : static void dasher_send_encode_hints(GF_DasherCtx *ctx, GF_DashStream *ds)</span>
<span class="lineNum">     708 </span>            : {
<span class="lineNum">     709 </span><span class="lineCov">         32 :         if (!ctx-&gt;sfile &amp;&amp; !ctx-&gt;stl &amp;&amp; !ctx-&gt;use_cues) {</span>
<span class="lineNum">     710 </span>            :                 GF_FilterEvent evt;
<span class="lineNum">     711 </span><span class="lineCov">         32 :                 GF_FEVT_INIT(evt, GF_FEVT_ENCODE_HINTS, ds-&gt;ipid)</span>
<span class="lineNum">     712 </span><span class="lineCov">         32 :                 evt.encode_hints.intra_period = ds-&gt;dash_dur;</span>
<span class="lineNum">     713 </span><span class="lineCov">         32 :                 gf_filter_pid_send_event(ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">     714 </span>            :         }
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">         32 : }</span></a>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span><span class="lineCov">        577 : static GF_Err dasher_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)</span>
<span class="lineNum">     718 </span>            : {
<span class="lineNum">     719 </span>            :         Bool period_switch = GF_FALSE;
<span class="lineNum">     720 </span>            :         const GF_PropertyValue *p, *dsi=NULL;
<span class="lineNum">     721 </span>            :         u32 dc_crc, dc_enh_crc;
<span class="lineNum">     722 </span>            :         GF_Err e;
<span class="lineNum">     723 </span>            :         GF_DashStream *ds;
<span class="lineNum">     724 </span>            :         Bool old_period_switch;
<span class="lineNum">     725 </span>            :         u32 prev_stream_type;
<span class="lineNum">     726 </span>            :         Bool new_period_request = GF_FALSE;
<span class="lineNum">     727 </span>            :         const char *cue_file=NULL;
<span class="lineNum">     728 </span>            :         s64 old_clamp_dur = 0;
<span class="lineNum">     729 </span><span class="lineCov">        577 :         GF_DasherCtx *ctx = gf_filter_get_udta(filter);</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineCov">        577 :         if (is_remove) {</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :                 ds = gf_filter_pid_get_udta(pid);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                 if (ds) {</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :                         if (ds-&gt;dyn_bitrate) dasher_update_bitrate(ctx, ds);</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :                         gf_list_del_item(ctx-&gt;pids, ds);</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :                         gf_list_del_item(ctx-&gt;current_period-&gt;streams, ds);</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :                         if (ctx-&gt;next_period)</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :                                 gf_list_del_item(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :                         dasher_reset_stream(filter, ds, GF_TRUE);</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :                         gf_free(ds);</span>
<span class="lineNum">     741 </span>            :                 }
<span class="lineNum">     742 </span>            :                 return GF_OK;
<span class="lineNum">     743 </span>            :         }
<span class="lineNum">     744 </span><span class="lineCov">        577 :         ctx-&gt;check_connections = GF_TRUE;</span>
<span class="lineNum">     745 </span><span class="lineCov">        577 :         if (!ctx-&gt;opid) {</span>
<span class="lineNum">     746 </span><span class="lineCov">        244 :                 u32 i, nb_opids = ctx-&gt;dual ? 2 : 1;</span>
<span class="lineNum">     747 </span><span class="lineCov">        490 :                 for (i=0; i &lt; nb_opids; i++) {</span>
<span class="lineNum">     748 </span>            :                         char *segext=NULL;
<span class="lineNum">     749 </span>            :                         char *force_ext=NULL;
<span class="lineNum">     750 </span>            :                         GF_FilterPid *opid;
<span class="lineNum">     751 </span><span class="lineCov">        246 :                         if (i==0) {</span>
<span class="lineNum">     752 </span><span class="lineCov">        244 :                                 ctx-&gt;opid = gf_filter_pid_new(filter);</span>
<span class="lineNum">     753 </span><span class="lineCov">        244 :                                 gf_filter_pid_set_name(ctx-&gt;opid, &quot;MANIFEST&quot;);</span>
<span class="lineNum">     754 </span><span class="lineCov">        244 :                                 opid = ctx-&gt;opid;</span>
<span class="lineNum">     755 </span>            :                         } else {
<span class="lineNum">     756 </span><span class="lineCov">          2 :                                 if (!ctx-&gt;alt_dst &amp;&amp; ctx-&gt;out_path) {</span>
<span class="lineNum">     757 </span>            :                                         char szSRC[100];
<span class="lineNum">     758 </span>            :                                         GF_FileIO *gfio = NULL;
<span class="lineNum">     759 </span>            :                                         char *mpath = ctx-&gt;out_path;
<span class="lineNum">     760 </span>            :                                         u32 len;
<span class="lineNum">     761 </span><span class="lineCov">          2 :                                         if (!strncmp(mpath, &quot;gfio://&quot;, 7)) {</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :                                                 gfio = gf_fileio_from_url(mpath);</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                                                 if (!gfio) return GF_BAD_PARAM;</span>
<span class="lineNum">     764 </span>            :                                                 //only use basename as we will create the new resource through factory
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                                                 mpath = (char *) gf_file_basename(gf_fileio_resource_url(gfio));</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                                                 if (!mpath) return GF_OUT_OF_MEM;</span>
<span class="lineNum">     767 </span>            :                                         }
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">          2 :                                         len = (u32) strlen(mpath);</span>
<span class="lineNum">     770 </span><span class="lineCov">          2 :                                         char *out_path = gf_malloc(len+10);</span>
<span class="lineNum">     771 </span><span class="lineCov">          2 :                                         if (!out_path) return GF_OUT_OF_MEM;</span>
<span class="lineNum">     772 </span>            :                                         memcpy(out_path, mpath, len);
<span class="lineNum">     773 </span><span class="lineCov">          2 :                                         out_path[len]=0;</span>
<span class="lineNum">     774 </span><span class="lineCov">          2 :                                         char *sep = gf_file_ext_start(out_path);</span>
<span class="lineNum">     775 </span><span class="lineCov">          2 :                                         if (sep) sep[0] = 0;</span>
<span class="lineNum">     776 </span><span class="lineCov">          2 :                                         if (ctx-&gt;do_m3u8) {</span>
<span class="lineNum">     777 </span>            :                                                 strcat(out_path, &quot;.mpd&quot;);
<span class="lineNum">     778 </span>            :                                                 force_ext = &quot;mpd&quot;;
<span class="lineNum">     779 </span>            :                                         } else {
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;opid_alt_m3u8 = GF_TRUE;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;do_m3u8 = GF_TRUE;</span>
<span class="lineNum">     782 </span>            :                                                 strcat(out_path, &quot;.m3u8&quot;);
<span class="lineNum">     783 </span>            :                                                 force_ext = &quot;m3u8&quot;;
<span class="lineNum">     784 </span>            :                                         }
<span class="lineNum">     785 </span><span class="lineCov">          2 :                                         if (gfio) {</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                                                 const char *rel = gf_fileio_factory(gfio, out_path);</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :                                                 gf_free(out_path);</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :                                                 out_path = gf_strdup(rel);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :                                                 if (!out_path) return GF_OUT_OF_MEM;</span>
<span class="lineNum">     790 </span>            :                                         }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">          2 :                                         ctx-&gt;alt_dst = gf_filter_connect_destination(filter, out_path, &amp;e);</span>
<span class="lineNum">     793 </span><span class="lineCov">          2 :                                         if (e) {</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't create secondary manifest output %s: %s\n&quot;, out_path, gf_error_to_string(e) ));</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :                                                 gf_free(out_path);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                                                 break;</span>
<span class="lineNum">     797 </span>            :                                         }
<span class="lineNum">     798 </span><span class="lineCov">          2 :                                         gf_free(out_path);</span>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :                                         //reset any sourceID given in the dst_arg and assign sourceID to be the dasher filter
<span class="lineNum">     801 </span><span class="lineCov">          2 :                                         gf_filter_reset_source(ctx-&gt;alt_dst);</span>
<span class="lineNum">     802 </span><span class="lineCov">          2 :                                         snprintf(szSRC, 100, &quot;MuxSrc%cdasher_%p&quot;, gf_filter_get_sep(filter, GF_FS_SEP_NAME), ctx-&gt;alt_dst);</span>
<span class="lineNum">     803 </span><span class="lineCov">          2 :                                         gf_filter_set_source(ctx-&gt;alt_dst, filter, szSRC);</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineCov">          2 :                                         ctx-&gt;opid_alt = gf_filter_pid_new(filter);</span>
<span class="lineNum">     806 </span><span class="lineCov">          2 :                                         gf_filter_pid_set_name(ctx-&gt;opid_alt, &quot;MANIFEST_ALT&quot;);</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineCov">          2 :                                         snprintf(szSRC, 100, &quot;dasher_%p&quot;, ctx-&gt;alt_dst);</span>
<span class="lineNum">     809 </span><span class="lineCov">          2 :                                         gf_filter_pid_set_property(ctx-&gt;opid_alt, GF_PROP_PID_MUX_SRC, &amp;PROP_STRING(szSRC) );</span>
<span class="lineNum">     810 </span>            :                                         //we also need to set the property on main output just to avoid the connection
<span class="lineNum">     811 </span>            :                                         snprintf(szSRC, 100, &quot;dasher_%p&quot;, ctx);
<span class="lineNum">     812 </span><span class="lineCov">          2 :                                         gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_MUX_SRC, &amp;PROP_STRING(szSRC) );</span>
<span class="lineNum">     813 </span>            :                                 }
<span class="lineNum">     814 </span><span class="lineCov">          2 :                                 opid = ctx-&gt;opid_alt;</span>
<span class="lineNum">     815 </span>            :                         }
<span class="lineNum">     816 </span><span class="lineCov">        246 :                         if (!opid)</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :                         //copy properties at init or reconfig
<span class="lineNum">     820 </span><span class="lineCov">        246 :                         gf_filter_pid_copy_properties(opid, pid);</span>
<span class="lineNum">     821 </span><span class="lineCov">        246 :                         gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, NULL);</span>
<span class="lineNum">     822 </span><span class="lineCov">        246 :                         gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, NULL);</span>
<span class="lineNum">     823 </span><span class="lineCov">        246 :                         gf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, NULL);</span>
<span class="lineNum">     824 </span><span class="lineCov">        246 :                         gf_filter_pid_set_property(opid, GF_PROP_PID_UNFRAMED, NULL);</span>
<span class="lineNum">     825 </span><span class="lineCov">        246 :                         gf_filter_pid_set_property(opid, GF_PROP_PID_STREAM_TYPE, &amp;PROP_UINT(GF_STREAM_FILE) );</span>
<span class="lineNum">     826 </span>            :                         //for routeout
<span class="lineNum">     827 </span><span class="lineCov">        246 :                         gf_filter_pid_set_property(opid, GF_PROP_PID_ORIG_STREAM_TYPE, &amp;PROP_UINT(GF_STREAM_FILE) );</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineCov">        246 :                         dasher_check_outpath(ctx);</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineCov">        246 :                         p = gf_filter_pid_caps_query(pid, GF_PROP_PID_FILE_EXT);</span>
<span class="lineNum">     832 </span><span class="lineCov">        246 :                         if (p) {</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :                                 gf_filter_pid_set_property(opid, GF_PROP_PID_FILE_EXT, p );</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                                 segext = p-&gt;value.string;</span>
<span class="lineNum">     835 </span>            :                         } else {
<span class="lineNum">     836 </span>            :                                 segext = NULL;
<span class="lineNum">     837 </span><span class="lineCov">        246 :                                 if (ctx-&gt;out_path) {</span>
<span class="lineNum">     838 </span><span class="lineCov">        242 :                                         segext = gf_file_ext_start(ctx-&gt;out_path);</span>
<span class="lineNum">     839 </span><span class="lineCov">          4 :                                 } else if (ctx-&gt;mname) {</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :                                         segext = gf_file_ext_start(ctx-&gt;mname);</span>
<span class="lineNum">     841 </span>            :                                 }
<span class="lineNum">     842 </span><span class="lineCov">        242 :                                 if (!segext) segext = &quot;mpd&quot;;</span>
<span class="lineNum">     843 </span><span class="lineCov">        242 :                                 else segext++;</span>
<span class="lineNum">     844 </span><span class="lineCov">        246 :                                 if (force_ext)</span>
<span class="lineNum">     845 </span>            :                                         segext = force_ext;
<span class="lineNum">     846 </span><span class="lineCov">        246 :                                 gf_filter_pid_set_property(opid, GF_PROP_PID_FILE_EXT, &amp;PROP_STRING(segext) );</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineCov">        246 :                                 if (!strcmp(segext, &quot;m3u8&quot;)) {</span>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineCov">         24 :                                         gf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &amp;PROP_STRING(&quot;video/mpegurl&quot;));</span>
<span class="lineNum">     851 </span>            :                                 } else {
<span class="lineNum">     852 </span><span class="lineCov">        222 :                                         gf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &amp;PROP_STRING(&quot;application/dash+xml&quot;));</span>
<span class="lineNum">     853 </span>            :                                 }
<span class="lineNum">     854 </span>            :                         }
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span><span class="lineCov">        246 :                         if (!strcmp(segext, &quot;m3u8&quot;)) {</span>
<span class="lineNum">     857 </span><span class="lineCov">         24 :                                 ctx-&gt;do_m3u8 = GF_TRUE;</span>
<span class="lineNum">     858 </span><span class="lineCov">         24 :                                 gf_filter_pid_set_name(opid, &quot;manifest_m3u8&quot; );</span>
<span class="lineNum">     859 </span>            :                         } else {
<span class="lineNum">     860 </span><span class="lineCov">        222 :                                 ctx-&gt;do_mpd = GF_TRUE;</span>
<span class="lineNum">     861 </span><span class="lineCov">        222 :                                 gf_filter_pid_set_name(opid, &quot;manifest_mpd&quot; );</span>
<span class="lineNum">     862 </span>            :                         }
<span class="lineNum">     863 </span>            :                 }
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineCov">        244 :                 ctx-&gt;store_seg_states = GF_FALSE;</span>
<span class="lineNum">     866 </span>            :                 //in m3u8 mode, always store all seg states. In MPD only if state, not ondemand
<span class="lineNum">     867 </span><span class="lineCov">        244 :                 if (((ctx-&gt;state || ctx-&gt;purge_segments) &amp;&amp; !ctx-&gt;sseg) || ctx-&gt;do_m3u8) ctx-&gt;store_seg_states = GF_TRUE;</span>
<span class="lineNum">     868 </span>            :         }
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineCov">        577 :         ds = gf_filter_pid_get_udta(pid);</span>
<span class="lineNum">     871 </span><span class="lineCov">        577 :         if (!ds) {</span>
<span class="lineNum">     872 </span><span class="lineCov">        357 :                 GF_SAFEALLOC(ds, GF_DashStream);</span>
<span class="lineNum">     873 </span><span class="lineCov">        357 :                 if (!ds) return GF_OUT_OF_MEM;</span>
<span class="lineNum">     874 </span><span class="lineCov">        357 :                 ds-&gt;ipid = pid;</span>
<span class="lineNum">     875 </span><span class="lineCov">        357 :                 gf_list_add(ctx-&gt;pids, ds);</span>
<span class="lineNum">     876 </span><span class="lineCov">        357 :                 ds-&gt;complementary_streams = gf_list_new();</span>
<span class="lineNum">     877 </span>            :                 period_switch = GF_TRUE;
<span class="lineNum">     878 </span><span class="lineCov">        357 :                 gf_filter_pid_set_udta(pid, ds);</span>
<span class="lineNum">     879 </span><span class="lineCov">        357 :                 ds-&gt;sbound = ctx-&gt;sbound;</span>
<span class="lineNum">     880 </span><span class="lineCov">        357 :                 if (ctx-&gt;sbound!=DASHER_BOUNDS_OUT)</span>
<span class="lineNum">     881 </span><span class="lineCov">          6 :                         ds-&gt;packet_queue = gf_list_new();</span>
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            :                 /*initial connection and we already have sent play event, send a PLAY on this new PID
<span class="lineNum">     884 </span>            :                 TODO: we need to send STOP/PLAY depending on period
<span class="lineNum">     885 </span>            :                 */
<span class="lineNum">     886 </span><span class="lineCov">        357 :                 if (ctx-&gt;is_playing) {</span>
<span class="lineNum">     887 </span>            :                         GF_FilterEvent evt;
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineCov">          2 :                         dasher_send_encode_hints(ctx, ds);</span>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span><span class="lineCov">          2 :                         GF_FEVT_INIT(evt, GF_FEVT_PLAY, ds-&gt;ipid);</span>
<span class="lineNum">     892 </span><span class="lineCov">          2 :                         evt.play.speed = 1.0;</span>
<span class="lineNum">     893 </span><span class="lineCov">          2 :                         gf_filter_pid_send_event(ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">     894 </span>            :                 }
<span class="lineNum">     895 </span>            :                 //don't create pid at this time
<span class="lineNum">     896 </span>            :         }
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineCov">        577 :         gf_filter_pid_set_framing_mode(pid, GF_TRUE);</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            : #define CHECK_PROP(_type, _mem, _e) \
<span class="lineNum">     901 </span>            :         p = gf_filter_pid_get_property(pid, _type); \
<span class="lineNum">     902 </span>            :         if (!p &amp;&amp; (_e&lt;=0) ) return _e; \
<span class="lineNum">     903 </span>            :         if (p &amp;&amp; (p-&gt;value.uint != _mem) &amp;&amp; _mem) period_switch = GF_TRUE; \
<span class="lineNum">     904 </span>            :         if (p) _mem = p-&gt;value.uint; \
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            : #define CHECK_PROPL(_type, _mem, _e) \
<span class="lineNum">     907 </span>            :         p = gf_filter_pid_get_property(pid, _type); \
<span class="lineNum">     908 </span>            :         if (!p &amp;&amp; (_e&lt;=0) ) return _e; \
<span class="lineNum">     909 </span>            :         if (p &amp;&amp; (p-&gt;value.longuint != _mem) &amp;&amp; _mem) period_switch = GF_TRUE; \
<span class="lineNum">     910 </span>            :         if (p) _mem = p-&gt;value.longuint; \
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            : #define CHECK_PROP_BOOL(_type, _mem, _e) \
<span class="lineNum">     913 </span>            :         p = gf_filter_pid_get_property(pid, _type); \
<span class="lineNum">     914 </span>            :         if (!p &amp;&amp; (_e&lt;=0) ) return _e; \
<span class="lineNum">     915 </span>            :         if (p &amp;&amp; (p-&gt;value.boolean != _mem) &amp;&amp; _mem) period_switch = GF_TRUE; \
<span class="lineNum">     916 </span>            :         if (p) _mem = p-&gt;value.uint; \
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            : #define CHECK_PROP_FRAC(_type, _mem, _e) \
<span class="lineNum">     919 </span>            :         p = gf_filter_pid_get_property(pid, _type); \
<span class="lineNum">     920 </span>            :         if (!p &amp;&amp; (_e&lt;=0) ) return _e; \
<span class="lineNum">     921 </span>            :         if (p &amp;&amp; (p-&gt;value.frac.num * _mem.den != p-&gt;value.frac.den * _mem.num) &amp;&amp; _mem.den &amp;&amp; _mem.num) period_switch = GF_TRUE; \
<span class="lineNum">     922 </span>            :         if (p) _mem = p-&gt;value.frac; \
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            : #define CHECK_PROP_FRAC64(_type, _mem, _e) \
<span class="lineNum">     925 </span>            :         p = gf_filter_pid_get_property(pid, _type); \
<span class="lineNum">     926 </span>            :         if (!p &amp;&amp; (_e&lt;=0) ) return _e; \
<span class="lineNum">     927 </span>            :         if (p &amp;&amp; (p-&gt;value.lfrac.num * _mem.den != p-&gt;value.lfrac.den * _mem.num) &amp;&amp; _mem.den &amp;&amp; _mem.num) period_switch = GF_TRUE; \
<span class="lineNum">     928 </span>            :         if (p) _mem = p-&gt;value.lfrac; \
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            : #define CHECK_PROP_STR(_type, _mem, _e) \
<span class="lineNum">     932 </span>            :         p = gf_filter_pid_get_property(pid, _type); \
<span class="lineNum">     933 </span>            :         if (!p &amp;&amp; (_e&lt;=0) ) return _e; \
<span class="lineNum">     934 </span>            :         if (p &amp;&amp; _mem &amp;&amp; strcmp(_mem, p-&gt;value.string)) period_switch = GF_TRUE; \
<span class="lineNum">     935 </span>            :         if (p) { \
<span class="lineNum">     936 </span>            :                 if (_mem) gf_free(_mem); \
<span class="lineNum">     937 </span>            :                 _mem = gf_strdup(p-&gt;value.string); \
<span class="lineNum">     938 </span>            :         }\
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            : #define CHECK_PROP_PROP(_type, _mem, _e) \
<span class="lineNum">     942 </span>            :         p = gf_filter_pid_get_property(pid, _type); \
<span class="lineNum">     943 </span>            :         if (!p &amp;&amp; (_e&lt;=0) ) return _e; \
<span class="lineNum">     944 </span>            :         if (p != _mem) period_switch = GF_TRUE; \
<span class="lineNum">     945 </span>            :         _mem = p; \
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineCov">        577 :         prev_stream_type = ds-&gt;stream_type;</span>
<span class="lineNum">     949 </span><span class="lineCov">        577 :         CHECK_PROP(GF_PROP_PID_STREAM_TYPE, ds-&gt;stream_type, GF_NOT_SUPPORTED)</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineCov">        577 :         ds-&gt;tile_base = GF_FALSE;</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span><span class="lineCov">        577 :         if (ds-&gt;stream_type != GF_STREAM_FILE) {</span>
<span class="lineNum">     954 </span><span class="lineCov">        576 :                 u32 prev_bitrate = ds-&gt;bitrate;</span>
<span class="lineNum">     955 </span><span class="lineCov">        576 :                 if (ds-&gt;stream_type==GF_STREAM_ENCRYPTED) {</span>
<span class="lineNum">     956 </span><span class="lineCov">        310 :                         CHECK_PROP(GF_PROP_PID_ORIG_STREAM_TYPE, ds-&gt;stream_type, GF_EOS)</span>
<span class="lineNum">     957 </span><span class="lineCov">        310 :                         ds-&gt;is_encrypted = GF_TRUE;</span>
<span class="lineNum">     958 </span>            :                 }
<span class="lineNum">     959 </span><span class="lineCov">        576 :                 if (prev_stream_type==ds-&gt;stream_type)</span>
<span class="lineNum">     960 </span>            :                         period_switch = GF_FALSE;
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineCov">        576 :                 CHECK_PROP(GF_PROP_PID_BITRATE, ds-&gt;bitrate, GF_EOS)</span>
<span class="lineNum">     963 </span><span class="lineCov">        576 :                 if (!ds-&gt;bitrate &amp;&amp; prev_bitrate) {</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                         ds-&gt;bitrate = prev_bitrate;</span>
<span class="lineNum">     965 </span>            :                         period_switch = GF_FALSE;
<span class="lineNum">     966 </span>            :                 }
<span class="lineNum">     967 </span><span class="lineCov">        576 :                 if (ds-&gt;bitrate &amp;&amp; period_switch) {</span>
<span class="lineNum">     968 </span>            :                         //allow 20% variation in bitrate, otherwise force period switch
<span class="lineNum">     969 </span><span class="lineCov">        298 :                         if ((ds-&gt;bitrate &lt;= 120 * prev_bitrate / 100) &amp;&amp; (ds-&gt;bitrate &gt;= 80 * prev_bitrate / 100)) {</span>
<span class="lineNum">     970 </span>            :                                 period_switch = GF_FALSE;
<span class="lineNum">     971 </span>            :                         }
<span class="lineNum">     972 </span>            :                 }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineCov">        576 :                 CHECK_PROP(GF_PROP_PID_CODECID, ds-&gt;codec_id, GF_NOT_SUPPORTED)</span>
<span class="lineNum">     975 </span><span class="lineCov">        576 :                 CHECK_PROP(GF_PROP_PID_TIMESCALE, ds-&gt;timescale, GF_NOT_SUPPORTED)</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">        576 :                 if (ds-&gt;stream_type==GF_STREAM_VISUAL) {</span>
<span class="lineNum">     978 </span><span class="lineCov">        439 :                         CHECK_PROP(GF_PROP_PID_WIDTH, ds-&gt;width, GF_EOS)</span>
<span class="lineNum">     979 </span><span class="lineCov">        439 :                         CHECK_PROP(GF_PROP_PID_HEIGHT, ds-&gt;height, GF_EOS)</span>
<span class="lineNum">     980 </span>            :                         //don't return if not defined
<span class="lineNum">     981 </span><span class="lineCov">        439 :                         CHECK_PROP_FRAC(GF_PROP_PID_SAR, ds-&gt;sar, GF_EOS)</span>
<span class="lineNum">     982 </span><span class="lineCov">        439 :                         if (!ds-&gt;sar.num) ds-&gt;sar.num = ds-&gt;sar.den = 1;</span>
<span class="lineNum">     983 </span><span class="lineCov">        439 :                         CHECK_PROP_FRAC(GF_PROP_PID_FPS, ds-&gt;fps, GF_EOS)</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineCov">        439 :                         p = gf_filter_pid_get_property(pid, GF_PROP_PID_CROP_POS);</span>
<span class="lineNum">     987 </span><span class="lineCov">        439 :                         if (p &amp;&amp; ((p-&gt;value.vec2i.x != ds-&gt;srd.x) || (p-&gt;value.vec2i.y != ds-&gt;srd.y) ) ) period_switch = GF_TRUE;</span>
<span class="lineNum">     988 </span><span class="lineCov">        439 :                         if (p) {</span>
<span class="lineNum">     989 </span><span class="lineCov">         36 :                                 ds-&gt;srd.x = p-&gt;value.vec2i.x;</span>
<span class="lineNum">     990 </span><span class="lineCov">         36 :                                 ds-&gt;srd.y = p-&gt;value.vec2i.y;</span>
<span class="lineNum">     991 </span><span class="lineCov">         36 :                                 ds-&gt;srd.z = ds-&gt;width;</span>
<span class="lineNum">     992 </span><span class="lineCov">         36 :                                 ds-&gt;srd.w = ds-&gt;height;</span>
<span class="lineNum">     993 </span>            :                         } else {
<span class="lineNum">     994 </span><span class="lineCov">        403 :                                 p = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);</span>
<span class="lineNum">     995 </span><span class="lineCov">        403 :                                 if (p) {</span>
<span class="lineNum">     996 </span><span class="lineCov">          4 :                                         ds-&gt;srd.x = ds-&gt;srd.y = 0;</span>
<span class="lineNum">     997 </span><span class="lineCov">          4 :                                         ds-&gt;srd.z = ds-&gt;width;</span>
<span class="lineNum">     998 </span><span class="lineCov">          4 :                                         ds-&gt;srd.w = ds-&gt;height;</span>
<span class="lineNum">     999 </span><span class="lineCov">          4 :                                         ds-&gt;tile_base = GF_TRUE;</span>
<span class="lineNum">    1000 </span>            :                                 }
<span class="lineNum">    1001 </span>            :                         }
<span class="lineNum">    1002 </span><span class="lineCov">        137 :                 } else if (ds-&gt;stream_type==GF_STREAM_AUDIO) {</span>
<span class="lineNum">    1003 </span><span class="lineCov">        135 :                         CHECK_PROP(GF_PROP_PID_SAMPLE_RATE, ds-&gt;sr, GF_EOS)</span>
<span class="lineNum">    1004 </span><span class="lineCov">        135 :                         CHECK_PROP(GF_PROP_PID_NUM_CHANNELS, ds-&gt;nb_ch, GF_EOS)</span>
<span class="lineNum">    1005 </span><span class="lineCov">        135 :                         CHECK_PROPL(GF_PROP_PID_CHANNEL_LAYOUT, ds-&gt;ch_layout, GF_EOS)</span>
<span class="lineNum">    1006 </span>            :                 }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :                 old_period_switch = period_switch;
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :                 //these ones can change without triggering period switch
<span class="lineNum">    1011 </span><span class="lineCov">        576 :                 CHECK_PROP(GF_PROP_PID_NB_FRAMES, ds-&gt;nb_samples_in_source, GF_EOS)</span>
<span class="lineNum">    1012 </span><span class="lineCov">        576 :                 CHECK_PROP_FRAC64(GF_PROP_PID_DURATION, ds-&gt;duration, GF_EOS)</span>
<span class="lineNum">    1013 </span><span class="lineCov">        576 :                 CHECK_PROP_STR(GF_PROP_PID_URL, ds-&gt;src_url, GF_EOS)</span>
<span class="lineNum">    1014 </span>            :                 period_switch = old_period_switch;
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineCov">        576 :                 CHECK_PROP(GF_PROP_PID_ID, ds-&gt;id, GF_EOS)</span>
<span class="lineNum">    1017 </span><span class="lineCov">        576 :                 CHECK_PROP(GF_PROP_PID_DEPENDENCY_ID, ds-&gt;dep_id, GF_EOS)</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineCov">        576 :                 p = gf_filter_pid_get_property(pid, GF_PROP_PID_HAS_SYNC);</span>
<span class="lineNum">    1020 </span>            :                 u32 sync_type = DASHER_SYNC_UNKNOWN;
<span class="lineNum">    1021 </span><span class="lineCov">        576 :                 if (p) sync_type = p-&gt;value.boolean ? DASHER_SYNC_PRESENT : DASHER_SYNC_NONE;</span>
<span class="lineNum">    1022 </span><span class="lineCov">        576 :                 if (sync_type != ds-&gt;sync_points_type) period_switch = GF_TRUE;</span>
<span class="lineNum">    1023 </span><span class="lineCov">        576 :                 ds-&gt;sync_points_type = sync_type;</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span><span class="lineCov">        576 :                 if (ds-&gt;inband_cues)</span>
<span class="lineNum">    1026 </span>            :                         period_switch = old_period_switch;
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span><span class="lineCov">        576 :                 if (ctx-&gt;scope_deps) {</span>
<span class="lineNum">    1029 </span><span class="lineCov">        576 :                         const char *src_args = gf_filter_pid_orig_src_args(pid, GF_TRUE);</span>
<span class="lineNum">    1030 </span><span class="lineCov">        576 :                         if (src_args) {</span>
<span class="lineNum">    1031 </span><span class="lineCov">        576 :                                 ds-&gt;src_id = gf_crc_32(src_args, (u32) strlen(src_args));</span>
<span class="lineNum">    1032 </span>            :                         }
<span class="lineNum">    1033 </span>            :                 }
<span class="lineNum">    1034 </span>            :                 dc_crc = 0;
<span class="lineNum">    1035 </span><span class="lineCov">        576 :                 dsi = p = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);</span>
<span class="lineNum">    1036 </span><span class="lineCov">        576 :                 if (p &amp;&amp; (p-&gt;type==GF_PROP_DATA))</span>
<span class="lineNum">    1037 </span><span class="lineCov">        526 :                         dc_crc = gf_crc_32(p-&gt;value.data.ptr, p-&gt;value.data.size);</span>
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            :                 dc_enh_crc = 0;
<span class="lineNum">    1040 </span><span class="lineCov">        576 :                 p = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);</span>
<span class="lineNum">    1041 </span><span class="lineCov">        576 :                 if (p &amp;&amp; (p-&gt;type==GF_PROP_DATA)) dc_enh_crc = gf_crc_32(p-&gt;value.data.ptr, p-&gt;value.data.size);</span>
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span><span class="lineCov">        576 :                 if (((dc_crc != ds-&gt;dsi_crc) &amp;&amp; ds-&gt;dsi_crc)</span>
<span class="lineNum">    1044 </span><span class="lineCov">        569 :                         || ((dc_enh_crc != ds-&gt;dsi_enh_crc) &amp;&amp; ds-&gt;dsi_enh_crc)</span>
<span class="lineNum">    1045 </span>            :                 ) {
<span class="lineNum">    1046 </span>            :                         //check which codecs can support inband param sets
<span class="lineNum">    1047 </span><span class="lineCov">         11 :                         switch (ds-&gt;codec_id) {</span>
<span class="lineNum">    1048 </span><span class="lineCov">         11 :                         case GF_CODECID_AVC:</span>
<span class="lineNum">    1049 </span>            :                         case GF_CODECID_SVC:
<span class="lineNum">    1050 </span>            :                         case GF_CODECID_MVC:
<span class="lineNum">    1051 </span>            :                         case GF_CODECID_HEVC:
<span class="lineNum">    1052 </span>            :                         case GF_CODECID_LHVC:
<span class="lineNum">    1053 </span><span class="lineCov">         11 :                                 if (!ctx-&gt;bs_switch)</span>
<span class="lineNum">    1054 </span>            :                                         period_switch = GF_TRUE;
<span class="lineNum">    1055 </span>            :                                 break;
<span class="lineNum">    1056 </span>            :                         default:
<span class="lineNum">    1057 </span>            :                                 period_switch = GF_TRUE;
<span class="lineNum">    1058 </span>            :                                 break;
<span class="lineNum">    1059 </span>            :                         }
<span class="lineNum">    1060 </span><span class="lineCov">        565 :                 }</span>
<span class="lineNum">    1061 </span>            :                 //check if input is ready
<span class="lineNum">    1062 </span><span class="lineCov">        576 :                 ds-&gt;dcd_not_ready = 0;</span>
<span class="lineNum">    1063 </span><span class="lineCov">        576 :                 if (!dc_crc &amp;&amp; !dc_enh_crc) {</span>
<span class="lineNum">    1064 </span><span class="lineCov">         48 :                         switch (ds-&gt;codec_id) {</span>
<span class="lineNum">    1065 </span><span class="lineCov">         15 :                         case GF_CODECID_AVC:</span>
<span class="lineNum">    1066 </span>            :                         case GF_CODECID_SVC:
<span class="lineNum">    1067 </span>            :                         case GF_CODECID_MVC:
<span class="lineNum">    1068 </span>            :                         case GF_CODECID_HEVC:
<span class="lineNum">    1069 </span>            :                         case GF_CODECID_LHVC:
<span class="lineNum">    1070 </span>            :                         case GF_CODECID_AAC_MPEG4:
<span class="lineNum">    1071 </span>            :                         case GF_CODECID_AAC_MPEG2_MP:
<span class="lineNum">    1072 </span>            :                         case GF_CODECID_AAC_MPEG2_LCP:
<span class="lineNum">    1073 </span>            :                         case GF_CODECID_AAC_MPEG2_SSRP:
<span class="lineNum">    1074 </span>            :                         case GF_CODECID_USAC:
<span class="lineNum">    1075 </span>            :                         case GF_CODECID_AC3:
<span class="lineNum">    1076 </span>            :                         case GF_CODECID_EAC3:
<span class="lineNum">    1077 </span>            :                         case GF_CODECID_AV1:
<span class="lineNum">    1078 </span>            :                         case GF_CODECID_VP8:
<span class="lineNum">    1079 </span>            :                         case GF_CODECID_VP9:
<span class="lineNum">    1080 </span><span class="lineCov">         15 :                                 ds-&gt;dcd_not_ready = gf_sys_clock();</span>
<span class="lineNum">    1081 </span><span class="lineCov">         15 :                                 break;</span>
<span class="lineNum">    1082 </span>            :                         default:
<span class="lineNum">    1083 </span>            :                                 break;
<span class="lineNum">    1084 </span>            :                         }
<span class="lineNum">    1085 </span><span class="lineCov">        528 :                 }</span>
<span class="lineNum">    1086 </span><span class="lineCov">        576 :                 ds-&gt;dsi_crc = dc_crc;</span>
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span><span class="lineCov">        576 :                 CHECK_PROP_STR(GF_PROP_PID_TEMPLATE, ds-&gt;template, GF_EOS)</span>
<span class="lineNum">    1089 </span><span class="lineCov">        576 :                 CHECK_PROP_STR(GF_PROP_PID_LANGUAGE, ds-&gt;lang, GF_EOS)</span>
<span class="lineNum">    1090 </span><span class="lineCov">        576 :                 CHECK_PROP_BOOL(GF_PROP_PID_INTERLACED, ds-&gt;interlaced, GF_EOS)</span>
<span class="lineNum">    1091 </span><span class="lineCov">        576 :                 CHECK_PROP_PROP(GF_PROP_PID_AS_COND_DESC, ds-&gt;p_as_desc, GF_EOS)</span>
<span class="lineNum">    1092 </span><span class="lineCov">        576 :                 CHECK_PROP_PROP(GF_PROP_PID_AS_ANY_DESC, ds-&gt;p_as_any_desc, GF_EOS)</span>
<span class="lineNum">    1093 </span><span class="lineCov">        576 :                 CHECK_PROP_PROP(GF_PROP_PID_REP_DESC, ds-&gt;p_rep_desc, GF_EOS)</span>
<span class="lineNum">    1094 </span><span class="lineCov">        576 :                 CHECK_PROP_PROP(GF_PROP_PID_BASE_URL, ds-&gt;p_base_url, GF_EOS)</span>
<span class="lineNum">    1095 </span><span class="lineCov">        576 :                 CHECK_PROP_PROP(GF_PROP_PID_ROLE, ds-&gt;p_role, GF_EOS)</span>
<span class="lineNum">    1096 </span><span class="lineCov">        576 :                 CHECK_PROP_STR(GF_PROP_PID_HLS_PLAYLIST, ds-&gt;hls_vp_name, GF_EOS)</span>
<span class="lineNum">    1097 </span><span class="lineCov">        576 :                 CHECK_PROP_BOOL(GF_PROP_PID_SINGLE_SCALE, ds-&gt;sscale, GF_EOS)</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span><span class="lineCov">        576 :                 if (ds-&gt;rate_first_dts_plus_one)</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                         dasher_update_bitrate(ctx, ds);</span>
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineCov">        576 :                 if (!ds-&gt;bitrate) {</span>
<span class="lineNum">    1104 </span><span class="lineCov">         65 :                         char *tpl = ds-&gt;template ? ds-&gt;template : ctx-&gt;template;</span>
<span class="lineNum">    1105 </span><span class="lineCov">         65 :                         if (tpl &amp;&amp; strstr(tpl, &quot;$Bandwidth$&quot;)) {</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] No bitrate property assigned to PID %s but template uses $Bandwidth$, cannot initialize !\n\tTry specifying bitrate property after your source, e.g. -i source.raw:#Bitrate=VAL\n&quot;, gf_filter_pid_get_name(ds-&gt;ipid)));</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                                 ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                                 return GF_BAD_PARAM;</span>
<span class="lineNum">    1109 </span>            :                         } else {
<span class="lineNum">    1110 </span><span class="lineCov">         65 :                                 GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] No bitrate property assigned to PID %s, computing from bitstream\n&quot;, gf_filter_pid_get_name(ds-&gt;ipid)));</span>
<span class="lineNum">    1111 </span><span class="lineCov">         65 :                                 ds-&gt;dyn_bitrate = GF_TRUE;</span>
<span class="lineNum">    1112 </span><span class="lineCov">         65 :                                 ds-&gt;rate_first_dts_plus_one = 0;</span>
<span class="lineNum">    1113 </span><span class="lineCov">         65 :                                 ds-&gt;rate_media_size = 0;</span>
<span class="lineNum">    1114 </span>            :                         }
<span class="lineNum">    1115 </span>            :                 } else {
<span class="lineNum">    1116 </span><span class="lineCov">        511 :                         ds-&gt;dyn_bitrate = GF_FALSE;</span>
<span class="lineNum">    1117 </span>            :                 }
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineCov">        576 :                 if (!ds-&gt;src_url)</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                         ds-&gt;src_url = gf_strdup(&quot;file&quot;);</span>
<span class="lineNum">    1121 </span><span class="lineCov">        576 :                 ds-&gt;startNumber = 1;</span>
<span class="lineNum">    1122 </span><span class="lineCov">        576 :                 CHECK_PROP(GF_PROP_PID_START_NUMBER, ds-&gt;startNumber, GF_EOS)</span>
<span class="lineNum">    1123 </span><span class="lineCov">        576 :                 ds-&gt;dash_dur = ctx-&gt;segdur;</span>
<span class="lineNum">    1124 </span><span class="lineCov">        576 :                 ds-&gt;no_seg_dur = ctx-&gt;no_seg_dur;</span>
<span class="lineNum">    1125 </span><span class="lineCov">        576 :                 p = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_DUR);</span>
<span class="lineNum">    1126 </span><span class="lineCov">        576 :                 if (p) {</span>
<span class="lineNum">    1127 </span><span class="lineCov">         45 :                         ds-&gt;dash_dur = p-&gt;value.frac;</span>
<span class="lineNum">    1128 </span><span class="lineCov">         45 :                         ds-&gt;no_seg_dur = GF_FALSE;</span>
<span class="lineNum">    1129 </span><span class="lineCov">         45 :                         if (!ds-&gt;dash_dur.num || !ds-&gt;dash_dur.den) {</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :                                 ds-&gt;dash_dur.num = 1;</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                                 ds-&gt;dash_dur.den = 1;</span>
<span class="lineNum">    1132 </span>            :                         }
<span class="lineNum">    1133 </span>            :                 }
<span class="lineNum">    1134 </span>            :                 //this avoids very weird cases where (u64) (dash_dur*timescale) is 0. we limit the max segment duration to 1M sec, a bit more than 11.5 days
<span class="lineNum">    1135 </span><span class="lineCov">        576 :                 if ((u64) ds-&gt;dash_dur.num &gt; (u64)ds-&gt;dash_dur.den * 1000000) {</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :                         ds-&gt;dash_dur.num = 1000000;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                         ds-&gt;dash_dur.den = 1;</span>
<span class="lineNum">    1138 </span>            :                 }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineCov">        576 :                 ds-&gt;splitable = GF_FALSE;</span>
<span class="lineNum">    1141 </span><span class="lineCov">        576 :                 switch (ds-&gt;stream_type) {</span>
<span class="lineNum">    1142 </span><span class="lineCov">          2 :                 case GF_STREAM_TEXT:</span>
<span class="lineNum">    1143 </span>            :                 case GF_STREAM_METADATA:
<span class="lineNum">    1144 </span>            :                 case GF_STREAM_OD:
<span class="lineNum">    1145 </span>            :                 case GF_STREAM_SCENE:
<span class="lineNum">    1146 </span><span class="lineCov">          2 :                         ds-&gt;splitable = ctx-&gt;split;</span>
<span class="lineNum">    1147 </span><span class="lineCov">          2 :                         break;</span>
<span class="lineNum">    1148 </span>            :                 }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineCov">        576 :                 old_clamp_dur = ds-&gt;clamped_dur.num;</span>
<span class="lineNum">    1151 </span><span class="lineCov">        576 :                 ds-&gt;clamped_dur.num = 0;</span>
<span class="lineNum">    1152 </span><span class="lineCov">        576 :                 ds-&gt;clamped_dur.den = 1;</span>
<span class="lineNum">    1153 </span><span class="lineCov">        576 :                 p = gf_filter_pid_get_property(pid, GF_PROP_PID_CLAMP_DUR);</span>
<span class="lineNum">    1154 </span><span class="lineCov">        576 :                 if (p &amp;&amp; p-&gt;value.lfrac.den) ds-&gt;clamped_dur = p-&gt;value.lfrac;</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            :                 //HDR
<span class="lineNum">    1157 </span>            : #if !defined(GPAC_DISABLE_AV_PARSERS)
<span class="lineNum">    1158 </span><span class="lineCov">        576 :                 if (dsi) {</span>
<span class="lineNum">    1159 </span>            : #if !defined(GPAC_DISABLE_HEVC)
<span class="lineNum">    1160 </span><span class="lineCov">        526 :                         if (ds-&gt;codec_id == GF_CODECID_LHVC || ds-&gt;codec_id == GF_CODECID_HEVC_TILES || ds-&gt;codec_id == GF_CODECID_HEVC) {</span>
<span class="lineNum">    1161 </span><span class="lineCov">         86 :                                 GF_HEVCConfig* hevccfg = gf_odf_hevc_cfg_read(dsi-&gt;value.data.ptr, dsi-&gt;value.data.size, GF_FALSE);</span>
<span class="lineNum">    1162 </span><span class="lineCov">         86 :                                 if (hevccfg) {</span>
<span class="lineNum">    1163 </span>            :                                         Bool is_interlaced;
<span class="lineNum">    1164 </span>            :                                         HEVCState hevc;
<span class="lineNum">    1165 </span>            :                                         HEVC_SPS* sps;
<span class="lineNum">    1166 </span>            :                                         memset(&amp;hevc, 0, sizeof(HEVCState));
<span class="lineNum">    1167 </span><span class="lineCov">         86 :                                         gf_hevc_parse_ps(hevccfg, &amp;hevc, GF_HEVC_NALU_VID_PARAM);</span>
<span class="lineNum">    1168 </span><span class="lineCov">         86 :                                         gf_hevc_parse_ps(hevccfg, &amp;hevc, GF_HEVC_NALU_SEQ_PARAM);</span>
<span class="lineNum">    1169 </span><span class="lineCov">         86 :                                         sps = &amp;hevc.sps[hevc.sps_active_idx];</span>
<span class="lineNum">    1170 </span><span class="lineCov">         86 :                                         if (sps &amp;&amp; sps-&gt;colour_description_present_flag) {</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :                                                 DasherHDRType old_hdr_type = ds-&gt;hdr_type;</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :                                                 if (sps-&gt;colour_primaries == 9 &amp;&amp; sps-&gt;matrix_coeffs == 9) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :                                                         if (sps-&gt;transfer_characteristic == 14) ds-&gt;hdr_type = DASHER_HDR_HLG; //TODO: parse alternative_transfer_characteristics SEI</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                                                         if (sps-&gt;transfer_characteristic == 16) ds-&gt;hdr_type = DASHER_HDR_PQ10;</span>
<span class="lineNum">    1175 </span>            :                                                 }
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :                                                 if (old_hdr_type != ds-&gt;hdr_type) period_switch = GF_TRUE;</span>
<span class="lineNum">    1177 </span>            :                                         }
<span class="lineNum">    1178 </span><span class="lineCov">         86 :                                         is_interlaced = hevccfg-&gt;interlaced_source_flag ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    1179 </span><span class="lineCov">         86 :                                         if (ds-&gt;interlaced != is_interlaced) period_switch = GF_TRUE;</span>
<span class="lineNum">    1180 </span><span class="lineCov">         86 :                                         ds-&gt;interlaced = is_interlaced;</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span><span class="lineCov">         86 :                                         gf_odf_hevc_cfg_del(hevccfg);</span>
<span class="lineNum">    1183 </span>            :                                 }
<span class="lineNum">    1184 </span>            :                         }
<span class="lineNum">    1185 </span>            :                         else
<span class="lineNum">    1186 </span>            : #endif
<span class="lineNum">    1187 </span><span class="lineCov">        440 :                         if (ds-&gt;codec_id == GF_CODECID_AVC || ds-&gt;codec_id == GF_CODECID_SVC || ds-&gt;codec_id == GF_CODECID_MVC) {</span>
<span class="lineNum">    1188 </span>            :                                 AVCState avc;
<span class="lineNum">    1189 </span><span class="lineCov">        213 :                                 GF_AVCConfig* avccfg = gf_odf_avc_cfg_read(dsi-&gt;value.data.ptr, dsi-&gt;value.data.size);</span>
<span class="lineNum">    1190 </span><span class="lineCov">        213 :                                 GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(avccfg-&gt;sequenceParameterSets, 0);</span>
<span class="lineNum">    1191 </span><span class="lineCov">        213 :                                 if (sl) {</span>
<span class="lineNum">    1192 </span>            :                                         s32 idx;
<span class="lineNum">    1193 </span>            :                                         memset(&amp;avc, 0, sizeof(AVCState));
<span class="lineNum">    1194 </span><span class="lineCov">        211 :                                         idx = gf_avc_read_sps(sl-&gt;data, sl-&gt;size, &amp;avc, 0, NULL);</span>
<span class="lineNum">    1195 </span><span class="lineCov">        211 :                                         if (idx&gt;=0) {</span>
<span class="lineNum">    1196 </span><span class="lineCov">        211 :                                                 Bool is_interlaced = avc.sps[idx].frame_mbs_only_flag ? GF_FALSE : GF_TRUE;</span>
<span class="lineNum">    1197 </span><span class="lineCov">        211 :                                                 if (ds-&gt;interlaced != is_interlaced) period_switch = GF_TRUE;</span>
<span class="lineNum">    1198 </span><span class="lineCov">        211 :                                                 ds-&gt;interlaced = is_interlaced;</span>
<span class="lineNum">    1199 </span>            :                                         }
<span class="lineNum">    1200 </span>            :                                 }
<span class="lineNum">    1201 </span><span class="lineCov">        213 :                                 gf_odf_avc_cfg_del(avccfg);</span>
<span class="lineNum">    1202 </span>            :                         }
<span class="lineNum">    1203 </span>            :                 }
<span class="lineNum">    1204 </span>            : #endif /*!GPAC_DISABLE_AV_PARSERS*/
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span><span class="lineCov">        576 :                 if (ds-&gt;stream_type==GF_STREAM_AUDIO) {</span>
<span class="lineNum">    1207 </span><span class="lineCov">        135 :                         u32 _sr=0, _nb_ch=0;</span>
<span class="lineNum">    1208 </span>            : #ifndef GPAC_DISABLE_AV_PARSERS
<span class="lineNum">    1209 </span><span class="lineCov">        135 :                         switch (ds-&gt;codec_id) {</span>
<span class="lineNum">    1210 </span><span class="lineCov">        130 :                         case GF_CODECID_AAC_MPEG4:</span>
<span class="lineNum">    1211 </span>            :                         case GF_CODECID_AAC_MPEG2_MP:
<span class="lineNum">    1212 </span>            :                         case GF_CODECID_AAC_MPEG2_LCP:
<span class="lineNum">    1213 </span>            :                         case GF_CODECID_AAC_MPEG2_SSRP:
<span class="lineNum">    1214 </span>            :                         case GF_CODECID_USAC:
<span class="lineNum">    1215 </span>            :                                 //DASH-IF and MPEG disagree here:
<span class="lineNum">    1216 </span><span class="lineCov">        260 :                                 if ((ctx-&gt;profile == GF_DASH_PROFILE_AVC264_LIVE)</span>
<span class="lineNum">    1217 </span>            :                                         || (ctx-&gt;profile == GF_DASH_PROFILE_AVC264_ONDEMAND)
<span class="lineNum">    1218 </span><span class="lineCov">        130 :                                         || (ctx-&gt;profile == GF_DASH_PROFILE_DASHIF_LL)</span>
<span class="lineNum">    1219 </span>            :                                 ) {
<span class="lineNum">    1220 </span><span class="lineCov">          5 :                                         GF_Err res = dasher_get_audio_info_with_m4a_sbr_ps(ds, dsi, &amp;_sr, &amp;_nb_ch);</span>
<span class="lineNum">    1221 </span><span class="lineCov">          5 :                                         if (res) {</span>
<span class="lineNum">    1222 </span>            :                                                 //DASH-IF IOP 3.3 mandates the SBR/PS info
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Could not get AAC info, %s\n&quot;, gf_error_to_string(res)));</span>
<span class="lineNum">    1224 </span>            :                                         }
<span class="lineNum">    1225 </span><span class="lineCov">        125 :                                 } else if (dsi) {</span>
<span class="lineNum">    1226 </span><span class="lineCov">        121 :                                         dasher_get_audio_info_with_m4a_sbr_ps(ds, dsi, NULL, &amp;_nb_ch);</span>
<span class="lineNum">    1227 </span>            :                                 }
<span class="lineNum">    1228 </span>            :                                 break;
<span class="lineNum">    1229 </span><span class="lineCov">          1 :                         case GF_CODECID_AC3:</span>
<span class="lineNum">    1230 </span>            :                         case GF_CODECID_EAC3:
<span class="lineNum">    1231 </span><span class="lineCov">          1 :                                 if (dsi) {</span>
<span class="lineNum">    1232 </span>            :                                         u32 i;
<span class="lineNum">    1233 </span>            :                                         GF_AC3Config ac3;
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :                                         gf_odf_ac3_config_parse(dsi-&gt;value.data.ptr, dsi-&gt;value.data.size, (ds-&gt;codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &amp;ac3);</span>
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :                                         ds-&gt;nb_lfe = ac3.streams[0].lfon ? 1 : 0;</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :                                         _nb_ch = gf_ac3_get_channels(ac3.streams[0].acmod);</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                                         for (i=0; i&lt;ac3.streams[0].nb_dep_sub; ++i) {</span>
<span class="lineNum">    1239 </span>            :                                                 assert(ac3.streams[0].nb_dep_sub == 1);
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                                                 _nb_ch += gf_ac3_get_channels(ac3.streams[0].chan_loc);</span>
<span class="lineNum">    1241 </span>            :                                         }
<span class="lineNum">    1242 </span>            :                                 }
<span class="lineNum">    1243 </span>            :                                 break;
<span class="lineNum">    1244 </span>            :                         }
<span class="lineNum">    1245 </span>            : #endif
<span class="lineNum">    1246 </span><span class="lineCov">        135 :                         if (_sr &gt; ds-&gt;sr) ds-&gt;sr = _sr;</span>
<span class="lineNum">    1247 </span><span class="lineCov">        135 :                         if (_nb_ch &gt; ds-&gt;nb_ch) ds-&gt;nb_ch = _nb_ch;</span>
<span class="lineNum">    1248 </span>            :                 }
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span><span class="lineCov">        576 :                 ds-&gt;pts_minus_cts = 0;</span>
<span class="lineNum">    1252 </span><span class="lineCov">        576 :                 p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_DELAY);</span>
<span class="lineNum">    1253 </span><span class="lineCov">        576 :                 if (p &amp;&amp; p-&gt;value.longsint) {</span>
<span class="lineNum">    1254 </span><span class="lineCov">         78 :                         ds-&gt;pts_minus_cts = p-&gt;value.longsint;</span>
<span class="lineNum">    1255 </span>            :                 }
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            :                 //only reload queues if we detected a period switch
<span class="lineNum">    1258 </span><span class="lineCov">        576 :                 if (period_switch) {</span>
<span class="lineNum">    1259 </span><span class="lineCov">        361 :                         cue_file = ctx-&gt;cues;</span>
<span class="lineNum">    1260 </span><span class="lineCov">        361 :                         p = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_CUE);</span>
<span class="lineNum">    1261 </span><span class="lineCov">        361 :                         if (p) cue_file = p-&gt;value.string;</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span><span class="lineCov">        361 :                         if (ds-&gt;cues) gf_free(ds-&gt;cues);</span>
<span class="lineNum">    1264 </span><span class="lineCov">        361 :                         ds-&gt;cues = NULL;</span>
<span class="lineNum">    1265 </span><span class="lineCov">        361 :                         ds-&gt;nb_cues = 0;</span>
<span class="lineNum">    1266 </span><span class="lineCov">        361 :                         ds-&gt;inband_cues = GF_FALSE;</span>
<span class="lineNum">    1267 </span><span class="lineCov">        361 :                         if (cue_file) {</span>
<span class="lineNum">    1268 </span><span class="lineCov">         37 :                                 if (!strcmp(cue_file, &quot;inband&quot;)) {</span>
<span class="lineNum">    1269 </span><span class="lineCov">         27 :                                         ds-&gt;inband_cues = GF_TRUE;</span>
<span class="lineNum">    1270 </span><span class="lineCov">         27 :                                         p = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_FWD);</span>
<span class="lineNum">    1271 </span><span class="lineCov">         27 :                                         if (p &amp;&amp; p-&gt;value.uint)</span>
<span class="lineNum">    1272 </span><span class="lineCov">         27 :                                                 ctx-&gt;forward_mode = p-&gt;value.uint;</span>
<span class="lineNum">    1273 </span>            :                                 } else {
<span class="lineNum">    1274 </span><span class="lineCov">         10 :                                         e = gf_mpd_load_cues(cue_file, ds-&gt;id, &amp;ds-&gt;cues_timescale, &amp;ds-&gt;cues_use_edits, &amp;ds-&gt;cues_ts_offset, &amp;ds-&gt;cues, &amp;ds-&gt;nb_cues);</span>
<span class="lineNum">    1275 </span><span class="lineCov">         10 :                                         if (e) return e;</span>
<span class="lineNum">    1276 </span><span class="lineCov">         10 :                                         if (!ds-&gt;cues_timescale)</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :                                                 ds-&gt;cues_timescale = ds-&gt;timescale;</span>
<span class="lineNum">    1278 </span>            :                                 }
<span class="lineNum">    1279 </span>            :                         }
<span class="lineNum">    1280 </span>            :                 }
<span class="lineNum">    1281 </span>            :         } else {
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span><span class="lineCov">          1 :                 p = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);</span>
<span class="lineNum">    1284 </span><span class="lineCov">          1 :                 if (!p) p = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">    1285 </span><span class="lineCov">          1 :                 if (p) return GF_NOT_SUPPORTED;</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span><span class="lineCov">          1 :                 CHECK_PROP_STR(GF_PROP_PID_XLINK, ds-&gt;xlink, GF_EOS)</span>
<span class="lineNum">    1288 </span>            :         }
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            :         //stream representation was not yet setup but is scheduled for this period, do not trigger period switch
<span class="lineNum">    1291 </span>            :         //this typically happens when we post-poned representation setup waiting for the decoder config
<span class="lineNum">    1292 </span><span class="lineCov">        577 :         if (!ds-&gt;rep &amp;&amp; (gf_list_find(ctx-&gt;current_period-&gt;streams, ds)&gt;=0))</span>
<span class="lineNum">    1293 </span>            :                 period_switch = GF_FALSE;
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :         old_period_switch = period_switch;
<span class="lineNum">    1296 </span>            :         period_switch = GF_FALSE;
<span class="lineNum">    1297 </span><span class="lineCov">        577 :         CHECK_PROP_STR(GF_PROP_PID_PERIOD_ID, ds-&gt;period_id, GF_EOS)</span>
<span class="lineNum">    1298 </span><span class="lineCov">        577 :         CHECK_PROP_PROP(GF_PROP_PID_PERIOD_DESC, ds-&gt;p_period_desc, GF_EOS)</span>
<span class="lineNum">    1299 </span><span class="lineCov">        574 :         if (!period_switch &amp;&amp; ctx-&gt;pswitch)</span>
<span class="lineNum">    1300 </span>            :                 period_switch = GF_TRUE;
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span><span class="lineCov">        577 :         if (gf_filter_pid_get_property_str(pid, &quot;period_switch&quot;))</span>
<span class="lineNum">    1303 </span>            :                 period_switch = GF_TRUE;
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span><span class="lineCov">        577 :         p = gf_filter_pid_get_property(pid, GF_PROP_PID_PERIOD_START);</span>
<span class="lineNum">    1306 </span><span class="lineCov">        577 :         if (p) {</span>
<span class="lineNum">    1307 </span><span class="lineCov">          3 :                 if (ds-&gt;period_start.num * p-&gt;value.lfrac.den != p-&gt;value.lfrac.num * ds-&gt;period_start.den) period_switch = GF_TRUE;</span>
<span class="lineNum">    1308 </span><span class="lineCov">          3 :                 ds-&gt;period_start = p-&gt;value.lfrac;</span>
<span class="lineNum">    1309 </span>            :         } else {
<span class="lineNum">    1310 </span><span class="lineCov">        574 :                 if (ds-&gt;period_start.num) period_switch = GF_TRUE;</span>
<span class="lineNum">    1311 </span><span class="lineCov">        574 :                 ds-&gt;period_start.num = 0;</span>
<span class="lineNum">    1312 </span><span class="lineCov">        574 :                 ds-&gt;period_start.den = 1;</span>
<span class="lineNum">    1313 </span>            :         }
<span class="lineNum">    1314 </span>            :         assert(ds-&gt;period_start.den);
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineCov">        577 :         if (period_switch) {</span>
<span class="lineNum">    1317 </span>            :                 new_period_request = GF_TRUE;
<span class="lineNum">    1318 </span>            :         } else {
<span class="lineNum">    1319 </span>            :                 period_switch = old_period_switch;
<span class="lineNum">    1320 </span>            :         }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineCov">        577 :         if (ds-&gt;period_continuity_id) gf_free(ds-&gt;period_continuity_id);</span>
<span class="lineNum">    1323 </span><span class="lineCov">        577 :         ds-&gt;period_continuity_id = NULL;</span>
<span class="lineNum">    1324 </span><span class="lineCov">        577 :         p = gf_filter_pid_get_property_str(ds-&gt;ipid, &quot;period_resume&quot;);</span>
<span class="lineNum">    1325 </span><span class="lineCov">        577 :         if (!ctx-&gt;mpd || (gf_list_find(ctx-&gt;mpd-&gt;periods, ds-&gt;last_period)&lt;0))</span>
<span class="lineNum">    1326 </span><span class="lineCov">        567 :                 ds-&gt;last_period = NULL;</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span><span class="lineCov">        577 :         if (p &amp;&amp; p-&gt;value.string &amp;&amp; ds-&gt;last_period) {</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                 if (!ds-&gt;last_period-&gt;ID) {</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                         if (p-&gt;value.string[0]) {</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :                                 ds-&gt;last_period-&gt;ID = p-&gt;value.string;</span>
<span class="lineNum">    1332 </span>            :                         } else {
<span class="lineNum">    1333 </span>            :                                 char szPName[50];
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :                                 sprintf(szPName, &quot;P%d&quot;, 1 + gf_list_find(ctx-&gt;mpd-&gt;periods, ds-&gt;last_period));</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :                                 ds-&gt;last_period-&gt;ID = gf_strdup(szPName);</span>
<span class="lineNum">    1336 </span>            :                         }
<span class="lineNum">    1337 </span>            :                 }
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :                 if (ds-&gt;set &amp;&amp; (ds-&gt;set-&gt;id&lt;0)) {</span>
<span class="lineNum">    1339 </span>            :                         //period may be NULL (no longer scheduled)
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :                         if (!ds-&gt;as_id &amp;&amp; ds-&gt;period &amp;&amp; ds-&gt;period-&gt;period)</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :                                 ds-&gt;as_id = gf_list_find(ds-&gt;period-&gt;period-&gt;adaptation_sets, ds-&gt;set) + 1;</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :                         ds-&gt;set-&gt;id = ds-&gt;as_id;</span>
<span class="lineNum">    1343 </span>            :                 }
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :                 ds-&gt;period_continuity_id = gf_strdup(ds-&gt;last_period-&gt;ID);</span>
<span class="lineNum">    1345 </span>            :         }
<span class="lineNum">    1346 </span><span class="lineCov">        577 :         ds-&gt;last_period = NULL;</span>
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineCov">        577 :         ds-&gt;period_dur.num = 0;</span>
<span class="lineNum">    1349 </span><span class="lineCov">        577 :         ds-&gt;period_dur.den = 1;</span>
<span class="lineNum">    1350 </span><span class="lineCov">        577 :         p = gf_filter_pid_get_property(pid, GF_PROP_PID_PERIOD_DUR);</span>
<span class="lineNum">    1351 </span><span class="lineCov">        577 :         if (p) ds-&gt;period_dur = p-&gt;value.lfrac;</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span><span class="lineCov">        577 :         if (ds-&gt;stream_type==GF_STREAM_FILE) {</span>
<span class="lineNum">    1354 </span><span class="lineCov">          1 :                 if (!ds-&gt;xlink &amp;&amp; !ds-&gt;period_start.num &amp;&amp; !ds-&gt;period_dur.num) {</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :                         ds-&gt;done = 1;</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] null PID specified without any XLINK/start/duration, ignoring\n&quot;));</span>
<span class="lineNum">    1357 </span><span class="lineCov">          1 :                 } else if (ds-&gt;xlink) {</span>
<span class="lineNum">    1358 </span><span class="lineCov">          1 :                         ctx-&gt;use_xlink = GF_TRUE;</span>
<span class="lineNum">    1359 </span>            :                 }
<span class="lineNum">    1360 </span>            :         } else {
<span class="lineNum">    1361 </span><span class="lineCov">        576 :                 if (ds-&gt;xlink) gf_free(ds-&gt;xlink);</span>
<span class="lineNum">    1362 </span><span class="lineCov">        576 :                 ds-&gt;xlink = NULL;</span>
<span class="lineNum">    1363 </span><span class="lineCov">        576 :                 CHECK_PROP_STR(GF_PROP_PID_XLINK, ds-&gt;xlink, GF_EOS)</span>
<span class="lineNum">    1364 </span><span class="lineCov">        576 :                 if (ds-&gt;xlink)</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :                         ctx-&gt;use_xlink = GF_TRUE;</span>
<span class="lineNum">    1366 </span>            :         }
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            :         //input was done due to clamp but forced to new period, reschedule
<span class="lineNum">    1369 </span><span class="lineCov">        577 :         if (new_period_request &amp;&amp; ds-&gt;done &amp;&amp; old_clamp_dur) {</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :                 gf_list_del_item(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">    1371 </span>            :                 //reset discard, blocking mode on output (set by EOS) and reset dasher EOS state
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :                 gf_filter_pid_set_discard(ds-&gt;ipid, GF_FALSE);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :                 if (ds-&gt;opid) {</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :                         gf_filter_pid_discard_block(ds-&gt;opid);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :                         gf_filter_pid_remove(ds-&gt;opid);</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :                         ds-&gt;opid = NULL;</span>
<span class="lineNum">    1377 </span>            :                 }
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;is_eos) {</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :                         ctx-&gt;is_eos = GF_FALSE;</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :                         gf_filter_pid_discard_block(ctx-&gt;opid);</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :                         if (ctx-&gt;opid_alt)</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :                         gf_filter_pid_discard_block(ctx-&gt;opid_alt);</span>
<span class="lineNum">    1383 </span>            :                 }
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :                 ds-&gt;rep_init = GF_FALSE;</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :                 ds-&gt;rep = NULL;</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :                 ds-&gt;set = NULL;</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                 ds-&gt;period = NULL;</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :                 ds-&gt;done = 0;</span>
<span class="lineNum">    1389 </span>            : //              gf_filter_post_process_task(filter);
<span class="lineNum">    1390 </span>            : //              dasher_reset_stream(filter, ds, GF_FALSE);
<span class="lineNum">    1391 </span>            :         }
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span>            :         //our stream is already scheduled for next period, don't do anything
<span class="lineNum">    1394 </span><span class="lineCov">        577 :         if (gf_list_find(ctx-&gt;next_period-&gt;streams, ds)&gt;=0)</span>
<span class="lineNum">    1395 </span>            :                 period_switch = GF_FALSE;
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            :         //assign default ID
<span class="lineNum">    1398 </span><span class="lineCov">        577 :         if (!ds-&gt;period_id)</span>
<span class="lineNum">    1399 </span><span class="lineCov">        350 :                 ds-&gt;period_id = gf_strdup(DEFAULT_PERIOD_ID);</span>
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineCov">        577 :         e = dasher_hls_setup_crypto(ctx, ds);</span>
<span class="lineNum">    1402 </span><span class="lineCov">        577 :         if (e) return e;</span>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineCov">        577 :         if (!period_switch) {</span>
<span class="lineNum">    1405 </span><span class="lineCov">        220 :                 if (ds-&gt;opid) {</span>
<span class="lineNum">    1406 </span><span class="lineCov">        181 :                         gf_filter_pid_copy_properties(ds-&gt;opid, pid);</span>
<span class="lineNum">    1407 </span>            :                         //for route out
<span class="lineNum">    1408 </span><span class="lineCov">        181 :                         if (ctx-&gt;is_route &amp;&amp; ctx-&gt;do_m3u8)</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :                                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PCK_HLS_REF, &amp;PROP_LONGUINT( ds-&gt;hls_ref_id ) );</span>
<span class="lineNum">    1410 </span><span class="lineCov">        181 :                         if (ctx-&gt;llhls)</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_LLHLS, &amp;PROP_UINT(ctx-&gt;llhls) );</span>
<span class="lineNum">    1412 </span>            :                 }
<span class="lineNum">    1413 </span><span class="lineCov">        220 :                 if (ds-&gt;rep)</span>
<span class="lineNum">    1414 </span><span class="lineCov">        181 :                         dasher_update_rep(ctx, ds);</span>
<span class="lineNum">    1415 </span>            :                 return GF_OK;
<span class="lineNum">    1416 </span>            :         }
<span class="lineNum">    1417 </span>            :         //period switch !
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            :         //we have queued packets (sbound modes), we cannot switch period for this stream now, force queue flush
<span class="lineNum">    1420 </span><span class="lineCov">        357 :         if (gf_list_count(ds-&gt;packet_queue)) {</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :                 ds-&gt;request_period_switch = new_period_request ? 2 : 1;</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                 return GF_OK;</span>
<span class="lineNum">    1423 </span>            :         }
<span class="lineNum">    1424 </span>            :         //done for this stream
<span class="lineNum">    1425 </span><span class="lineCov">        357 :         return dasher_stream_period_changed(filter, ctx, ds, new_period_request);</span>
<span class="lineNum">    1426 </span>            : }
<a name="1427"><span class="lineNum">    1427 </span>            : </a>
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span><span class="lineCov">        876 : static GF_Err dasher_update_mpd(GF_DasherCtx *ctx)</span>
<span class="lineNum">    1430 </span>            : {
<span class="lineNum">    1431 </span>            :         char profiles_string[GF_MAX_PATH];
<span class="lineNum">    1432 </span>            :         GF_XMLAttribute *cenc_att = NULL;
<span class="lineNum">    1433 </span>            :         GF_XMLAttribute *xlink_att = NULL;
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span><span class="lineCov">        876 :         u32 i, count=gf_list_count(ctx-&gt;mpd-&gt;x_attributes);</span>
<span class="lineNum">    1436 </span><span class="lineCov">        921 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1437 </span><span class="lineCov">         45 :                 GF_XMLAttribute * att = gf_list_get(ctx-&gt;mpd-&gt;x_attributes, i);</span>
<span class="lineNum">    1438 </span><span class="lineCov">         45 :                 if (!strcmp(att-&gt;name, &quot;xmlns:cenc&quot;)) cenc_att = att;</span>
<span class="lineNum">    1439 </span><span class="lineCov">         45 :                 if (!strcmp(att-&gt;name, &quot;xmlns:xlink&quot;)) xlink_att = att;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :         }
<span class="lineNum">    1442 </span><span class="lineCov">        876 :         if (ctx-&gt;dmode==GF_MPD_TYPE_DYNAMIC) {</span>
<span class="lineNum">    1443 </span><span class="lineCov">        433 :                 ctx-&gt;mpd-&gt;type = GF_MPD_TYPE_DYNAMIC;</span>
<span class="lineNum">    1444 </span>            :         } else {
<span class="lineNum">    1445 </span><span class="lineCov">        443 :                 ctx-&gt;mpd-&gt;type = GF_MPD_TYPE_STATIC;</span>
<span class="lineNum">    1446 </span><span class="lineCov">        443 :                 ctx-&gt;mpd-&gt;availabilityStartTime = 0;</span>
<span class="lineNum">    1447 </span>            :         }
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span><span class="lineCov">        876 :         if (ctx-&gt;profile==GF_DASH_PROFILE_LIVE) {</span>
<span class="lineNum">    1450 </span><span class="lineCov">        328 :                 if (ctx-&gt;use_xlink &amp;&amp; !ctx-&gt;m2ts) {</span>
<span class="lineNum">    1451 </span>            :                         strcpy(profiles_string, &quot;urn:mpeg:dash:profile:isoff-segext-live:2014&quot;);
<span class="lineNum">    1452 </span>            :                 } else {
<span class="lineNum">    1453 </span><span class="lineCov">        324 :                         sprintf(profiles_string, &quot;urn:mpeg:dash:profile:%s:2011&quot;, ctx-&gt;m2ts ? &quot;mp2t-simple&quot; : &quot;isoff-live&quot;);</span>
<span class="lineNum">    1454 </span>            :                 }
<span class="lineNum">    1455 </span><span class="lineCov">        548 :         } else if (ctx-&gt;profile==GF_DASH_PROFILE_ONDEMAND) {</span>
<span class="lineNum">    1456 </span><span class="lineCov">         30 :                 if (ctx-&gt;use_xlink) {</span>
<span class="lineNum">    1457 </span>            :                         strcpy(profiles_string, &quot;urn:mpeg:dash:profile:isoff-segext-on-demand:2014&quot;);
<span class="lineNum">    1458 </span>            :                 } else {
<span class="lineNum">    1459 </span>            :                         strcpy(profiles_string, &quot;urn:mpeg:dash:profile:isoff-on-demand:2011&quot;);
<span class="lineNum">    1460 </span>            :                 }
<span class="lineNum">    1461 </span><span class="lineCov">        518 :         } else if (ctx-&gt;profile==GF_DASH_PROFILE_MAIN) {</span>
<span class="lineNum">    1462 </span><span class="lineCov">         22 :                 sprintf(profiles_string, &quot;urn:mpeg:dash:profile:%s:2011&quot;, ctx-&gt;m2ts ? &quot;mp2t-main&quot; : &quot;isoff-main&quot;);</span>
<span class="lineNum">    1463 </span><span class="lineCov">        496 :         } else if (ctx-&gt;profile==GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {</span>
<span class="lineNum">    1464 </span>            :                 strcpy(profiles_string, &quot;urn:hbbtv:dash:profile:isoff-live:2012&quot;);
<span class="lineNum">    1465 </span><span class="lineCov">        496 :         } else if (ctx-&gt;profile==GF_DASH_PROFILE_AVC264_LIVE) {</span>
<span class="lineNum">    1466 </span>            :                 strcpy(profiles_string, &quot;urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash264&quot;);
<span class="lineNum">    1467 </span><span class="lineCov">        490 :         } else if (ctx-&gt;profile==GF_DASH_PROFILE_AVC264_ONDEMAND) {</span>
<span class="lineNum">    1468 </span>            :                 strcpy(profiles_string, &quot;urn:mpeg:dash:profile:isoff-on-demand:2011,http://dashif.org/guidelines/dash264&quot;);
<span class="lineNum">    1469 </span><span class="lineCov">        486 :         } else if (ctx-&gt;profile==GF_DASH_PROFILE_DASHIF_LL) {</span>
<span class="lineNum">    1470 </span>            :                 strcpy(profiles_string, &quot;urn:mpeg:dash:profile:isoff-live:2011,http://www.dashif.org/guidelines/low-latency-live-v5&quot;);
<span class="lineNum">    1471 </span>            :         } else {
<span class="lineNum">    1472 </span>            :                 strcpy(profiles_string, &quot;urn:mpeg:dash:profile:full:2011&quot;);
<span class="lineNum">    1473 </span>            :         }
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineCov">        876 :         if (ctx-&gt;cmaf) {</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :                 const size_t offset = strlen(profiles_string);</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :                 strncat(profiles_string+offset, &quot;,urn:mpeg:dash:profile:cmaf:2019&quot;, GF_MAX_PATH-offset-1);</span>
<span class="lineNum">    1478 </span>            :         }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineCov">        876 :         if (ctx-&gt;profX) {</span>
<span class="lineNum">    1481 </span>            :                 char profiles_w_ext[GF_MAX_PATH+256];
<span class="lineNum">    1482 </span>            :                 sprintf(profiles_w_ext, &quot;%s,%s&quot;, profiles_string, ctx-&gt;profX);
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;mpd-&gt;profiles) gf_free(ctx-&gt;mpd-&gt;profiles);</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                 ctx-&gt;mpd-&gt;profiles = gf_strdup(profiles_w_ext);</span>
<span class="lineNum">    1485 </span>            :         } else {
<span class="lineNum">    1486 </span><span class="lineCov">        876 :                 if (ctx-&gt;mpd-&gt;profiles) gf_free(ctx-&gt;mpd-&gt;profiles);</span>
<span class="lineNum">    1487 </span><span class="lineCov">        876 :                 ctx-&gt;mpd-&gt;profiles = gf_strdup(profiles_string);</span>
<span class="lineNum">    1488 </span>            :         }
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineCov">        876 :         if (ctx-&gt;use_cenc &amp;&amp; !cenc_att) {</span>
<span class="lineNum">    1491 </span><span class="lineCov">         88 :                 cenc_att = gf_xml_dom_create_attribute(&quot;xmlns:cenc&quot;, &quot;urn:mpeg:cenc:2013&quot;);</span>
<span class="lineNum">    1492 </span><span class="lineCov">         88 :                 gf_list_add(ctx-&gt;mpd-&gt;x_attributes, cenc_att);</span>
<span class="lineNum">    1493 </span>            :         }
<span class="lineNum">    1494 </span><span class="lineCov">        876 :         if (ctx-&gt;use_xlink &amp;&amp; !xlink_att) {</span>
<span class="lineNum">    1495 </span><span class="lineCov">          1 :                 xlink_att = gf_xml_dom_create_attribute(&quot;xmlns:xlink&quot;, &quot;http://www.w3.org/1999/xlink&quot;);</span>
<span class="lineNum">    1496 </span><span class="lineCov">          1 :                 gf_list_add(ctx-&gt;mpd-&gt;x_attributes, xlink_att);</span>
<span class="lineNum">    1497 </span>            :         }
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineCov">        876 :         ctx-&gt;mpd-&gt;time_shift_buffer_depth = 0;</span>
<span class="lineNum">    1500 </span><span class="lineCov">        876 :         ctx-&gt;mpd-&gt;minimum_update_period = 0;</span>
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span><span class="lineCov">        876 :         if (ctx-&gt;dmode==GF_MPD_TYPE_DYNAMIC) {</span>
<span class="lineNum">    1503 </span><span class="lineCov">        433 :                 ctx-&gt;mpd-&gt;time_shift_buffer_depth = (u32) -1;</span>
<span class="lineNum">    1504 </span><span class="lineCov">        433 :                 if (ctx-&gt;tsb&gt;=0) ctx-&gt;mpd-&gt;time_shift_buffer_depth = (u32) (1000*ctx-&gt;tsb);</span>
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span><span class="lineCov">        433 :                 if (ctx-&gt;refresh&gt;=0) {</span>
<span class="lineNum">    1507 </span><span class="lineCov">        433 :                         if (ctx-&gt;refresh) {</span>
<span class="lineNum">    1508 </span><span class="lineCov">         39 :                                 ctx-&gt;mpd-&gt;minimum_update_period = (u32) (1000*ctx-&gt;refresh);</span>
<span class="lineNum">    1509 </span>            :                         } else {
<span class="lineNum">    1510 </span><span class="lineCov">        394 :                                 ctx-&gt;mpd-&gt;minimum_update_period = ctx-&gt;segdur.num * 1000;</span>
<span class="lineNum">    1511 </span><span class="lineCov">        394 :                                 ctx-&gt;mpd-&gt;minimum_update_period /= ctx-&gt;segdur.den;</span>
<span class="lineNum">    1512 </span>            :                         }
<span class="lineNum">    1513 </span>            :                 } else {
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :                         ctx-&gt;mpd-&gt;minimum_update_period = 0;</span>
<span class="lineNum">    1515 </span>            :                 }
<span class="lineNum">    1516 </span>            :         }
<a name="1517"><span class="lineNum">    1517 </span><span class="lineCov">        876 :         return GF_OK;</span></a>
<span class="lineNum">    1518 </span>            : }
<span class="lineNum">    1519 </span><span class="lineCov">        241 : static GF_Err dasher_setup_mpd(GF_DasherCtx *ctx)</span>
<span class="lineNum">    1520 </span>            : {
<span class="lineNum">    1521 </span>            :         u32 i, count;
<span class="lineNum">    1522 </span>            :         GF_MPD_ProgramInfo *info;
<span class="lineNum">    1523 </span><span class="lineCov">        241 :         ctx-&gt;mpd = gf_mpd_new();</span>
<span class="lineNum">    1524 </span><span class="lineCov">        241 :         ctx-&gt;mpd-&gt;xml_namespace = &quot;urn:mpeg:dash:schema:mpd:2011&quot;;</span>
<span class="lineNum">    1525 </span><span class="lineCov">        241 :         ctx-&gt;mpd-&gt;base_URLs = gf_list_new();</span>
<span class="lineNum">    1526 </span><span class="lineCov">        241 :         ctx-&gt;mpd-&gt;locations = gf_list_new();</span>
<span class="lineNum">    1527 </span><span class="lineCov">        241 :         ctx-&gt;mpd-&gt;program_infos = gf_list_new();</span>
<span class="lineNum">    1528 </span><span class="lineCov">        241 :         ctx-&gt;mpd-&gt;periods = gf_list_new();</span>
<span class="lineNum">    1529 </span>            :         //created by default because we store xmlns in it
<span class="lineNum">    1530 </span><span class="lineCov">        241 :         ctx-&gt;mpd-&gt;x_attributes = gf_list_new();</span>
<span class="lineNum">    1531 </span><span class="lineCov">        241 :         if (ctx-&gt;buf&lt;0) {</span>
<span class="lineNum">    1532 </span><span class="lineCov">         68 :                 s32 buf = -ctx-&gt;buf;</span>
<span class="lineNum">    1533 </span><span class="lineCov">         68 :                 ctx-&gt;mpd-&gt;min_buffer_time = (u32) ( ctx-&gt;segdur.num * 10 * buf / ctx-&gt;segdur.den); //*1000 (ms) / 100 (percent)</span>
<span class="lineNum">    1534 </span>            :         } else
<span class="lineNum">    1535 </span><span class="lineCov">        173 :                 ctx-&gt;mpd-&gt;min_buffer_time = ctx-&gt;buf;</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">        241 :         GF_SAFEALLOC(info, GF_MPD_ProgramInfo);</span>
<span class="lineNum">    1538 </span><span class="lineCov">        241 :         if (info) {</span>
<span class="lineNum">    1539 </span><span class="lineCov">        241 :                 gf_list_add(ctx-&gt;mpd-&gt;program_infos, info);</span>
<span class="lineNum">    1540 </span><span class="lineCov">        241 :                 if (ctx-&gt;title)</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :                         info-&gt;title = gf_strdup(ctx-&gt;title);</span>
<span class="lineNum">    1542 </span>            :                 else {
<span class="lineNum">    1543 </span>            :                         char tmp[256];
<span class="lineNum">    1544 </span>            :                         const char *name = NULL;
<span class="lineNum">    1545 </span><span class="lineCov">        241 :                         if (ctx-&gt;out_path) {</span>
<span class="lineNum">    1546 </span>            :                                 const char *url = ctx-&gt;out_path;
<span class="lineNum">    1547 </span><span class="lineCov">        241 :                                 if (!strncmp(ctx-&gt;out_path, &quot;gfio://&quot;, 7)) {</span>
<span class="lineNum">    1548 </span><span class="lineCov">          1 :                                         url = gf_fileio_translate_url(ctx-&gt;out_path);</span>
<span class="lineNum">    1549 </span><span class="lineCov">          1 :                                         if (!url) url = &quot;&quot;;</span>
<span class="lineNum">    1550 </span>            :                                 }
<span class="lineNum">    1551 </span><span class="lineCov">        241 :                                 name = strrchr(url, '/');</span>
<span class="lineNum">    1552 </span><span class="lineCov">        241 :                                 if (!name) name = strrchr(url, '\\');</span>
<span class="lineNum">    1553 </span><span class="lineCov">        241 :                                 if (!name) name = url;</span>
<span class="lineNum">    1554 </span><span class="lineCov">        239 :                                 else name++;</span>
<span class="lineNum">    1555 </span>            :                         }
<span class="lineNum">    1556 </span><span class="lineCov">        241 :                         snprintf(tmp, 255, &quot;%s generated by GPAC&quot;, name ? name : &quot;&quot;);</span>
<span class="lineNum">    1557 </span><span class="lineCov">        241 :                         tmp[255]=0;</span>
<span class="lineNum">    1558 </span><span class="lineCov">        241 :                         info-&gt;title = gf_strdup(tmp);</span>
<span class="lineNum">    1559 </span>            :                 }
<span class="lineNum">    1560 </span><span class="lineCov">        241 :                 if (ctx-&gt;cprt) info-&gt;copyright = gf_strdup(ctx-&gt;cprt);</span>
<span class="lineNum">    1561 </span><span class="lineCov">        241 :                 if (ctx-&gt;info) info-&gt;more_info_url = gf_strdup(ctx-&gt;info);</span>
<span class="lineNum">    1562 </span><span class="lineCov">        241 :                 else info-&gt;more_info_url = gf_strdup(&quot;http://gpac.io&quot;);</span>
<span class="lineNum">    1563 </span><span class="lineCov">        241 :                 if (ctx-&gt;source) info-&gt;source = gf_strdup(ctx-&gt;source);</span>
<span class="lineNum">    1564 </span><span class="lineCov">        241 :                 if (ctx-&gt;lang) info-&gt;lang = gf_strdup(ctx-&gt;lang);</span>
<span class="lineNum">    1565 </span>            :         }
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineCov">        241 :         count = ctx-&gt;location.nb_items;</span>
<span class="lineNum">    1568 </span><span class="lineCov">        241 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :                 char *l = ctx-&gt;location.vals[i];</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :                 gf_list_add(ctx-&gt;mpd-&gt;locations, gf_strdup(l));</span>
<span class="lineNum">    1571 </span>            :         }
<span class="lineNum">    1572 </span><span class="lineCov">        241 :         count = ctx-&gt;base.nb_items;</span>
<span class="lineNum">    1573 </span><span class="lineCov">        242 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1574 </span>            :                 GF_MPD_BaseURL *base;
<span class="lineNum">    1575 </span><span class="lineCov">          1 :                 char *b = ctx-&gt;base.vals[i];</span>
<span class="lineNum">    1576 </span><span class="lineCov">          1 :                 GF_SAFEALLOC(base, GF_MPD_BaseURL);</span>
<span class="lineNum">    1577 </span><span class="lineCov">          1 :                 if (base) {</span>
<span class="lineNum">    1578 </span><span class="lineCov">          1 :                         base-&gt;URL = gf_strdup(b);</span>
<span class="lineNum">    1579 </span><span class="lineCov">          1 :                         gf_list_add(ctx-&gt;mpd-&gt;base_URLs, base);</span>
<span class="lineNum">    1580 </span>            :                 }
<span class="lineNum">    1581 </span>            :         }
<span class="lineNum">    1582 </span><span class="lineCov">        241 :         return dasher_update_mpd(ctx);</span>
<span class="lineNum">    1583 </span>            : }
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span>            : GF_Err rfc_6381_get_codec_aac(char *szCodec, u32 codec_id,  u8 *dsi, u32 dsi_size, Bool force_sbr);
<span class="lineNum">    1587 </span>            : GF_Err rfc_6381_get_codec_m4v(char *szCodec, u32 codec_id, u8 *dsi, u32 dsi_size);
<span class="lineNum">    1588 </span>            : GF_Err rfc_6381_get_codec_avc(char *szCodec, u32 subtype, GF_AVCConfig *avcc);
<span class="lineNum">    1589 </span>            : GF_Err rfc_6381_get_codec_hevc(char *szCodec, u32 subtype, GF_HEVCConfig *hvcc);
<span class="lineNum">    1590 </span>            : GF_Err rfc_6381_get_codec_av1(char *szCodec, u32 subtype, GF_AV1Config *av1c);
<span class="lineNum">    1591 </span>            : GF_Err rfc_6381_get_codec_vpx(char *szCodec, u32 subtype, GF_VPConfig *vpcc);
<span class="lineNum">    1592 </span>            : GF_Err rfc_6381_get_codec_dolby_vision(char *szCodec, u32 subtype, GF_DOVIDecoderConfigurationRecord *dovi);
<span class="lineNum">    1593 </span>            : GF_Err rfc_6381_get_codec_vvc(char *szCodec, u32 subtype, GF_VVCConfig *vvcc);
<span class="lineNum">    1594 </span>            : GF_Err rfc_6381_get_codec_mpegha(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size, s32 pl);
<span class="lineNum">    1595 </span>            : GF_Err rfc6381_codec_name_default(char *szCodec, u32 subtype, u32 codec_id);
<a name="1596"><span class="lineNum">    1596 </span>            : </a>
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">        538 : static GF_Err dasher_get_rfc_6381_codec_name(GF_DasherCtx *ctx, GF_DashStream *ds, char *szCodec, Bool force_inband, Bool force_sbr)</span>
<span class="lineNum">    1599 </span>            : {
<span class="lineNum">    1600 </span>            :         u32 subtype=0, subtype_src=0;
<span class="lineNum">    1601 </span>            :         s32 mha_pl=-1;
<span class="lineNum">    1602 </span>            :         const GF_PropertyValue *dcd, *dcd_enh, *dovi, *codec;
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span><span class="lineCov">        538 :         dcd = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_ISOM_SUBTYPE);</span>
<span class="lineNum">    1605 </span><span class="lineCov">        538 :         if (dcd) subtype_src = dcd-&gt;value.uint;</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineCov">        538 :         dcd = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_DECODER_CONFIG);</span>
<span class="lineNum">    1608 </span><span class="lineCov">        538 :         dcd_enh = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);</span>
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineCov">        538 :         if (!force_inband) {</span>
<span class="lineNum">    1611 </span><span class="lineCov">        538 :                 force_inband = ds-&gt;inband_params;</span>
<span class="lineNum">    1612 </span>            :         }
<span class="lineNum">    1613 </span><span class="lineCov">        538 :         if (!force_inband) {</span>
<span class="lineNum">    1614 </span><span class="lineCov">        530 :                 const GF_PropertyValue *p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_ISOM_SUBTYPE);</span>
<span class="lineNum">    1615 </span><span class="lineCov">        530 :                 if (p) {</span>
<span class="lineNum">    1616 </span>            :                         //input uses inband parameters, force it on output regardless of bitstream switching mode
<span class="lineNum">    1617 </span><span class="lineCov">        427 :                         switch (p-&gt;value.uint) {</span>
<span class="lineNum">    1618 </span><span class="lineCov">          3 :                         case GF_ISOM_SUBTYPE_AVC3_H264:</span>
<span class="lineNum">    1619 </span>            :                         case GF_ISOM_SUBTYPE_AVC4_H264:
<span class="lineNum">    1620 </span>            :                         case GF_ISOM_SUBTYPE_LHE1:
<span class="lineNum">    1621 </span>            :                         case GF_ISOM_SUBTYPE_HEV1:
<span class="lineNum">    1622 </span>            :                                 force_inband = GF_TRUE;
<span class="lineNum">    1623 </span><span class="lineCov">          3 :                                 ds-&gt;inband_params = GF_TRUE;</span>
<span class="lineNum">    1624 </span>            :                                 break;
<span class="lineNum">    1625 </span>            :                         }
<span class="lineNum">    1626 </span>            :                 }
<span class="lineNum">    1627 </span>            :         }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span><span class="lineCov">        538 :         codec = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_CODEC);</span>
<span class="lineNum">    1630 </span><span class="lineCov">        538 :         if (codec &amp;&amp; (codec-&gt;type==GF_PROP_STRING) &amp;&amp; codec-&gt;value.string) {</span>
<span class="lineNum">    1631 </span>            :                 const char *codec_str = codec-&gt;value.string;
<span class="lineNum">    1632 </span><span class="lineCov">         24 :                 if (codec_str[0] != '.') {</span>
<span class="lineNum">    1633 </span>            :                         snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s&quot;, codec_str);
<span class="lineNum">    1634 </span>            :                         return GF_OK;
<span class="lineNum">    1635 </span>            :                 }
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :                 if (!subtype_src)</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :                         subtype_src = gf_codecid_4cc_type(ds-&gt;codec_id);</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :                 snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s%s&quot;, gf_4cc_to_str(subtype_src), codec_str);</span>
<span class="lineNum">    1639 </span>            :                 return GF_OK;
<span class="lineNum">    1640 </span>            :         }
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineCov">        514 :         dovi = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_DOLBY_VISION);</span>
<span class="lineNum">    1643 </span><span class="lineCov">        514 :         if (dovi) {</span>
<span class="lineNum">    1644 </span><span class="lineCov">          1 :                 GF_BitStream *bs = gf_bs_new(dovi-&gt;value.data.ptr, dovi-&gt;value.data.size, GF_BITSTREAM_READ);</span>
<span class="lineNum">    1645 </span><span class="lineCov">          1 :                 GF_DOVIDecoderConfigurationRecord *dvcc = gf_odf_dovi_cfg_read_bs(bs);</span>
<span class="lineNum">    1646 </span><span class="lineCov">          1 :                 gf_bs_del(bs);</span>
<span class="lineNum">    1647 </span><span class="lineCov">          1 :                 if (!dvcc) {</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (&quot;[ISOM Tools] No config found for Dolby Vision file (\&quot;%s\&quot;) when computing RFC6381.\n&quot;, gf_4cc_to_str(subtype)));</span>
<span class="lineNum">    1649 </span>            :                         return GF_BAD_PARAM;
<span class="lineNum">    1650 </span>            :                 }
<span class="lineNum">    1651 </span><span class="lineCov">          1 :                 GF_Err e = rfc_6381_get_codec_dolby_vision(szCodec, GF_ISOM_SUBTYPE_DVHE, dvcc);</span>
<span class="lineNum">    1652 </span><span class="lineCov">          1 :                 gf_odf_dovi_cfg_del(dvcc);</span>
<span class="lineNum">    1653 </span>            :                 return e;
<span class="lineNum">    1654 </span>            :         }
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">        513 :         switch (ds-&gt;codec_id) {</span>
<span class="lineNum">    1657 </span><span class="lineCov">        121 :         case GF_CODECID_AAC_MPEG4:</span>
<span class="lineNum">    1658 </span>            :         case GF_CODECID_AAC_MPEG2_MP:
<span class="lineNum">    1659 </span>            :         case GF_CODECID_AAC_MPEG2_LCP:
<span class="lineNum">    1660 </span>            :         case GF_CODECID_AAC_MPEG2_SSRP:
<span class="lineNum">    1661 </span>            :         case GF_CODECID_USAC:
<span class="lineNum">    1662 </span><span class="lineCov">        121 :                 return rfc_6381_get_codec_aac(szCodec, ds-&gt;codec_id, dcd ? dcd-&gt;value.data.ptr : NULL, dcd ? dcd-&gt;value.data.size : 0, force_sbr);</span>
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span><span class="lineCov">          2 :         case GF_CODECID_MPEG4_PART2:</span>
<span class="lineNum">    1665 </span><span class="lineCov">          2 :                 return rfc_6381_get_codec_m4v(szCodec, ds-&gt;codec_id, dcd ? dcd-&gt;value.data.ptr : NULL, dcd ? dcd-&gt;value.data.size : 0);</span>
<span class="lineNum">    1666 </span>            :                 break;
<span class="lineNum">    1667 </span><span class="lineCov">          2 :         case GF_CODECID_SVC:</span>
<span class="lineNum">    1668 </span>            :         case GF_CODECID_MVC:
<span class="lineNum">    1669 </span><span class="lineCov">          2 :                 if (dcd_enh) dcd = dcd_enh;</span>
<span class="lineNum">    1670 </span><span class="lineCov">          2 :                 subtype = (ds-&gt;codec_id==GF_CODECID_SVC) ? GF_ISOM_SUBTYPE_SVC_H264 : GF_ISOM_SUBTYPE_MVC_H264;</span>
<span class="lineNum">    1671 </span>            :         case GF_CODECID_AVC:
<span class="lineNum">    1672 </span>            :                 if (!subtype) {
<span class="lineNum">    1673 </span><span class="lineCov">        172 :                         if (force_inband) {</span>
<span class="lineNum">    1674 </span><span class="lineCov">          7 :                                 subtype = dcd_enh ? GF_ISOM_SUBTYPE_AVC4_H264 : GF_ISOM_SUBTYPE_AVC3_H264;</span>
<span class="lineNum">    1675 </span>            :                         } else {
<span class="lineNum">    1676 </span><span class="lineCov">        165 :                                 subtype = dcd_enh ? GF_ISOM_SUBTYPE_AVC2_H264 : GF_ISOM_SUBTYPE_AVC_H264;</span>
<span class="lineNum">    1677 </span>            :                         }
<span class="lineNum">    1678 </span>            :                 }
<span class="lineNum">    1679 </span><span class="lineCov">        174 :                 if (dcd) {</span>
<span class="lineNum">    1680 </span><span class="lineCov">        174 :                         GF_AVCConfig *avcc = gf_odf_avc_cfg_read(dcd-&gt;value.data.ptr, dcd-&gt;value.data.size);</span>
<span class="lineNum">    1681 </span><span class="lineCov">        174 :                         if (avcc) {</span>
<span class="lineNum">    1682 </span><span class="lineCov">        174 :                                 GF_Err e = rfc_6381_get_codec_avc(szCodec, subtype, avcc);</span>
<span class="lineNum">    1683 </span><span class="lineCov">        174 :                                 gf_odf_avc_cfg_del(avcc);</span>
<span class="lineNum">    1684 </span>            :                                 return e;
<span class="lineNum">    1685 </span>            :                         }
<span class="lineNum">    1686 </span>            :                 }
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :                 snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s&quot;, gf_4cc_to_str(subtype));</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (&quot;[Dasher] Cannot find AVC config, using default %s\n&quot;, szCodec));</span>
<span class="lineNum">    1689 </span>            :                 return GF_OK;
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            : #ifndef GPAC_DISABLE_HEVC
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :         case GF_CODECID_LHVC:</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :                 subtype = force_inband ? GF_ISOM_SUBTYPE_LHE1 : GF_ISOM_SUBTYPE_LHV1;</span>
<span class="lineNum">    1694 </span>            :                 //fallthrough
<span class="lineNum">    1695 </span>            :         case GF_CODECID_HEVC_TILES:
<span class="lineNum">    1696 </span>            :                 if (!subtype) subtype = GF_ISOM_SUBTYPE_HVT1;
<span class="lineNum">    1697 </span><span class="lineCov">         36 :                 if (!dcd &amp;&amp; ds-&gt;dep_id) {</span>
<span class="lineNum">    1698 </span><span class="lineCov">         27 :                         u32 i, count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    1699 </span><span class="lineCov">         27 :                         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1700 </span><span class="lineCov">         27 :                                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    1701 </span><span class="lineCov">         27 :                                 if (a_ds-&gt;id != ds-&gt;dep_id) continue;</span>
<span class="lineNum">    1702 </span><span class="lineCov">         27 :                                 dcd = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_DECODER_CONFIG);</span>
<span class="lineNum">    1703 </span>            :                                 break;
<span class="lineNum">    1704 </span>            :                         }
<span class="lineNum">    1705 </span>            :                 }
<span class="lineNum">    1706 </span>            :                 //fallthrough
<span class="lineNum">    1707 </span>            :         case GF_CODECID_HEVC:
<span class="lineNum">    1708 </span><span class="lineCov">        111 :                 if (!subtype) {</span>
<span class="lineNum">    1709 </span><span class="lineCov">         75 :                         if (ds-&gt;tile_base) {</span>
<span class="lineNum">    1710 </span><span class="lineCov">          4 :                                 subtype = force_inband ? GF_ISOM_SUBTYPE_HEV2 : GF_ISOM_SUBTYPE_HVC2;</span>
<span class="lineNum">    1711 </span><span class="lineCov">         71 :                         } else if (dcd_enh) {</span>
<span class="lineNum">    1712 </span><span class="lineCov">          2 :                                 if (dcd) {</span>
<span class="lineNum">    1713 </span><span class="lineCov">          2 :                                         subtype = force_inband ? GF_ISOM_SUBTYPE_HEV2 : GF_ISOM_SUBTYPE_HVC2;</span>
<span class="lineNum">    1714 </span>            :                                 } else {
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :                                         subtype = force_inband ? GF_ISOM_SUBTYPE_LHE1 : GF_ISOM_SUBTYPE_LHV1;</span>
<span class="lineNum">    1716 </span>            :                                 }
<span class="lineNum">    1717 </span>            :                         } else {
<span class="lineNum">    1718 </span><span class="lineCov">         69 :                                 subtype = force_inband ? GF_ISOM_SUBTYPE_HEV1 : GF_ISOM_SUBTYPE_HVC1;</span>
<span class="lineNum">    1719 </span>            :                         }
<span class="lineNum">    1720 </span>            :                 }
<span class="lineNum">    1721 </span><span class="lineCov">        111 :                 if (dcd || dcd_enh) {</span>
<span class="lineNum">    1722 </span><span class="lineCov">        111 :                         GF_HEVCConfig *hvcc = dcd ? gf_odf_hevc_cfg_read(dcd-&gt;value.data.ptr, dcd-&gt;value.data.size, GF_FALSE) : NULL;</span>
<span class="lineNum">    1723 </span><span class="lineCov">        111 :                         if (hvcc) {</span>
<span class="lineNum">    1724 </span><span class="lineCov">        111 :                                 GF_Err e = rfc_6381_get_codec_hevc(szCodec, subtype, hvcc);</span>
<span class="lineNum">    1725 </span><span class="lineCov">        111 :                                 gf_odf_hevc_cfg_del(hvcc);</span>
<span class="lineNum">    1726 </span>            :                                 return e;
<span class="lineNum">    1727 </span>            :                         }
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (&quot;[Dasher] HEVC config not compliant !\n&quot;));</span>
<span class="lineNum">    1729 </span>            :                         return GF_NON_COMPLIANT_BITSTREAM;
<span class="lineNum">    1730 </span>            :                 }
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :                 snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s&quot;, gf_4cc_to_str(subtype));</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (&quot;[Dasher] Cannot find HEVC config, using default %s\n&quot;, szCodec));</span>
<span class="lineNum">    1734 </span>            :                 return GF_OK;
<span class="lineNum">    1735 </span>            : #endif
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span>            : #ifndef GPAC_DISABLE_AV1
<span class="lineNum">    1738 </span>            :         case GF_CODECID_AV1:
<span class="lineNum">    1739 </span>            :                 if (!subtype) subtype = GF_ISOM_SUBTYPE_AV01;
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span><span class="lineCov">         54 :                 if (dcd) {</span>
<span class="lineNum">    1742 </span><span class="lineCov">         54 :                         GF_AV1Config *av1c = gf_odf_av1_cfg_read(dcd-&gt;value.data.ptr, dcd-&gt;value.data.size);</span>
<span class="lineNum">    1743 </span><span class="lineCov">         54 :                         if (av1c) {</span>
<span class="lineNum">    1744 </span><span class="lineCov">         54 :                                 GF_Err e = rfc_6381_get_codec_av1(szCodec, subtype, av1c);</span>
<span class="lineNum">    1745 </span><span class="lineCov">         54 :                                 gf_odf_av1_cfg_del(av1c);</span>
<span class="lineNum">    1746 </span>            :                                 return e;
<span class="lineNum">    1747 </span>            :                         }
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (&quot;[DASHER] AV1 config not conformant\n&quot;));</span>
<span class="lineNum">    1749 </span>            :                         return GF_NON_COMPLIANT_BITSTREAM;
<span class="lineNum">    1750 </span>            :                 }
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :                 snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s&quot;, gf_4cc_to_str(subtype));</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (&quot;[Dasher] Cannot find AV1 config, using default %s\n&quot;, szCodec));</span>
<span class="lineNum">    1753 </span>            :                 return GF_OK;
<span class="lineNum">    1754 </span>            : #endif /*GPAC_DISABLE_AV1*/
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            :         case GF_CODECID_VP8:
<span class="lineNum">    1758 </span>            :                 if (!subtype) subtype = GF_ISOM_SUBTYPE_VP08;
<span class="lineNum">    1759 </span>            :         case GF_CODECID_VP9:
<span class="lineNum">    1760 </span>            :                 if (!subtype) subtype = GF_ISOM_SUBTYPE_VP09;
<span class="lineNum">    1761 </span>            : 
<span class="lineNum">    1762 </span><span class="lineCov">         43 :                 if (dcd) {</span>
<span class="lineNum">    1763 </span><span class="lineCov">         43 :                         GF_VPConfig *vpcc = gf_odf_vp_cfg_read(dcd-&gt;value.data.ptr, dcd-&gt;value.data.size);</span>
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span><span class="lineCov">         43 :                         if (vpcc) {</span>
<span class="lineNum">    1766 </span><span class="lineCov">         43 :                                 GF_Err e = rfc_6381_get_codec_vpx(szCodec, subtype, vpcc);</span>
<span class="lineNum">    1767 </span><span class="lineCov">         43 :                                 gf_odf_vp_cfg_del(vpcc);</span>
<span class="lineNum">    1768 </span>            :                                 return e;
<span class="lineNum">    1769 </span>            :                         }
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (&quot;[Dasher] No config found for VP file (\&quot;%s\&quot;) when computing RFC6381.\n&quot;, gf_4cc_to_str(subtype)));</span>
<span class="lineNum">    1771 </span>            :                         return GF_NON_COMPLIANT_BITSTREAM;
<span class="lineNum">    1772 </span>            :                 }
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :                 snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s&quot;, gf_4cc_to_str(subtype));</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (&quot;[Dasher] Cannot find VPX config, using default %s\n&quot;, szCodec));</span>
<span class="lineNum">    1775 </span>            :                 return GF_OK;
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :         case GF_CODECID_MHAS:</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :                 subtype = subtype_src ? subtype_src : GF_ISOM_SUBTYPE_MH3D_MHM1;</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :                 if (!dcd) {</span>
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :                         const GF_PropertyValue *pl = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_PROFILE_LEVEL);</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :                         if (pl) mha_pl = (s32) pl-&gt;value.uint;</span>
<span class="lineNum">    1782 </span>            :                 }
<span class="lineNum">    1783 </span>            :                 //fallthrough
<span class="lineNum">    1784 </span>            :         case GF_CODECID_MPHA:
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :                 if (!subtype)</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :                         subtype = subtype_src ? subtype_src : GF_ISOM_SUBTYPE_MH3D_MHA1;</span>
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :                 return rfc_6381_get_codec_mpegha(szCodec, subtype, dcd ? dcd-&gt;value.data.ptr : NULL, dcd ? dcd-&gt;value.data.size : 0, mha_pl);</span>
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span>            :         case GF_CODECID_VVC:
<span class="lineNum">    1791 </span>            :                 if (!subtype) {
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :                         subtype = force_inband ? GF_ISOM_SUBTYPE_VVI1 : GF_ISOM_SUBTYPE_VVC1;</span>
<span class="lineNum">    1793 </span>            :                 }
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :                 if (dcd) {</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :                         GF_VVCConfig *vvcc = gf_odf_vvc_cfg_read(dcd-&gt;value.data.ptr, dcd-&gt;value.data.size);</span>
<span class="lineNum">    1796 </span>            : 
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :                         snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s.&quot;, gf_4cc_to_str(subtype));</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :                         if (vvcc) {</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :                                 GF_Err e = rfc_6381_get_codec_vvc(szCodec, subtype, vvcc);</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :                                 gf_odf_vvc_cfg_del(vvcc);</span>
<span class="lineNum">    1801 </span>            :                                 return e;
<span class="lineNum">    1802 </span>            :                         }
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, (&quot;[Dasher] No config found for VP file (\&quot;%s\&quot;) when computing RFC6381.\n&quot;, gf_4cc_to_str(subtype)));</span>
<span class="lineNum">    1804 </span>            :                         return GF_NON_COMPLIANT_BITSTREAM;
<span class="lineNum">    1805 </span>            :                 }
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :                 snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, &quot;%s&quot;, gf_4cc_to_str(subtype));</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (&quot;[Dasher] Cannot find VVC config, using default %s\n&quot;, szCodec));</span>
<span class="lineNum">    1808 </span>            :                 return GF_OK;
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span><span class="lineCov">          8 :         default:</span>
<span class="lineNum">    1811 </span><span class="lineCov">          8 :                 subtype = gf_codecid_4cc_type(ds-&gt;codec_id);</span>
<span class="lineNum">    1812 </span><span class="lineCov">          8 :                 if (!subtype) {</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :                         const GF_PropertyValue *p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_ISOM_SUBTYPE);</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :                         if (p) subtype = p-&gt;value.uint;</span>
<span class="lineNum">    1815 </span>            :                 }
<span class="lineNum">    1816 </span><span class="lineCov">          8 :                 if (!subtype) {</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (&quot;[Dasher] codec parameters not known, cannot set codec string\n&quot; ));</span>
<span class="lineNum">    1818 </span>            :                         strcpy(szCodec, &quot;unkn&quot;);
<span class="lineNum">    1819 </span>            :                         return GF_OK;
<span class="lineNum">    1820 </span>            :                 }
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span><span class="lineCov">          8 :                 return rfc6381_codec_name_default(szCodec, subtype, ds-&gt;codec_id);</span>
<span class="lineNum">    1823 </span>            :         }
<span class="lineNum">    1824 </span>            :         return GF_OK;
<span class="lineNum">    1825 </span>            : }
<a name="1826"><span class="lineNum">    1826 </span>            : </a>
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span><span class="lineCov">         45 : static GF_DashStream *get_base_ds(GF_DasherCtx *ctx, GF_DashStream *for_ds)</span>
<span class="lineNum">    1829 </span>            : {
<span class="lineNum">    1830 </span>            :         u32 i, count;
<span class="lineNum">    1831 </span><span class="lineCov">         45 :         if (!for_ds-&gt;dep_id) return NULL;</span>
<span class="lineNum">    1832 </span><span class="lineCov">         45 :         count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1834 </span><span class="lineCov">         45 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    1835 </span><span class="lineCov">         45 :                 if (ds-&gt;id == for_ds-&gt;dep_id)</span>
<span class="lineNum">    1836 </span>            :                         return ds;
<span class="lineNum">    1837 </span>            :         }
<span class="lineNum">    1838 </span>            :         return NULL;
<a name="1839"><span class="lineNum">    1839 </span>            : }</a>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span><span class="lineCov">        109 : static void get_canon_urn(bin128 URN, char *res)</span>
<span class="lineNum">    1842 </span>            : {
<span class="lineNum">    1843 </span>            :         char sres[4];
<span class="lineNum">    1844 </span>            :         u32 i;
<span class="lineNum">    1845 </span>            :         /* Output canonical UIID form */
<span class="lineNum">    1846 </span>            :         strcpy(res, &quot;&quot;);
<span class="lineNum">    1847 </span><span class="lineCov">        545 :         for (i=0; i&lt;4; i++) { sprintf(sres, &quot;%02x&quot;, URN[i]); strcat(res, sres); }</span>
<span class="lineNum">    1848 </span>            :         strcat(res, &quot;-&quot;);
<span class="lineNum">    1849 </span><span class="lineCov">        327 :         for (i=4; i&lt;6; i++) { sprintf(sres, &quot;%02x&quot;, URN[i]); strcat(res, sres); }</span>
<span class="lineNum">    1850 </span>            :         strcat(res, &quot;-&quot;);
<span class="lineNum">    1851 </span><span class="lineCov">        327 :         for (i=6; i&lt;8; i++) { sprintf(sres, &quot;%02x&quot;, URN[i]); strcat(res, sres); }</span>
<span class="lineNum">    1852 </span>            :         strcat(res, &quot;-&quot;);
<span class="lineNum">    1853 </span><span class="lineCov">        327 :         for (i=8; i&lt;10; i++) { sprintf(sres, &quot;%02x&quot;, URN[i]); strcat(res, sres); }</span>
<span class="lineNum">    1854 </span>            :         strcat(res, &quot;-&quot;);
<span class="lineNum">    1855 </span><span class="lineCov">        763 :         for (i=10; i&lt;16; i++) { sprintf(sres, &quot;%02x&quot;, URN[i]); strcat(res, sres); }</span>
<a name="1856"><span class="lineNum">    1856 </span><span class="lineCov">        109 : }</span></a>
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 : static const char *get_drm_kms_name(const char *canURN)</span>
<span class="lineNum">    1859 </span>            : {
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :         if (!stricmp(canURN, &quot;67706163-6365-6E63-6472-6D746F6F6C31&quot;)) return &quot;GPAC1.0&quot;;</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :         else if (!stricmp(canURN, &quot;5E629AF5-38DA-4063-8977-97FFBD9902D4&quot;)) return &quot;Marlin1.0&quot;;</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;adb41c24-2dbf-4a6d-958b-4457c0d27b95&quot;)) return &quot;MediaAccess3.0&quot;;</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;A68129D3-575B-4F1A-9CBA-3223846CF7C3&quot;)) return &quot;VideoGuard&quot;;</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;9a04f079-9840-4286-ab92-e65be0885f95&quot;)) return &quot;PlayReady&quot;;</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;9a27dd82-fde2-4725-8cbc-4234aa06ec09&quot;)) return &quot;VCAS&quot;;</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;F239E769-EFA3-4850-9C16-A903C6932EFB&quot;)) return &quot;Adobe&quot;;</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;1f83e1e8-6ee9-4f0d-ba2f-5ec4e3ed1a66&quot;)) return &quot;SecureMedia&quot;;</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;644FE7B5-260F-4FAD-949A-0762FFB054B4&quot;)) return &quot;CMLA (OMA DRM)&quot;;</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;6a99532d-869f-5922-9a91-113ab7b1e2f3&quot;)) return &quot;MobiTVDRM&quot;;</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;35BF197B-530E-42D7-8B65-1B4BF415070F&quot;)) return &quot;DivX DRM&quot;;</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;B4413586-C58C-FFB0-94A5-D4896C1AF6C3&quot;)) return &quot;VODRM&quot;;</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;edef8ba9-79d6-4ace-a3c8-27dcd51d21ed&quot;)) return &quot;Widevine&quot;;</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;80a6be7e-1448-4c37-9e70-d5aebe04c8d2&quot;)) return &quot;Irdeto&quot;;</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;dcf4e3e3-62f1-5818-7ba6-0a6fe33ff3dd&quot;)) return &quot;CA 1.0, DRM+ 2.0&quot;;</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;45d481cb-8fe0-49c0-ada9-ab2d2455b2f2&quot;)) return &quot;CoreCrypt&quot;;</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;616C7469-6361-7374-2D50-726F74656374&quot;)) return &quot;altiProtect&quot;;</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;992c46e6-c437-4899-b6a0-50fa91ad0e39&quot;)) return &quot;Arris SecureMedia SteelKnot version 1&quot;;</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;1077efec-c0b2-4d02-ace3-3c1e52e2fb4b&quot;)) return &quot;cenc initData&quot;;</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;e2719d58-a985-b3c9-781a-b030af78d30e&quot;)) return &quot;ClearKey1.0&quot;;</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;94CE86FB-07FF-4F43-ADB8-93D2FA968CA2&quot;)) return &quot;FairPlay&quot;;</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;279fe473-512c-48fe-ade8-d176fee6b40f&quot;)) return &quot;Arris Titanium&quot;;</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :         else if (!strcmp(canURN, &quot;aa11967f-cc01-4a4a-8e99-c5d3dddfea2d&quot;)) return &quot;UDRM&quot;;</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :         return &quot;unknown&quot;;</span>
<a name="1884"><span class="lineNum">    1884 </span>            : }</a>
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineCov">        323 : static GF_List *dasher_get_content_protection_desc(GF_DasherCtx *ctx, GF_DashStream *ds, GF_MPD_AdaptationSet *for_set)</span>
<span class="lineNum">    1887 </span>            : {
<span class="lineNum">    1888 </span>            :         char sCan[40];
<span class="lineNum">    1889 </span>            :         u32 prot_scheme=0;
<span class="lineNum">    1890 </span>            :         u32 i, count;
<span class="lineNum">    1891 </span>            :         const GF_PropertyValue *p;
<span class="lineNum">    1892 </span>            :         GF_List *res = NULL;
<span class="lineNum">    1893 </span>            :         GF_BitStream *bs_r;
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span><span class="lineCov">        323 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    1896 </span><span class="lineCov">        323 :         bs_r = gf_bs_new((const char *) &amp;count, 1, GF_BITSTREAM_READ);</span>
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span><span class="lineCov">       1167 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    1899 </span>            :                 GF_MPD_Descriptor *desc;
<span class="lineNum">    1900 </span><span class="lineCov">        844 :                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    1901 </span><span class="lineCov">        844 :                 if (!a_ds-&gt;is_encrypted) continue;</span>
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span><span class="lineCov">        174 :                 if (for_set) {</span>
<span class="lineNum">    1904 </span><span class="lineCov">        174 :                         if (a_ds-&gt;set != for_set) continue;</span>
<span class="lineNum">    1905 </span>            :                         //for now only insert for the stream holding the set
<span class="lineNum">    1906 </span><span class="lineCov">        125 :                         if (!a_ds-&gt;owns_set) continue;</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :                 } else if ((a_ds != ds) &amp;&amp; (a_ds-&gt;muxed_base != ds) ) {</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1909 </span>            :                 }
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span><span class="lineCov">        119 :                 p = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);</span>
<span class="lineNum">    1912 </span><span class="lineCov">        119 :                 if (p) prot_scheme = p-&gt;value.uint;</span>
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span><span class="lineCov">        119 :                 if ((prot_scheme==GF_ISOM_CENC_SCHEME) || (prot_scheme==GF_ISOM_CBC_SCHEME) || (prot_scheme==GF_ISOM_CENS_SCHEME) || (prot_scheme==GF_ISOM_CBCS_SCHEME)</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :                 ) {</span>
<span class="lineNum">    1916 </span>            :                         const GF_PropertyValue *ki;
<span class="lineNum">    1917 </span>            :                         u32 j, nb_pssh;
<span class="lineNum">    1918 </span>            :                         GF_XMLAttribute *att;
<span class="lineNum">    1919 </span>            :                         char szVal[GF_MAX_PATH];
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineCov">        109 :                         ctx-&gt;use_cenc = GF_TRUE;</span>
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span><span class="lineCov">        109 :                         ki = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_CENC_KEY_INFO);</span>
<span class="lineNum">    1924 </span><span class="lineCov">        109 :                         if (!ki || !ki-&gt;value.data.ptr) {</span>
<span class="lineNum">    1925 </span><span class="lineCov">        109 :                                 continue;</span>
<span class="lineNum">    1926 </span>            :                         }
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span><span class="lineCov">        109 :                         if (!res) res = gf_list_new();</span>
<span class="lineNum">    1929 </span><span class="lineCov">        109 :                         desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:dash:mp4protection:2011&quot;, gf_4cc_to_str(prot_scheme));</span>
<span class="lineNum">    1930 </span><span class="lineCov">        109 :                         gf_list_add(res, desc);</span>
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span><span class="lineCov">        109 :                         get_canon_urn(ki-&gt;value.data.ptr + 4, sCan);</span>
<span class="lineNum">    1933 </span><span class="lineCov">        109 :                         att = gf_xml_dom_create_attribute(&quot;cenc:default_KID&quot;, sCan);</span>
<span class="lineNum">    1934 </span><span class="lineCov">        109 :                         if (!desc-&gt;x_attributes) desc-&gt;x_attributes = gf_list_new();</span>
<span class="lineNum">    1935 </span><span class="lineCov">        109 :                         gf_list_add(desc-&gt;x_attributes, att);</span>
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span><span class="lineCov">        109 :                         if (ctx-&gt;pssh &lt;= GF_DASH_PSSH_MOOF) {</span>
<span class="lineNum">    1938 </span><span class="lineCov">        109 :                                 continue;</span>
<span class="lineNum">    1939 </span>            :                         }
<span class="lineNum">    1940 </span>            :                         //(data) binary blob containing (u32)N [(bin128)SystemID(u32)version(u32)KID_count[(bin128)keyID](u32)priv_size(char*priv_size)priv_data]
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                         p = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_CENC_PSSH);</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :                         if (!p) continue;</span>
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :                         gf_bs_reassign_buffer(bs_r, p-&gt;value.data.ptr, p-&gt;value.data.size);</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :                         nb_pssh = gf_bs_read_u32(bs_r);</span>
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span>            :                         //add pssh
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :                         for (j=0; j&lt;nb_pssh; j++) {</span>
<span class="lineNum">    1949 </span>            :                                 u32 pssh_idx;
<span class="lineNum">    1950 </span>            :                                 bin128 sysID;
<span class="lineNum">    1951 </span>            :                                 GF_XMLNode *node;
<span class="lineNum">    1952 </span>            :                                 u32 version, k_count;
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :                                 u8 *pssh_data=NULL;</span>
<span class="lineNum">    1954 </span>            :                                 u32 pssh_len, size_64;
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :                                 GF_BitStream *bs_w = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);</span>
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span>            :                                 //rewrite PSSH box
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :                                 gf_bs_write_u32(bs_w, 0);</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :                                 gf_bs_write_u32(bs_w, GF_ISOM_BOX_TYPE_PSSH);</span>
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :                                 gf_bs_read_data(bs_r, sysID, 16);</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :                                 version = gf_bs_read_u32(bs_r);</span>
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :                                 k_count = gf_bs_read_u32(bs_r);</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :                                 if (k_count) version = 1;</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :                                 gf_bs_write_u8(bs_w, version);</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :                                 gf_bs_write_u24(bs_w, 0);</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :                                 gf_bs_write_data(bs_w, sysID, 16);</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :                                 if (version) {</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :                                         gf_bs_write_u32(bs_w, k_count);</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :                                         for (j=0; j&lt;k_count; j++) {</span>
<span class="lineNum">    1972 </span>            :                                                 bin128 keyID;
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :                                                 gf_bs_read_data(bs_r, keyID, 16);</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :                                                 gf_bs_write_data(bs_w, keyID, 16);</span>
<span class="lineNum">    1975 </span>            :                                         }
<span class="lineNum">    1976 </span>            :                                 }
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :                                 k_count = gf_bs_read_u32(bs_r);</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :                                 gf_bs_write_u32(bs_w, k_count);</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :                                 for (pssh_idx=0; pssh_idx&lt;k_count; pssh_idx++) {</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :                                         gf_bs_write_u8(bs_w, gf_bs_read_u8(bs_r) );</span>
<span class="lineNum">    1981 </span>            :                                 }
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :                                 pssh_len = (u32) gf_bs_get_position(bs_w);</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :                                 gf_bs_seek(bs_w, 0);</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :                                 gf_bs_write_u32(bs_w, pssh_len);</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :                                 gf_bs_seek(bs_w, pssh_len);</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :                                 gf_bs_get_content(bs_w, &amp;pssh_data, &amp;pssh_len);</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :                                 gf_bs_del(bs_w);</span>
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :                                 get_canon_urn(sysID, sCan);</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :                                 desc = gf_mpd_descriptor_new(NULL, NULL, NULL);</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :                                 desc-&gt;x_children = gf_list_new();</span>
<span class="lineNum">    1992 </span>            :                                 sprintf(szVal, &quot;urn:uuid:%s&quot;, sCan);
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :                                 desc-&gt;scheme_id_uri = gf_strdup(szVal);</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :                                 desc-&gt;value = gf_strdup(get_drm_kms_name(sCan));</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :                                 gf_list_add(res, desc);</span>
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :                                 GF_SAFEALLOC(node, GF_XMLNode);</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :                                 if (node) {</span>
<span class="lineNum">    1999 </span>            :                                         GF_XMLNode *pnode;
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :                                         node-&gt;type = GF_XML_NODE_TYPE;</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :                                         node-&gt;name = gf_strdup(&quot;cenc:pssh&quot;);</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :                                         node-&gt;content = gf_list_new();</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :                                         gf_list_add(desc-&gt;x_children, node);</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :                                         GF_SAFEALLOC(pnode, GF_XMLNode);</span>
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :                                         if (pnode) {</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :                                                 pnode-&gt;type = GF_XML_TEXT_TYPE;</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :                                                 gf_list_add(node-&gt;content, pnode);</span>
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :                                                 size_64 = 2*pssh_len;</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :                                                 pnode-&gt;name = gf_malloc(size_64);</span>
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :                                                 if (pnode-&gt;name) {</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :                                                         size_64 = gf_base64_encode((const char *)pssh_data, pssh_len, (char *)pnode-&gt;name, size_64);</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :                                                         pnode-&gt;name[size_64] = 0;</span>
<span class="lineNum">    2015 </span>            :                                                 }
<span class="lineNum">    2016 </span>            :                                         }
<span class="lineNum">    2017 </span>            :                                 }
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :                                 gf_free(pssh_data);</span>
<span class="lineNum">    2019 </span>            :                         }
<span class="lineNum">    2020 </span>            :                 } else {
<span class="lineNum">    2021 </span><span class="lineCov">         10 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Protection scheme %s has no official DASH mapping, using URI \&quot;urn:gpac:dash:mp4protection:2018\&quot;\n&quot;, gf_4cc_to_str(prot_scheme)));</span>
<span class="lineNum">    2022 </span><span class="lineCov">         10 :                         if (!res) res = gf_list_new();</span>
<span class="lineNum">    2023 </span><span class="lineCov">         10 :                         desc = gf_mpd_descriptor_new(NULL, &quot;urn:gpac:dash:mp4protection:2018&quot;, gf_4cc_to_str(prot_scheme));</span>
<span class="lineNum">    2024 </span><span class="lineCov">         10 :                         gf_list_add(res, desc);</span>
<span class="lineNum">    2025 </span>            :                 }
<span class="lineNum">    2026 </span>            :         }
<span class="lineNum">    2027 </span><span class="lineCov">        323 :         gf_bs_del(bs_r);</span>
<span class="lineNum">    2028 </span><span class="lineCov">        323 :         return res;</span>
<a name="2029"><span class="lineNum">    2029 </span>            : }</a>
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineCov">        357 : static void dasher_get_mime_and_ext(GF_DasherCtx *ctx, GF_DashStream *ds, const char **out_subtype, const char **out_ext)</span>
<span class="lineNum">    2032 </span>            : {
<span class="lineNum">    2033 </span>            :         const char *subtype = NULL;
<span class="lineNum">    2034 </span>            :         const char *mux_ext = NULL;
<span class="lineNum">    2035 </span>            :         const char *cstr;
<span class="lineNum">    2036 </span>            : 
<span class="lineNum">    2037 </span><span class="lineCov">        357 :         if (ctx-&gt;m2ts) {</span>
<span class="lineNum">    2038 </span>            :                 subtype = &quot;mp2t&quot;;
<span class="lineNum">    2039 </span><span class="lineCov">        346 :         } else if (ctx-&gt;muxtype!=DASHER_MUX_AUTO) {</span>
<span class="lineNum">    2040 </span><span class="lineCov">        345 :                 switch (ctx-&gt;muxtype) {</span>
<span class="lineNum">    2041 </span>            :                 case DASHER_MUX_ISOM: subtype = &quot;mp4&quot;; mux_ext = &quot;mp4&quot;; break;
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :                 case DASHER_MUX_TS: subtype = &quot;mp2t&quot;; mux_ext = &quot;ts&quot;; break;</span>
<span class="lineNum">    2043 </span><span class="lineCov">          1 :                 case DASHER_MUX_MKV: subtype = &quot;x-matroska&quot;; mux_ext = &quot;mkv&quot;; break;</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :                 case DASHER_MUX_WEBM: subtype = &quot;webm&quot;; mux_ext = &quot;webm&quot;; break;</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :                 case DASHER_MUX_OGG: subtype = &quot;ogg&quot;; mux_ext = &quot;ogg&quot;; break;</span>
<span class="lineNum">    2046 </span><span class="lineCov">          8 :                 case DASHER_MUX_RAW:</span>
<span class="lineNum">    2047 </span><span class="lineCov">          8 :                         cstr = gf_codecid_mime(ds-&gt;codec_id);</span>
<span class="lineNum">    2048 </span><span class="lineCov">          8 :                         if (cstr) {</span>
<span class="lineNum">    2049 </span><span class="lineCov">          8 :                                 subtype = strchr(cstr, '/');</span>
<span class="lineNum">    2050 </span><span class="lineCov">          8 :                                 if (subtype) subtype++;</span>
<span class="lineNum">    2051 </span>            :                                 else subtype = &quot;raw&quot;;
<span class="lineNum">    2052 </span>            :                         }
<span class="lineNum">    2053 </span><span class="lineCov">          8 :                         if (out_ext) {</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :                                 cstr = gf_codecid_file_ext(ds-&gt;codec_id);</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :                                 if (cstr) *out_ext = cstr;</span>
<span class="lineNum">    2056 </span>            :                         }
<span class="lineNum">    2057 </span>            :                         break;
<span class="lineNum">    2058 </span>            :                 }
<span class="lineNum">    2059 </span><span class="lineCov">          1 :         } else if (ctx-&gt;initext) {</span>
<span class="lineNum">    2060 </span>            :                 mux_ext = ctx-&gt;initext;
<span class="lineNum">    2061 </span><span class="lineCov">          1 :                 if (!strcmp(ctx-&gt;initext, &quot;ts&quot;) || !strcmp(ctx-&gt;initext, &quot;m2ts&quot;)) {</span>
<span class="lineNum">    2062 </span>            :                         subtype = &quot;mp2t&quot;;
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :                         ctx-&gt;muxtype = DASHER_MUX_TS;</span>
<span class="lineNum">    2064 </span><span class="lineCov">          1 :                 } else if (!strcmp(ctx-&gt;initext, &quot;mkv&quot;) || !strcmp(ctx-&gt;initext, &quot;mka&quot;) || !strcmp(ctx-&gt;initext, &quot;mks&quot;) || !strcmp(ctx-&gt;initext, &quot;mk3d&quot;)) {</span>
<span class="lineNum">    2065 </span>            :                         subtype = &quot;x-matroska&quot;;
<span class="lineNum">    2066 </span><span class="lineCov">          1 :                         ctx-&gt;muxtype = DASHER_MUX_MKV;</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :                 } else if (!strcmp(ctx-&gt;initext, &quot;webm&quot;) || !strcmp(ctx-&gt;initext, &quot;weba&quot;)) {</span>
<span class="lineNum">    2068 </span>            :                         subtype = &quot;webm&quot;;
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :                         ctx-&gt;muxtype = DASHER_MUX_WEBM;</span>
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :                 } else if (!strcmp(ctx-&gt;initext, &quot;ogg&quot;) || !strcmp(ctx-&gt;initext, &quot;oga&quot;) || !strcmp(ctx-&gt;initext, &quot;ogv&quot;) || !strcmp(ctx-&gt;initext, &quot;spx&quot;) || !strcmp(ctx-&gt;initext, &quot;oggm&quot;) || !strcmp(ctx-&gt;initext, &quot;opus&quot;)) {</span>
<span class="lineNum">    2071 </span>            :                         subtype = &quot;ogg&quot;;
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :                         ctx-&gt;muxtype = DASHER_MUX_OGG;</span>
<span class="lineNum">    2073 </span>            :                 }
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :                 else if (!strcmp(ctx-&gt;initext, &quot;null&quot;)) {</span>
<span class="lineNum">    2075 </span>            :                         mux_ext = &quot;mp4&quot;;
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :                         ctx-&gt;muxtype = DASHER_MUX_ISOM;</span>
<span class="lineNum">    2077 </span>            :                 }
<span class="lineNum">    2078 </span>            :         }
<span class="lineNum">    2079 </span><span class="lineCov">        357 :         if (!subtype) subtype = &quot;mp4&quot;;</span>
<span class="lineNum">    2080 </span><span class="lineCov">        357 :         if (out_subtype) *out_subtype = subtype;</span>
<span class="lineNum">    2081 </span><span class="lineCov">        357 :         if (!mux_ext) mux_ext = &quot;mp4&quot;;</span>
<span class="lineNum">    2082 </span><span class="lineCov">        357 :         if (out_ext) *out_ext = mux_ext;</span>
<span class="lineNum">    2083 </span><span class="lineCov">        357 : }</span>
<a name="2084"><span class="lineNum">    2084 </span>            : </a>
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span><span class="lineCov">        538 : static void dasher_update_rep(GF_DasherCtx *ctx, GF_DashStream *ds)</span>
<span class="lineNum">    2087 </span>            : {
<span class="lineNum">    2088 </span>            :         char szCodec[RFC6381_CODEC_NAME_SIZE_MAX];
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span>            :         //Outputs are not yet connected, derive mime from init segment extension
<span class="lineNum">    2091 </span><span class="lineCov">        538 :         if (!ds-&gt;rep-&gt;mime_type) {</span>
<span class="lineNum">    2092 </span><span class="lineCov">        357 :                 const char *subtype = NULL;</span>
<span class="lineNum">    2093 </span><span class="lineCov">        357 :                 dasher_get_mime_and_ext(ctx, ds, &amp;subtype, NULL);</span>
<span class="lineNum">    2094 </span>            : 
<span class="lineNum">    2095 </span><span class="lineCov">        357 :                 if (ds-&gt;stream_type==GF_STREAM_VISUAL)</span>
<span class="lineNum">    2096 </span><span class="lineCov">        271 :                         gf_dynstrcat(&amp;ds-&gt;rep-&gt;mime_type, &quot;video/&quot;, NULL);</span>
<span class="lineNum">    2097 </span><span class="lineCov">         86 :                 else if (ds-&gt;stream_type==GF_STREAM_AUDIO)</span>
<span class="lineNum">    2098 </span><span class="lineCov">         84 :                         gf_dynstrcat(&amp;ds-&gt;rep-&gt;mime_type, &quot;audio/&quot;, NULL);</span>
<span class="lineNum">    2099 </span>            :                 else
<span class="lineNum">    2100 </span><span class="lineCov">          2 :                         gf_dynstrcat(&amp;ds-&gt;rep-&gt;mime_type, &quot;application/&quot;, NULL);</span>
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span><span class="lineCov">        357 :                 gf_dynstrcat(&amp;ds-&gt;rep-&gt;mime_type, subtype, NULL);</span>
<span class="lineNum">    2103 </span>            :         }
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span><span class="lineCov">        538 :         ds-&gt;rep-&gt;bandwidth = ds-&gt;bitrate;</span>
<span class="lineNum">    2106 </span><span class="lineCov">        538 :         if (ds-&gt;stream_type==GF_STREAM_VISUAL) {</span>
<span class="lineNum">    2107 </span><span class="lineCov">        405 :                 ds-&gt;rep-&gt;width = ds-&gt;width;</span>
<span class="lineNum">    2108 </span><span class="lineCov">        405 :                 ds-&gt;rep-&gt;height = ds-&gt;height;</span>
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineCov">        405 :                 if (!ds-&gt;rep-&gt;sar) {</span>
<span class="lineNum">    2112 </span><span class="lineCov">        271 :                         GF_SAFEALLOC(ds-&gt;rep-&gt;sar, GF_MPD_Fractional);</span>
<span class="lineNum">    2113 </span>            :                 }
<span class="lineNum">    2114 </span><span class="lineCov">        405 :                 if (ds-&gt;rep-&gt;sar) {</span>
<span class="lineNum">    2115 </span><span class="lineCov">        405 :                         ds-&gt;rep-&gt;sar-&gt;num = ds-&gt;sar.num;</span>
<span class="lineNum">    2116 </span><span class="lineCov">        405 :                         ds-&gt;rep-&gt;sar-&gt;den = ds-&gt;sar.den;</span>
<span class="lineNum">    2117 </span>            :                 }
<span class="lineNum">    2118 </span><span class="lineCov">        405 :                 if (ds-&gt;fps.num &amp;&amp; ds-&gt;fps.den) {</span>
<span class="lineNum">    2119 </span><span class="lineCov">        376 :                         if (!ds-&gt;rep-&gt;framerate) {</span>
<span class="lineNum">    2120 </span><span class="lineCov">        242 :                                 GF_SAFEALLOC(ds-&gt;rep-&gt;framerate, GF_MPD_Fractional);</span>
<span class="lineNum">    2121 </span>            :                         }
<span class="lineNum">    2122 </span><span class="lineCov">        376 :                         if (ds-&gt;rep-&gt;framerate) {</span>
<span class="lineNum">    2123 </span><span class="lineCov">        376 :                                 ds-&gt;rep-&gt;framerate-&gt;num = ds-&gt;fps.num;</span>
<span class="lineNum">    2124 </span><span class="lineCov">        376 :                                 ds-&gt;rep-&gt;framerate-&gt;den = ds-&gt;fps.den;</span>
<span class="lineNum">    2125 </span><span class="lineCov">        376 :                                 gf_media_get_reduced_frame_rate(&amp;ds-&gt;rep-&gt;framerate-&gt;num, &amp;ds-&gt;rep-&gt;framerate-&gt;den);</span>
<span class="lineNum">    2126 </span>            :                         }
<span class="lineNum">    2127 </span>            :                 }
<span class="lineNum">    2128 </span>            :         }
<span class="lineNum">    2129 </span><span class="lineCov">        133 :         else if (ds-&gt;stream_type==GF_STREAM_AUDIO) {</span>
<span class="lineNum">    2130 </span>            :                 Bool use_cicp = GF_FALSE;
<span class="lineNum">    2131 </span>            :                 Bool use_dolbyx = GF_FALSE;
<span class="lineNum">    2132 </span>            :                 GF_MPD_Descriptor *desc;
<span class="lineNum">    2133 </span>            :                 char value[256];
<span class="lineNum">    2134 </span><span class="lineCov">        131 :                 ds-&gt;rep-&gt;samplerate = ds-&gt;sr;</span>
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span><span class="lineCov">        131 :                 if (ds-&gt;nb_surround || ds-&gt;nb_lfe) use_cicp = GF_TRUE;</span>
<span class="lineNum">    2137 </span><span class="lineCov">        131 :                 if ((ds-&gt;codec_id==GF_CODECID_MHAS) || (ds-&gt;codec_id==GF_CODECID_MPHA)) use_cicp = GF_TRUE;</span>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span><span class="lineCov">        131 :                 if ((ds-&gt;codec_id==GF_CODECID_AC3) || (ds-&gt;codec_id==GF_CODECID_EAC3)) {</span>
<span class="lineNum">    2140 </span>            :                         //if regular MPEG-DASH, use CICP, otherwise use Dolby signaling
<span class="lineNum">    2141 </span><span class="lineCov">          1 :                         if (ctx-&gt;profile &gt; GF_DASH_PROFILE_FULL) {</span>
<span class="lineNum">    2142 </span>            :                                 use_dolbyx = GF_TRUE;
<span class="lineNum">    2143 </span>            :                         }
<span class="lineNum">    2144 </span>            :                 }
<span class="lineNum">    2145 </span>            :                 if (use_dolbyx) {
<span class="lineNum">    2146 </span>            :                         u32 cicp_layout = 0;
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :                         if (ds-&gt;ch_layout)</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :                                 cicp_layout = gf_audio_fmt_get_cicp_from_layout(ds-&gt;ch_layout);</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :                         if (!cicp_layout)</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :                                 cicp_layout = gf_audio_fmt_get_cicp_layout(ds-&gt;nb_ch, ds-&gt;nb_surround, ds-&gt;nb_lfe);</span>
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :                         sprintf(value, &quot;%X&quot;, gf_audio_fmt_get_dolby_chanmap(cicp_layout) );</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :                         desc = gf_mpd_descriptor_new(NULL, &quot;tag:dolby.com,2014:dash:audio_channel_configuration:2011&quot;, value);</span>
<span class="lineNum">    2154 </span>            :                 }
<span class="lineNum">    2155 </span><span class="lineCov">        131 :                 else if (!use_cicp) {</span>
<span class="lineNum">    2156 </span><span class="lineCov">        131 :                         sprintf(value, &quot;%d&quot;, ds-&gt;nb_ch);</span>
<span class="lineNum">    2157 </span><span class="lineCov">        131 :                         desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:dash:23003:3:audio_channel_configuration:2011&quot;, value);</span>
<span class="lineNum">    2158 </span>            :                 } else {
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :                         sprintf(value, &quot;%d&quot;, gf_audio_fmt_get_cicp_layout(ds-&gt;nb_ch, ds-&gt;nb_surround, ds-&gt;nb_lfe));</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :                         desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:mpegB:cicp:ChannelConfiguration&quot;, value);</span>
<span class="lineNum">    2161 </span>            :                 }
<span class="lineNum">    2162 </span>            : 
<span class="lineNum">    2163 </span><span class="lineCov">        131 :                 gf_mpd_del_list(ds-&gt;rep-&gt;audio_channels, gf_mpd_descriptor_free, GF_TRUE);</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span><span class="lineCov">        131 :                 gf_list_add(ds-&gt;rep-&gt;audio_channels, desc);</span>
<span class="lineNum">    2166 </span>            :         } else {
<span class="lineNum">    2167 </span>            :         }
<span class="lineNum">    2168 </span>            : 
<span class="lineNum">    2169 </span><span class="lineCov">        538 :         dasher_get_rfc_6381_codec_name(ctx, ds, szCodec, (ctx-&gt;bs_switch==DASHER_BS_SWITCH_INBAND) ? GF_TRUE : GF_FALSE, GF_TRUE);</span>
<span class="lineNum">    2170 </span><span class="lineCov">        538 :         if (ds-&gt;rep-&gt;codecs) gf_free(ds-&gt;rep-&gt;codecs);</span>
<span class="lineNum">    2171 </span><span class="lineCov">        538 :         ds-&gt;rep-&gt;codecs = gf_strdup(szCodec);</span>
<span class="lineNum">    2172 </span>            : 
<span class="lineNum">    2173 </span><span class="lineCov">        538 :         if (ds-&gt;interlaced) ds-&gt;rep-&gt;scan_type = GF_MPD_SCANTYPE_INTERLACED;</span>
<span class="lineNum">    2174 </span>            :         else {
<span class="lineNum">    2175 </span>            :                 //profiles forcing scanType=progressive for progressive
<span class="lineNum">    2176 </span><span class="lineCov">        538 :                 switch (ctx-&gt;profile) {</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :                 case GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :                         ds-&gt;rep-&gt;scan_type = GF_MPD_SCANTYPE_PROGRESSIVE;</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2180 </span>            :                 }
<span class="lineNum">    2181 </span>            :         }
<span class="lineNum">    2182 </span>            : 
<span class="lineNum">    2183 </span><span class="lineCov">        538 :         if (ctx-&gt;cp!=GF_DASH_CPMODE_ADAPTATION_SET) {</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :                 gf_mpd_del_list(ds-&gt;rep-&gt;content_protection, gf_mpd_descriptor_free, 0);</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :                 ds-&gt;rep-&gt;content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);</span>
<span class="lineNum">    2186 </span>            :         }
<a name="2187"><span class="lineNum">    2187 </span><span class="lineCov">        538 : }</span></a>
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span><span class="lineCov">        357 : static void dasher_setup_rep(GF_DasherCtx *ctx, GF_DashStream *ds, u32 *srd_rep_idx)</span>
<span class="lineNum">    2190 </span>            : {
<span class="lineNum">    2191 </span>            :         const GF_PropertyValue *p;
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span>            :         assert(ds-&gt;rep==NULL);
<span class="lineNum">    2194 </span><span class="lineCov">        357 :         ds-&gt;rep = gf_mpd_representation_new();</span>
<span class="lineNum">    2195 </span><span class="lineCov">        357 :         ds-&gt;rep-&gt;playback.udta = ds;</span>
<span class="lineNum">    2196 </span><span class="lineCov">        357 :         if (ds-&gt;tci)</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :                 ds-&gt;rep-&gt;crypto_type = 1;</span>
<span class="lineNum">    2198 </span>            :         else
<span class="lineNum">    2199 </span><span class="lineCov">        357 :                 ds-&gt;rep-&gt;crypto_type = ds-&gt;is_encrypted ? 2 : 0;</span>
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span><span class="lineCov">        357 :         dasher_update_rep(ctx, ds);</span>
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span><span class="lineCov">        357 :         p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_AS_ID);</span>
<span class="lineNum">    2204 </span>            :         //do not reset as id in case of period continuity
<span class="lineNum">    2205 </span><span class="lineCov">        357 :         if (p) {</span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :                 if (ds-&gt;as_id != p-&gt;value.uint) {</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :                         if (ds-&gt;period_continuity_id) gf_free(ds-&gt;period_continuity_id);</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :                         ds-&gt;period_continuity_id = NULL;</span>
<span class="lineNum">    2209 </span>            :                 }
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :                 ds-&gt;as_id = p-&gt;value.uint;</span>
<span class="lineNum">    2211 </span>            :         }
<span class="lineNum">    2212 </span>            : 
<span class="lineNum">    2213 </span><span class="lineCov">        357 :         p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_REP_ID);</span>
<span class="lineNum">    2214 </span><span class="lineCov">        357 :         if (p) {</span>
<span class="lineNum">    2215 </span><span class="lineCov">        279 :                 if (ds-&gt;rep_id) gf_free(ds-&gt;rep_id);</span>
<span class="lineNum">    2216 </span>            : 
<span class="lineNum">    2217 </span><span class="lineCov">        306 :                 if (!ds-&gt;tile_base &amp;&amp; (ds-&gt;srd.w || ds-&gt;srd.z) &amp;&amp; !ctx-&gt;sseg &amp;&amp; !ctx-&gt;sfile) {</span>
<span class="lineNum">    2218 </span><span class="lineCov">         27 :                         char *rep_name = gf_malloc(sizeof(char) * (strlen(p-&gt;value.string) + 15) );</span>
<span class="lineNum">    2219 </span><span class="lineCov">         27 :                         sprintf(rep_name, &quot;%s_%d&quot;, p-&gt;value.string, *srd_rep_idx);</span>
<span class="lineNum">    2220 </span><span class="lineCov">         27 :                         ds-&gt;rep_id = rep_name;</span>
<span class="lineNum">    2221 </span><span class="lineCov">         27 :                         (*srd_rep_idx) ++;</span>
<span class="lineNum">    2222 </span>            :                 } else {
<span class="lineNum">    2223 </span><span class="lineCov">        252 :                         ds-&gt;rep_id = gf_strdup(p-&gt;value.string);</span>
<span class="lineNum">    2224 </span>            :                 }
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span><span class="lineCov">         78 :         } else if (!ds-&gt;rep_id) {</span>
<span class="lineNum">    2227 </span>            :                 char szRepID[20];
<span class="lineNum">    2228 </span><span class="lineCov">         78 :                 sprintf(szRepID, &quot;%d&quot;, 1 + gf_list_find(ctx-&gt;pids, ds));</span>
<span class="lineNum">    2229 </span><span class="lineCov">         78 :                 ds-&gt;rep_id = gf_strdup(szRepID);</span>
<span class="lineNum">    2230 </span>            :         }
<span class="lineNum">    2231 </span><span class="lineCov">        357 :         ds-&gt;rep-&gt;id = gf_strdup(ds-&gt;rep_id);</span>
<a name="2232"><span class="lineNum">    2232 </span><span class="lineCov">        357 : }</span></a>
<span class="lineNum">    2233 </span>            : 
<span class="lineNum">    2234 </span><span class="lineCov">        258 : static Bool dasher_same_roles(GF_DashStream *ds1, GF_DashStream *ds2)</span>
<span class="lineNum">    2235 </span>            : {
<span class="lineNum">    2236 </span>            :         const GF_PropStringList *slist;
<span class="lineNum">    2237 </span><span class="lineCov">        258 :         if (ds1-&gt;p_role &amp;&amp; ds2-&gt;p_role) {</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :                 if (gf_props_equal(ds1-&gt;p_role, ds2-&gt;p_role)) return GF_TRUE;</span>
<span class="lineNum">    2239 </span>            :         }
<span class="lineNum">    2240 </span><span class="lineCov">        258 :         if (!ds1-&gt;p_role &amp;&amp; !ds2-&gt;p_role)</span>
<span class="lineNum">    2241 </span>            :                 return GF_TRUE;
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span>            :         //special case, if one is set and the other is not, compare with &quot;main&quot; role
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :         slist = ds2-&gt;p_role ?  &amp;ds2-&gt;p_role-&gt;value.string_list : &amp;ds1-&gt;p_role-&gt;value.string_list;</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :         if (slist-&gt;nb_items==1) {</span>
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :                 if (!strcmp(slist-&gt;vals[0], &quot;main&quot;)) return GF_TRUE;</span>
<span class="lineNum">    2247 </span>            :         }
<span class="lineNum">    2248 </span>            :         return GF_FALSE;
<a name="2249"><span class="lineNum">    2249 </span>            : }</a>
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 : static u32 dasher_get_next_as_id(GF_DasherCtx *ctx)</span>
<span class="lineNum">    2252 </span>            : {
<span class="lineNum">    2253 </span>            :         u32 check_id = 1;
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :         u32 i, count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :                 if (ds-&gt;as_id == check_id) {</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :                         check_id++;</span>
<span class="lineNum">    2259 </span>            :                         i = -1;
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2261 </span>            :                 }
<span class="lineNum">    2262 </span>            :         }
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :         return check_id;</span>
<a name="2264"><span class="lineNum">    2264 </span>            : }</a>
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span><span class="lineCov">        316 : static Bool dasher_same_adaptation_set(GF_DasherCtx *ctx, GF_DashStream *ds, GF_DashStream *ds_test)</span>
<span class="lineNum">    2267 </span>            : {
<span class="lineNum">    2268 </span>            :         const char *lang1, *lang2;
<span class="lineNum">    2269 </span>            :         const GF_PropertyValue *p1, *p2;
<span class="lineNum">    2270 </span>            : 
<span class="lineNum">    2271 </span>            :         //in all forward mode we don't rewrite the manifest, make each source file a single as
<span class="lineNum">    2272 </span><span class="lineCov">        316 :         if (ctx-&gt;forward_mode==DASHER_FWD_ALL)</span>
<span class="lineNum">    2273 </span>            :                 return GF_FALSE;
<span class="lineNum">    2274 </span>            :                 
<span class="lineNum">    2275 </span>            :         //muxed representations
<span class="lineNum">    2276 </span><span class="lineCov">        307 :         if (ds_test-&gt;muxed_base) {</span>
<span class="lineNum">    2277 </span><span class="lineCov">         10 :                 if (ds_test-&gt;muxed_base == ds)</span>
<span class="lineNum">    2278 </span>            :                         return GF_TRUE;
<span class="lineNum">    2279 </span>            :                 //if muxed base rep has been registered with this AdaptationSet, also register this stream
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :                 if (gf_list_find(ds-&gt;set-&gt;representations, ds_test-&gt;muxed_base-&gt;rep)&gt;=0)</span>
<span class="lineNum">    2281 </span>            :                         return GF_TRUE;
<span class="lineNum">    2282 </span>            :         }
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span>            :         //otherwise we have to be of same type
<span class="lineNum">    2285 </span><span class="lineCov">        297 :         if (ds-&gt;stream_type != ds_test-&gt;stream_type) return GF_FALSE;</span>
<span class="lineNum">    2286 </span>            : 
<span class="lineNum">    2287 </span>            :         //not the same roles
<span class="lineNum">    2288 </span><span class="lineCov">        258 :         if (!dasher_same_roles(ds, ds_test)) return GF_FALSE;</span>
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span>            :         //intra-only trick mode belongs to a separate AS
<span class="lineNum">    2291 </span><span class="lineCov">        258 :         if ((ds-&gt;stream_type == GF_STREAM_VISUAL) &amp;&amp; (ds-&gt;sync_points_type != ds_test-&gt;sync_points_type)) {</span>
<span class="lineNum">    2292 </span>            :                 //assign trickmode as id for dashif
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :                 if (ds_test-&gt;sync_points_type == DASHER_SYNC_NONE) {</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :                         if (!ds-&gt;as_id) ds-&gt;as_id = dasher_get_next_as_id(ctx);</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :                         ds_test-&gt;sync_as_id = ds-&gt;as_id;</span>
<span class="lineNum">    2296 </span>            :                 }
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :                 else if (ds-&gt;sync_points_type == DASHER_SYNC_NONE) {</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :                         if (!ds_test-&gt;as_id) ds_test-&gt;as_id = dasher_get_next_as_id(ctx);</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :                         ds-&gt;sync_as_id = ds_test-&gt;as_id;</span>
<span class="lineNum">    2300 </span>            :                 }
<span class="lineNum">    2301 </span>            :                 return GF_FALSE;
<span class="lineNum">    2302 </span>            :         }
<span class="lineNum">    2303 </span>            : 
<span class="lineNum">    2304 </span>            :         /* if two inputs don't have the same (number and value) as_desc they don't belong to the same AdaptationSet
<span class="lineNum">    2305 </span>            :            (use c_as_desc for AdaptationSet descriptors common to all inputs in an AS) */
<span class="lineNum">    2306 </span><span class="lineCov">        258 :         if (!ds-&gt;p_as_desc &amp;&amp; ds_test-&gt;p_as_desc)</span>
<span class="lineNum">    2307 </span>            :                 return GF_FALSE;
<span class="lineNum">    2308 </span><span class="lineCov">        258 :         if (ds-&gt;p_as_desc &amp;&amp; !ds_test-&gt;p_as_desc)</span>
<span class="lineNum">    2309 </span>            :                 return GF_FALSE;
<span class="lineNum">    2310 </span><span class="lineCov">        258 :         if (ds-&gt;p_as_desc &amp;&amp; ! gf_props_equal(ds-&gt;p_as_desc, ds_test-&gt;p_as_desc))</span>
<span class="lineNum">    2311 </span>            :                 return GF_FALSE;
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span>            :         //need same AS ID if specified
<span class="lineNum">    2314 </span><span class="lineCov">        257 :         if (ds-&gt;as_id &amp;&amp; ds_test-&gt;as_id &amp;&amp;(ds-&gt;as_id != ds_test-&gt;as_id) )</span>
<span class="lineNum">    2315 </span>            :                 return GF_FALSE;
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span>            :         //need same dash duration if aligned
<span class="lineNum">    2318 </span><span class="lineCov">        257 :         if (ctx-&gt;align) {</span>
<span class="lineNum">    2319 </span><span class="lineCov">        257 :                 if ((u64) ds-&gt;dash_dur.num * ds_test-&gt;dash_dur.den != (u64) ds_test-&gt;dash_dur.num * ds-&gt;dash_dur.den) return GF_FALSE;</span>
<span class="lineNum">    2320 </span>            :         }
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span>            :         //if one of the pid is marked with period resume and the other is not, one is a spliced media the other no
<span class="lineNum">    2323 </span>            :         //cf flist filter
<span class="lineNum">    2324 </span><span class="lineCov">        257 :         p1 = gf_filter_pid_get_property_str(ds-&gt;ipid, &quot;period_resume&quot;);</span>
<span class="lineNum">    2325 </span><span class="lineCov">        257 :         p2 = gf_filter_pid_get_property_str(ds_test-&gt;ipid, &quot;period_resume&quot;);</span>
<span class="lineNum">    2326 </span><span class="lineCov">        257 :         if ((!p1 &amp;&amp; p2) || (p1 &amp;&amp; !p2) || (p1 &amp;&amp; gf_props_equal(p1, p2)))</span>
<span class="lineNum">    2327 </span>            :                 return GF_FALSE;
<span class="lineNum">    2328 </span>            : 
<span class="lineNum">    2329 </span><span class="lineCov">        257 :         if (ds-&gt;srd.x != ds_test-&gt;srd.x) return GF_FALSE;</span>
<span class="lineNum">    2330 </span><span class="lineCov">         92 :         if (ds-&gt;srd.y != ds_test-&gt;srd.y) return GF_FALSE;</span>
<span class="lineNum">    2331 </span><span class="lineCov">         37 :         if (ds-&gt;srd.z != ds_test-&gt;srd.z) return GF_FALSE;</span>
<span class="lineNum">    2332 </span><span class="lineCov">         32 :         if (ds-&gt;srd.w != ds_test-&gt;srd.w) return GF_FALSE;</span>
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span><span class="lineCov">         32 :         if (ds-&gt;view_id != ds_test-&gt;view_id) return GF_FALSE;</span>
<span class="lineNum">    2335 </span>            :         //according to DASH spec mixing interlaced and progressive is OK
<span class="lineNum">    2336 </span>            :         //if (ds-&gt;interlaced != ds_test-&gt;interlaced) return GF_FALSE;
<span class="lineNum">    2337 </span><span class="lineCov">         32 :         if (ds-&gt;nb_ch != ds_test-&gt;nb_ch) return GF_FALSE;</span>
<span class="lineNum">    2338 </span>            : 
<span class="lineNum">    2339 </span><span class="lineCov">         32 :         lang1 = ds-&gt;lang ? ds-&gt;lang : &quot;und&quot;;</span>
<span class="lineNum">    2340 </span><span class="lineCov">         32 :         lang2 = ds_test-&gt;lang ? ds_test-&gt;lang : &quot;und&quot;;</span>
<span class="lineNum">    2341 </span><span class="lineCov">         32 :         if (strcmp(lang1, lang2)) return GF_FALSE;</span>
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span><span class="lineCov">         30 :         if (ds-&gt;stream_type==GF_STREAM_VISUAL) {</span>
<span class="lineNum">    2344 </span>            :                 u32 w, h, tw, th;
<span class="lineNum">    2345 </span><span class="lineCov">         30 :                 if (ctx-&gt;no_sar) {</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :                         w = ds-&gt;width;</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :                         h = ds-&gt;height;</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :                         tw = ds_test-&gt;width;</span>
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :                         th = ds_test-&gt;height;</span>
<span class="lineNum">    2350 </span>            :                 } else {
<span class="lineNum">    2351 </span><span class="lineCov">         30 :                         w = ds-&gt;width * ds-&gt;sar.num;</span>
<span class="lineNum">    2352 </span><span class="lineCov">         30 :                         h = ds-&gt;height * ds-&gt;sar.den;</span>
<span class="lineNum">    2353 </span><span class="lineCov">         30 :                         tw = ds_test-&gt;width * ds_test-&gt;sar.num;</span>
<span class="lineNum">    2354 </span><span class="lineCov">         30 :                         th = ds_test-&gt;height * ds_test-&gt;sar.den;</span>
<span class="lineNum">    2355 </span>            :                 }
<span class="lineNum">    2356 </span>            : 
<span class="lineNum">    2357 </span>            :                 //not the same aspect ratio
<span class="lineNum">    2358 </span><span class="lineCov">         30 :                 if (w * th != h * tw)</span>
<span class="lineNum">    2359 </span>            :                         return GF_FALSE;
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :         } else if (ds-&gt;stream_type==GF_STREAM_AUDIO) {</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :                 if (!ctx-&gt;mix_codecs &amp;&amp; (ds-&gt;codec_id != ds_test-&gt;codec_id) )</span>
<span class="lineNum">    2362 </span>            :                         return GF_FALSE;
<span class="lineNum">    2363 </span>            :                 //we allow mix of channels config
<span class="lineNum">    2364 </span>            :         } else {
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :                 if (!ctx-&gt;mix_codecs &amp;&amp; strcmp(ds-&gt;rep-&gt;codecs, ds_test-&gt;rep-&gt;codecs)) return GF_FALSE;</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :                 return GF_TRUE;</span>
<span class="lineNum">    2367 </span>            :         }
<span class="lineNum">    2368 </span>            :         //ok, we are video or audio with mixed codecs
<span class="lineNum">    2369 </span><span class="lineCov">         30 :         if (ctx-&gt;mix_codecs) return GF_TRUE;</span>
<span class="lineNum">    2370 </span>            :         //we need dependencies, unless SRD case
<span class="lineNum">    2371 </span><span class="lineCov">         30 :         if (!ds_test-&gt;srd.z &amp;&amp; !ds_test-&gt;srd.w) {</span>
<span class="lineNum">    2372 </span><span class="lineCov">         20 :                 if (ds_test-&gt;dep_id &amp;&amp; (ds_test-&gt;src_id==ds-&gt;src_id) &amp;&amp; gf_list_find(ds-&gt;complementary_streams, ds_test) &lt; 0) {</span>
<span class="lineNum">    2373 </span>            :                         return GF_FALSE;
<span class="lineNum">    2374 </span>            :                 }
<span class="lineNum">    2375 </span>            :         }
<span class="lineNum">    2376 </span>            :         //we should be good
<span class="lineNum">    2377 </span>            :         return GF_TRUE;
<a name="2378"><span class="lineNum">    2378 </span>            : }</a>
<span class="lineNum">    2379 </span>            : 
<span class="lineNum">    2380 </span><span class="lineCov">       1388 : static void dasher_add_descriptors(GF_List **p_dst_list, const GF_PropertyValue *desc_val)</span>
<span class="lineNum">    2381 </span>            : {
<span class="lineNum">    2382 </span>            :         u32 j, count;
<span class="lineNum">    2383 </span>            :         GF_List *dst_list;
<span class="lineNum">    2384 </span><span class="lineCov">       1388 :         if (!desc_val) return;</span>
<span class="lineNum">    2385 </span><span class="lineCov">          8 :         if (desc_val-&gt;type != GF_PROP_STRING_LIST) return;</span>
<span class="lineNum">    2386 </span><span class="lineCov">          8 :         count = desc_val-&gt;value.string_list.nb_items;</span>
<span class="lineNum">    2387 </span><span class="lineCov">          8 :         if (!count) return;</span>
<span class="lineNum">    2388 </span><span class="lineCov">          8 :         if ( ! (*p_dst_list)) *p_dst_list = gf_list_new();</span>
<span class="lineNum">    2389 </span><span class="lineCov">          8 :         dst_list = *p_dst_list;</span>
<span class="lineNum">    2390 </span><span class="lineCov">         16 :         for (j=0; j&lt;count; j++) {</span>
<span class="lineNum">    2391 </span><span class="lineCov">          8 :                 char *desc = desc_val-&gt;value.string_list.vals[j];</span>
<span class="lineNum">    2392 </span><span class="lineCov">          8 :                 if (desc[0] == '&lt;') {</span>
<span class="lineNum">    2393 </span>            :                         GF_XMLNode *d;
<span class="lineNum">    2394 </span><span class="lineCov">          8 :                         GF_SAFEALLOC(d, GF_XMLNode);</span>
<span class="lineNum">    2395 </span><span class="lineCov">          8 :                         if (d) {</span>
<span class="lineNum">    2396 </span><span class="lineCov">          8 :                                 d-&gt;type = GF_XML_TEXT_TYPE;</span>
<span class="lineNum">    2397 </span><span class="lineCov">          8 :                                 d-&gt;name = gf_strdup(desc);</span>
<span class="lineNum">    2398 </span><span class="lineCov">          8 :                                 gf_list_add(dst_list, d);</span>
<span class="lineNum">    2399 </span>            :                         }
<span class="lineNum">    2400 </span>            :                 } else {
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Invalid descriptor %s, expecting '&lt;' as first character\n&quot;, desc));</span>
<span class="lineNum">    2402 </span>            :                 }
<span class="lineNum">    2403 </span>            :         }
<a name="2404"><span class="lineNum">    2404 </span>            : }</a>
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span><span class="lineCov">        317 : static void dasher_setup_set_defaults(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)</span>
<span class="lineNum">    2407 </span>            : {
<span class="lineNum">    2408 </span>            :         u32 i, count;
<span class="lineNum">    2409 </span>            :         Bool main_role_set = GF_FALSE;
<span class="lineNum">    2410 </span>            :         //by default setup alignment
<span class="lineNum">    2411 </span><span class="lineCov">        317 :         if (ctx-&gt;sseg) set-&gt;subsegment_alignment = ctx-&gt;align;</span>
<span class="lineNum">    2412 </span><span class="lineCov">        296 :         else set-&gt;segment_alignment = ctx-&gt;align;</span>
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span>            :         //startWithSAP is set when the first packet comes in
<span class="lineNum">    2415 </span>            : 
<span class="lineNum">    2416 </span>            :         //the rest depends on the various profiles/iop, to check
<span class="lineNum">    2417 </span><span class="lineCov">        317 :         count = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    2418 </span><span class="lineCov">        356 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    2419 </span><span class="lineCov">        356 :                 GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    2420 </span><span class="lineCov">        356 :                 GF_DashStream *ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span><span class="lineCov">        356 :                 if (set-&gt;max_width &lt; ds-&gt;width) set-&gt;max_width = ds-&gt;width;</span>
<span class="lineNum">    2423 </span><span class="lineCov">        356 :                 if (set-&gt;max_height &lt; ds-&gt;height) set-&gt;max_height = ds-&gt;height;</span>
<span class="lineNum">    2424 </span>            : /*              if (set-&gt;max_bandwidth &lt; ds-&gt;rep-&gt;bandwidth) set-&gt;max_bandwidth = ds-&gt;rep-&gt;bandwidth;
<span class="lineNum">    2425 </span>            :                 if (set-&gt;max_framerate * ds-&gt;fps.den &lt; ds-&gt;fps.num) set-&gt;max_framerate = (u32) (ds-&gt;fps.num / ds-&gt;fps.den);
<span class="lineNum">    2426 </span>            : */
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span>            :                 /*set trick mode*/
<span class="lineNum">    2429 </span><span class="lineCov">        356 :                 if (set-&gt;intra_only &amp;&amp; (ds-&gt;stream_type==GF_STREAM_VISUAL)) {</span>
<span class="lineNum">    2430 </span>            :                         char value[256];
<span class="lineNum">    2431 </span>            :                         GF_MPD_Descriptor* desc;
<span class="lineNum">    2432 </span><span class="lineCov">          1 :                         sprintf(value, &quot;%d&quot;, ds-&gt;sync_as_id);</span>
<span class="lineNum">    2433 </span><span class="lineCov">          1 :                         desc = gf_mpd_descriptor_new(NULL, &quot;http://dashif.org/guidelines/trickmode&quot;, value);</span>
<span class="lineNum">    2434 </span><span class="lineCov">          1 :                         gf_list_add(set-&gt;essential_properties, desc);</span>
<span class="lineNum">    2435 </span>            :                 }
<span class="lineNum">    2436 </span>            :                 /*set role*/
<span class="lineNum">    2437 </span><span class="lineCov">        356 :                 if (ds-&gt;p_role) {</span>
<span class="lineNum">    2438 </span>            :                         u32 j, role_count;
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :                         role_count = ds-&gt;p_role-&gt;value.string_list.nb_items;</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :                         for (j=0; j&lt;role_count; j++) {</span>
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :                                 char *role = ds-&gt;p_role-&gt;value.string_list.vals[j];</span>
<span class="lineNum">    2442 </span>            :                                 GF_MPD_Descriptor *desc;
<span class="lineNum">    2443 </span>            :                                 char *uri;
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :                                 if (!strcmp(role, &quot;caption&quot;) || !strcmp(role, &quot;subtitle&quot;) || !strcmp(role, &quot;main&quot;)</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :                                 || !strcmp(role, &quot;alternate&quot;) || !strcmp(role, &quot;supplementary&quot;) || !strcmp(role, &quot;commentary&quot;)</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :                                 || !strcmp(role, &quot;dub&quot;) || !strcmp(role, &quot;description&quot;) || !strcmp(role, &quot;sign&quot;)</span>
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :                                          || !strcmp(role, &quot;metadata&quot;) || !strcmp(role, &quot;enhanced-audio- intelligibility&quot;)</span>
<span class="lineNum">    2448 </span>            :                                 ) {
<span class="lineNum">    2449 </span>            :                                         uri = &quot;urn:mpeg:dash:role:2011&quot;;
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :                                         if (!strcmp(role, &quot;main&quot;)) main_role_set = GF_TRUE;</span>
<span class="lineNum">    2451 </span>            :                                 } else {
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Unrecognized role %s - using GPAC urn for schemaID\n&quot;, role));</span>
<span class="lineNum">    2453 </span>            :                                         uri = &quot;urn:gpac:dash:role:2013&quot;;
<span class="lineNum">    2454 </span>            :                                 }
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :                                 desc = gf_mpd_descriptor_new(NULL, uri, role);</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :                                 gf_list_add(set-&gt;role, desc);</span>
<span class="lineNum">    2457 </span>            :                         }
<span class="lineNum">    2458 </span>            :                 }
<span class="lineNum">    2459 </span>            :                 //set SRD
<span class="lineNum">    2460 </span><span class="lineCov">        356 :                 if (!i &amp;&amp; ds-&gt;srd.z &amp;&amp; ds-&gt;srd.w) {</span>
<span class="lineNum">    2461 </span>            :                         char value[256];
<span class="lineNum">    2462 </span>            :                         GF_MPD_Descriptor *desc;
<span class="lineNum">    2463 </span><span class="lineCov">         30 :                         if (ds-&gt;dep_id) {</span>
<span class="lineNum">    2464 </span><span class="lineCov">         27 :                                 sprintf(value, &quot;1,%d,%d,%d,%d&quot;, ds-&gt;srd.x, ds-&gt;srd.y, ds-&gt;srd.z, ds-&gt;srd.w);</span>
<span class="lineNum">    2465 </span><span class="lineCov">         27 :                                 desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:dash:srd:2014&quot;, value);</span>
<span class="lineNum">    2466 </span><span class="lineCov">         27 :                                 gf_list_add(set-&gt;supplemental_properties, desc);</span>
<span class="lineNum">    2467 </span>            :                         } else {
<span class="lineNum">    2468 </span>            :                                 sprintf(value, &quot;1,0,0,0,0,%d,%d&quot;, ds-&gt;srd.z, ds-&gt;srd.w);
<span class="lineNum">    2469 </span><span class="lineCov">          3 :                                 desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:dash:srd:2014&quot;, value);</span>
<span class="lineNum">    2470 </span><span class="lineCov">          3 :                                 gf_list_add(set-&gt;essential_properties, desc);</span>
<span class="lineNum">    2471 </span>            :                         }
<span class="lineNum">    2472 </span>            :                 }
<span class="lineNum">    2473 </span>            :                 //set HDR
<span class="lineNum">    2474 </span><span class="lineCov">        356 :                 if (ds-&gt;hdr_type &gt; DASHER_HDR_NONE) {</span>
<span class="lineNum">    2475 </span>            :                         char value[256];
<span class="lineNum">    2476 </span>            :                         GF_MPD_Descriptor* desc;
<span class="lineNum">    2477 </span>            :                         sprintf(value, &quot;9&quot;);
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :                         desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:mpegB:cicp:ColourPrimaries&quot;, value);</span>
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :                         gf_list_add(set-&gt;essential_properties, desc);</span>
<span class="lineNum">    2480 </span>            :                         sprintf(value, &quot;9&quot;);
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :                         desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:mpegB:cicp:MatrixCoefficients&quot;, value);</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :                         gf_list_add(set-&gt;essential_properties, desc);</span>
<span class="lineNum">    2483 </span>            : 
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :                         if (ds-&gt;hdr_type==DASHER_HDR_PQ10) {</span>
<span class="lineNum">    2485 </span>            :                                 sprintf(value, &quot;16&quot;);
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :                                 desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:mpegB:cicp:TransferCharacteristics&quot;, value);</span>
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :                                 gf_list_add(set-&gt;essential_properties, desc);</span>
<span class="lineNum">    2488 </span>            :                         }
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 :                         if (ds-&gt;hdr_type == DASHER_HDR_HLG) {</span>
<span class="lineNum">    2491 </span>            :                                 sprintf(value, &quot;14&quot;);
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :                                 desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:mpegB:cicp:TransferCharacteristics&quot;, value);</span>
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :                                 gf_list_add(set-&gt;essential_properties, desc);</span>
<span class="lineNum">    2494 </span>            :                                 sprintf(value, &quot;18&quot;);
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :                                 desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:mpegB:cicp:TransferCharacteristics&quot;, value);</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :                                 gf_list_add(set-&gt;supplemental_properties, desc);</span>
<span class="lineNum">    2497 </span>            :                         }
<span class="lineNum">    2498 </span>            :                 }
<span class="lineNum">    2499 </span>            :         }
<span class="lineNum">    2500 </span><span class="lineCov">        317 :         if (ctx-&gt;check_main_role &amp;&amp; !main_role_set) {</span>
<span class="lineNum">    2501 </span>            :                 GF_MPD_Descriptor *desc;
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :                 desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:dash:role:2011&quot;, &quot;main&quot;);</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :                 gf_list_add(set-&gt;role, desc);</span>
<span class="lineNum">    2504 </span>            :         }
<a name="2505"><span class="lineNum">    2505 </span><span class="lineCov">        317 : }</span></a>
<span class="lineNum">    2506 </span>            : 
<span class="lineNum">    2507 </span><span class="lineCov">          1 : static void rewrite_dep_ids(GF_DasherCtx *ctx, GF_DashStream *base_ds)</span>
<span class="lineNum">    2508 </span>            : {
<span class="lineNum">    2509 </span><span class="lineCov">          1 :         u32 i, count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    2510 </span><span class="lineCov">         20 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    2511 </span><span class="lineCov">         20 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    2512 </span><span class="lineCov">         20 :                 if (ds-&gt;src_id != base_ds-&gt;src_id) continue;</span>
<span class="lineNum">    2513 </span><span class="lineCov">         10 :                 if (!ds-&gt;dep_id || !ds-&gt;rep) continue;</span>
<span class="lineNum">    2514 </span><span class="lineCov">          9 :                 if (ds-&gt;dep_id != base_ds-&gt;id) continue;</span>
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span><span class="lineCov">          9 :                 ds-&gt;tile_dep_id_merged = GF_TRUE;</span>
<span class="lineNum">    2517 </span><span class="lineCov">          9 :                 if (ds-&gt;rep-&gt;dependency_id) gf_free(ds-&gt;rep-&gt;dependency_id);</span>
<span class="lineNum">    2518 </span><span class="lineCov">          9 :                 ds-&gt;rep-&gt;dependency_id = gf_strdup(base_ds-&gt;merged_tile_dep-&gt;rep-&gt;id);</span>
<span class="lineNum">    2519 </span>            :         }
<a name="2520"><span class="lineNum">    2520 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    2521 </span>            : 
<span class="lineNum">    2522 </span><span class="lineCov">        317 : static void dasher_check_bitstream_swicthing(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)</span>
<span class="lineNum">    2523 </span>            : {
<span class="lineNum">    2524 </span>            :         u32 i, j, count;
<span class="lineNum">    2525 </span><span class="lineCov">        317 :         Bool use_inband = (ctx-&gt;bs_switch==DASHER_BS_SWITCH_INBAND) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    2526 </span><span class="lineCov">        317 :         Bool use_multi = (ctx-&gt;bs_switch==DASHER_BS_SWITCH_MULTI) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    2527 </span><span class="lineCov">        317 :         GF_MPD_Representation *base_rep = gf_list_get(set-&gt;representations, 0);</span>
<span class="lineNum">    2528 </span>            :         GF_DashStream *base_ds;
<span class="lineNum">    2529 </span>            : 
<span class="lineNum">    2530 </span><span class="lineCov">        317 :         if (ctx-&gt;m2ts) {</span>
<span class="lineNum">    2531 </span><span class="lineCov">          8 :                 set-&gt;bitstream_switching = GF_TRUE;</span>
<span class="lineNum">    2532 </span>            :                 return;
<span class="lineNum">    2533 </span>            :         }
<span class="lineNum">    2534 </span><span class="lineCov">        309 :         if (ctx-&gt;bs_switch==DASHER_BS_SWITCH_OFF) return;</span>
<span class="lineNum">    2535 </span><span class="lineCov">        287 :         if (!base_rep) return;</span>
<span class="lineNum">    2536 </span><span class="lineCov">        287 :         base_ds = base_rep-&gt;playback.udta;</span>
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span><span class="lineCov">        287 :         count = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    2539 </span><span class="lineCov">        287 :         if (count==1) {</span>
<span class="lineNum">    2540 </span><span class="lineCov">        253 :                 if (ctx-&gt;bs_switch==DASHER_BS_SWITCH_FORCE) set-&gt;bitstream_switching=GF_TRUE;</span>
<span class="lineNum">    2541 </span><span class="lineCov">        251 :                 else if (ctx-&gt;bs_switch==DASHER_BS_SWITCH_INBAND) {</span>
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :                         base_ds-&gt;inband_params = GF_TRUE;</span>
<span class="lineNum">    2543 </span>            :                 }
<span class="lineNum">    2544 </span>            :                 return;
<span class="lineNum">    2545 </span>            :         }
<span class="lineNum">    2546 </span>            : 
<span class="lineNum">    2547 </span><span class="lineCov">         15 :         for (i=1; i&lt;count; i++) {</span>
<span class="lineNum">    2548 </span><span class="lineCov">         34 :                 GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    2549 </span><span class="lineCov">         34 :                 GF_DashStream *ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    2550 </span>            :                 //same codec ID
<span class="lineNum">    2551 </span><span class="lineCov">         34 :                 if (ds-&gt;codec_id == base_ds-&gt;codec_id) {</span>
<span class="lineNum">    2552 </span>            :                         //we will use inband params, so bs switching is OK
<span class="lineNum">    2553 </span><span class="lineCov">         30 :                         if (use_inband || use_multi) continue;</span>
<span class="lineNum">    2554 </span>            :                         //we have deps, cannot use bitstream switching except for merged tile base
<span class="lineNum">    2555 </span><span class="lineCov">         30 :                         if (ds-&gt;dep_id) {</span>
<span class="lineNum">    2556 </span><span class="lineCov">         10 :                                 if (ds-&gt;codec_id==GF_CODECID_HEVC_TILES) {</span>
<span class="lineNum">    2557 </span>            :                                         u32 id;
<span class="lineNum">    2558 </span><span class="lineCov">          9 :                                         GF_DashStream *tile_base = get_base_ds(ctx, ds);</span>
<span class="lineNum">    2559 </span><span class="lineCov">          9 :                                         if (!tile_base) return;</span>
<span class="lineNum">    2560 </span><span class="lineCov">          9 :                                         id = tile_base-&gt;merged_tile_dep ? tile_base-&gt;merged_tile_dep-&gt;id : tile_base-&gt;id;</span>
<span class="lineNum">    2561 </span><span class="lineCov">          9 :                                         if (base_ds-&gt;dep_id==id) continue;</span>
<span class="lineNum">    2562 </span>            :                                 }
<span class="lineNum">    2563 </span>            :                                 return;
<span class="lineNum">    2564 </span>            :                         }
<span class="lineNum">    2565 </span>            :                         //we consider we can switch in non-inband only if we have same CRC for the decoder config
<span class="lineNum">    2566 </span><span class="lineCov">         20 :                         if (base_ds-&gt;dsi_crc == ds-&gt;dsi_crc) continue;</span>
<span class="lineNum">    2567 </span>            :                         //not the same config, no BS switching
<span class="lineNum">    2568 </span>            :                         return;
<span class="lineNum">    2569 </span>            :                 }
<span class="lineNum">    2570 </span>            :                 //dependencies / different codec IDs, cannot use bitstream switching
<span class="lineNum">    2571 </span>            :                 return;
<span class="lineNum">    2572 </span>            :         }
<span class="lineNum">    2573 </span>            :         //ok we can use BS switching, ensure we use the same timescale for every stream
<span class="lineNum">    2574 </span><span class="lineCov">         15 :         set-&gt;bitstream_switching = GF_TRUE;</span>
<span class="lineNum">    2575 </span>            : 
<span class="lineNum">    2576 </span><span class="lineCov">         45 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    2577 </span><span class="lineCov">         30 :                 GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    2578 </span><span class="lineCov">         30 :                 GF_DashStream *ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    2579 </span><span class="lineCov">         30 :                 if (base_ds-&gt;tile_base &amp;&amp; ds-&gt;tile_base &amp;&amp; (base_ds != ds) ) {</span>
<span class="lineNum">    2580 </span><span class="lineCov">          1 :                         ds-&gt;merged_tile_dep = base_ds;</span>
<span class="lineNum">    2581 </span><span class="lineCov">          1 :                         if (ds-&gt;rep) {</span>
<span class="lineNum">    2582 </span><span class="lineCov">          1 :                                 gf_list_rem(set-&gt;representations, i);</span>
<span class="lineNum">    2583 </span><span class="lineCov">          1 :                                 i--;</span>
<span class="lineNum">    2584 </span><span class="lineCov">          1 :                                 count--;</span>
<span class="lineNum">    2585 </span><span class="lineCov">          1 :                                 gf_mpd_representation_free(ds-&gt;rep);</span>
<span class="lineNum">    2586 </span><span class="lineCov">          1 :                                 ds-&gt;rep = NULL;</span>
<span class="lineNum">    2587 </span>            :                                 //switch dependencyID of all reps depending on this one to the new base
<span class="lineNum">    2588 </span><span class="lineCov">          1 :                                 rewrite_dep_ids(ctx, ds);</span>
<span class="lineNum">    2589 </span>            :                         }
<span class="lineNum">    2590 </span>            :                 }
<span class="lineNum">    2591 </span><span class="lineCov">         45 :                 for (j=i+1; j&lt;count; j++) {</span>
<span class="lineNum">    2592 </span>            :                         GF_DashStream *a_ds;
<span class="lineNum">    2593 </span><span class="lineCov">         15 :                         rep = gf_list_get(set-&gt;representations, j);</span>
<span class="lineNum">    2594 </span><span class="lineCov">         15 :                         a_ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    2595 </span><span class="lineCov">         15 :                         if (a_ds-&gt;stream_type != ds-&gt;stream_type) continue;</span>
<span class="lineNum">    2596 </span><span class="lineCov">         15 :                         if (a_ds-&gt;timescale != ds-&gt;timescale)</span>
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :                                 a_ds-&gt;force_timescale = ds-&gt;timescale;</span>
<span class="lineNum">    2598 </span>            :                 }
<span class="lineNum">    2599 </span>            :         }
<span class="lineNum">    2600 </span>            : }
<span class="lineNum">    2601 </span>            : 
<a name="2602"><span class="lineNum">    2602 </span>            : GF_Err gf_cryptfout_push_key(GF_Filter *filter, bin128 *key, bin128 *IV);</a>
<span class="lineNum">    2603 </span>            : 
<span class="lineNum">    2604 </span><span class="lineCov">        349 : static void dasher_open_destination(GF_Filter *filter, GF_DasherCtx *ctx, GF_MPD_Representation *rep, const char *szInitURL, Bool trash_init)</span>
<span class="lineNum">    2605 </span>            : {
<span class="lineNum">    2606 </span>            :         GF_Err e;
<span class="lineNum">    2607 </span>            :         Bool has_frag=GF_FALSE;
<span class="lineNum">    2608 </span>            :         Bool has_subs=GF_FALSE;
<span class="lineNum">    2609 </span>            :         Bool has_strun=GF_FALSE;
<span class="lineNum">    2610 </span>            :         Bool has_vodcache=GF_FALSE;
<span class="lineNum">    2611 </span>            :         Bool has_cmaf=GF_FALSE;
<span class="lineNum">    2612 </span><span class="lineCov">        349 :         char sep_args = gf_filter_get_sep(filter, GF_FS_SEP_ARGS);</span>
<span class="lineNum">    2613 </span><span class="lineCov">        349 :         char sep_name = gf_filter_get_sep(filter, GF_FS_SEP_NAME);</span>
<span class="lineNum">    2614 </span>            :         const char *dst_args, *trailer_args=NULL;
<span class="lineNum">    2615 </span><span class="lineCov">        349 :         char *szDST = NULL;</span>
<span class="lineNum">    2616 </span>            :         char szSRC[100];
<span class="lineNum">    2617 </span>            : 
<span class="lineNum">    2618 </span><span class="lineCov">        349 :         if (ctx-&gt;sigfrag)</span>
<span class="lineNum">    2619 </span><span class="lineCov">          6 :                 return;</span>
<span class="lineNum">    2620 </span>            : 
<span class="lineNum">    2621 </span><span class="lineCov">        343 :         GF_DashStream *ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    2622 </span><span class="lineCov">        343 :         if (ds-&gt;muxed_base) return;</span>
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span>            : 
<span class="lineNum">    2625 </span><span class="lineCov">        343 :         ctx-&gt;check_connections = GF_TRUE;</span>
<span class="lineNum">    2626 </span><span class="lineCov">        343 :         gf_dynstrcat(&amp;szDST, szInitURL, NULL);</span>
<span class="lineNum">    2627 </span><span class="lineCov">        343 :         if (ctx-&gt;out_path) {</span>
<span class="lineNum">    2628 </span>            :                 char *rel = NULL;
<span class="lineNum">    2629 </span><span class="lineCov">        343 :                 if (ctx-&gt;do_m3u8 &amp;&amp; ds-&gt;hls_vp_name) {</span>
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :                         char *tmp = gf_url_concatenate(ctx-&gt;out_path, ds-&gt;hls_vp_name);</span>
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :                         if (tmp) {</span>
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :                                 rel = gf_url_concatenate(tmp, szInitURL);</span>
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :                                 gf_free(tmp);</span>
<span class="lineNum">    2634 </span>            :                         }
<span class="lineNum">    2635 </span>            :                 }
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 :                 if (!rel)</span>
<span class="lineNum">    2637 </span><span class="lineCov">        343 :                         rel = gf_url_concatenate(ctx-&gt;out_path, szInitURL);</span>
<span class="lineNum">    2638 </span><span class="lineCov">        343 :                 if (rel) {</span>
<span class="lineNum">    2639 </span><span class="lineCov">        343 :                         gf_free(szDST);</span>
<span class="lineNum">    2640 </span><span class="lineCov">        343 :                         szDST = rel;</span>
<span class="lineNum">    2641 </span>            :                 }
<span class="lineNum">    2642 </span>            :         }
<span class="lineNum">    2643 </span><span class="lineCov">        343 :         if (ds-&gt;tci) {</span>
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :                 char *tmp = szDST;</span>
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :                 szDST = NULL;</span>
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 :                 gf_dynstrcat(&amp;szDST, &quot;gcryp://&quot;, NULL);</span>
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 :                 gf_dynstrcat(&amp;szDST, tmp, NULL);</span>
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :                 gf_free(tmp);</span>
<span class="lineNum">    2649 </span>            :         }
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span><span class="lineCov">        343 :         sprintf(szSRC, &quot;%cgfopt&quot;, sep_args);</span>
<span class="lineNum">    2652 </span><span class="lineCov">        343 :         gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2653 </span>            : 
<span class="lineNum">    2654 </span><span class="lineCov">        343 :         dst_args = gf_filter_get_dst_args(filter);</span>
<span class="lineNum">    2655 </span><span class="lineCov">        343 :         if (dst_args) {</span>
<span class="lineNum">    2656 </span>            :                 char szKey[20], *sep;
<span class="lineNum">    2657 </span>            :                 sprintf(szSRC, &quot;%c&quot;, sep_args);
<span class="lineNum">    2658 </span><span class="lineCov">        282 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2659 </span>            :                 
<span class="lineNum">    2660 </span><span class="lineCov">        282 :                 gf_dynstrcat(&amp;szDST, dst_args, NULL);</span>
<span class="lineNum">    2661 </span>            :                 sprintf(szKey, &quot;%c%c&quot;, sep_args, sep_args);
<span class="lineNum">    2662 </span><span class="lineCov">        282 :                 sep = strstr(szDST, szKey);</span>
<span class="lineNum">    2663 </span><span class="lineCov">        282 :                 if (sep) {</span>
<span class="lineNum">    2664 </span><span class="lineCov">          1 :                         sep[0] = 0;</span>
<span class="lineNum">    2665 </span><span class="lineCov">          1 :                         trailer_args = strstr(dst_args, szKey);</span>
<span class="lineNum">    2666 </span>            :                 }
<span class="lineNum">    2667 </span>            :                 //look for frag arg
<span class="lineNum">    2668 </span>            :                 sprintf(szKey, &quot;%cfrag&quot;, sep_args);
<span class="lineNum">    2669 </span><span class="lineCov">        282 :                 if (strstr(dst_args, szKey)) has_frag = GF_TRUE;</span>
<span class="lineNum">    2670 </span>            :                 else {
<span class="lineNum">    2671 </span>            :                         sprintf(szKey, &quot;%csfrag&quot;, sep_args);
<span class="lineNum">    2672 </span><span class="lineCov">        282 :                         if (strstr(dst_args, szKey)) has_frag = GF_TRUE;</span>
<span class="lineNum">    2673 </span>            :                 }
<span class="lineNum">    2674 </span>            :                 //look for subs_sidx arg
<span class="lineNum">    2675 </span>            :                 sprintf(szKey, &quot;%csubs_sidx&quot;, sep_args);
<span class="lineNum">    2676 </span><span class="lineCov">        282 :                 if (strstr(dst_args, szKey)) has_subs = GF_TRUE;</span>
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span>            :                 sprintf(szKey, &quot;%cstrun&quot;, sep_args);
<span class="lineNum">    2679 </span><span class="lineCov">        282 :                 if (strstr(dst_args, szKey)) has_strun = GF_TRUE;</span>
<span class="lineNum">    2680 </span>            : 
<span class="lineNum">    2681 </span>            :                 sprintf(szKey, &quot;%cvodcache&quot;, sep_args);
<span class="lineNum">    2682 </span><span class="lineCov">        282 :                 if (strstr(dst_args, szKey)) has_vodcache = GF_TRUE;</span>
<span class="lineNum">    2683 </span>            : 
<span class="lineNum">    2684 </span>            :                 sprintf(szKey, &quot;%ccmaf&quot;, sep_args);
<span class="lineNum">    2685 </span><span class="lineCov">        282 :                 if (strstr(dst_args, szKey)) has_cmaf = GF_TRUE;</span>
<span class="lineNum">    2686 </span>            :         }
<span class="lineNum">    2687 </span>            : 
<span class="lineNum">    2688 </span><span class="lineCov">        343 :         if (trash_init) {</span>
<span class="lineNum">    2689 </span>            :                 sprintf(szSRC, &quot;%cnoinit&quot;, sep_args);
<span class="lineNum">    2690 </span><span class="lineCov">         56 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2691 </span>            :         }
<span class="lineNum">    2692 </span><span class="lineCov">        343 :         if (!has_frag) {</span>
<span class="lineNum">    2693 </span>            :                 sprintf(szSRC, &quot;%cfrag&quot;, sep_args);
<span class="lineNum">    2694 </span><span class="lineCov">        343 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2695 </span>            :         }
<span class="lineNum">    2696 </span><span class="lineCov">        343 :         if (!ctx-&gt;forward_mode) {</span>
<span class="lineNum">    2697 </span><span class="lineCov">        316 :                 if (!has_subs &amp;&amp; ctx-&gt;sseg) {</span>
<span class="lineNum">    2698 </span><span class="lineCov">          4 :                         sprintf(szSRC, &quot;%csubs_sidx%c0&quot;, sep_args, sep_name);</span>
<span class="lineNum">    2699 </span><span class="lineCov">          4 :                         gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2700 </span>            :                 }
<span class="lineNum">    2701 </span><span class="lineCov">        316 :                 if (ctx-&gt;cues &amp;&amp; !has_strun) {</span>
<span class="lineNum">    2702 </span>            :                         sprintf(szSRC, &quot;%cstrun&quot;, sep_args);
<span class="lineNum">    2703 </span><span class="lineCov">         10 :                         gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2704 </span>            :                 }
<span class="lineNum">    2705 </span><span class="lineCov">        316 :                 if (ctx-&gt;styp) {</span>
<span class="lineNum">    2706 </span>            :                         sprintf(szSRC, &quot;%cstyp=%s&quot;, sep_args, ctx-&gt;styp);
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :                         gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2708 </span>            :                 }
<span class="lineNum">    2709 </span>            :         }
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span>            :         //override xps inband declaration in args
<span class="lineNum">    2712 </span><span class="lineCov">        343 :         sprintf(szSRC, &quot;%cxps_inband%c%s&quot;, sep_args, sep_name, ds-&gt;inband_params ? &quot;all&quot; : &quot;no&quot;);</span>
<span class="lineNum">    2713 </span><span class="lineCov">        343 :         gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2714 </span>            : 
<span class="lineNum">    2715 </span><span class="lineCov">        343 :         if (ctx-&gt;no_fragments_defaults) {</span>
<span class="lineNum">    2716 </span>            :                 sprintf(szSRC, &quot;%cnofragdef&quot;, sep_args );
<span class="lineNum">    2717 </span><span class="lineCov">         10 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2718 </span>            :         }
<span class="lineNum">    2719 </span><span class="lineCov">        343 :         switch (ctx-&gt;pssh) {</span>
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :         case GF_DASH_PSSH_MPD:</span>
<span class="lineNum">    2721 </span>            :                 sprintf(szSRC, &quot;%cpsshs%cnone&quot;, sep_args, sep_name);
<span class="lineNum">    2722 </span>            :                 break;
<span class="lineNum">    2723 </span><span class="lineNoCov">          0 :         case GF_DASH_PSSH_MOOF:</span>
<span class="lineNum">    2724 </span>            :         case GF_DASH_PSSH_MOOF_MPD:
<span class="lineNum">    2725 </span>            :                 sprintf(szSRC, &quot;%cpsshs%cmoof&quot;, sep_args, sep_name);
<span class="lineNum">    2726 </span>            :                 break;
<span class="lineNum">    2727 </span><span class="lineCov">        343 :         default:</span>
<span class="lineNum">    2728 </span>            :                 sprintf(szSRC, &quot;%cpsshs%cmoov&quot;, sep_args, sep_name);
<span class="lineNum">    2729 </span>            :                 break;
<span class="lineNum">    2730 </span>            :         }
<span class="lineNum">    2731 </span><span class="lineCov">        343 :         gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2732 </span>            : 
<span class="lineNum">    2733 </span>            :         //patch for old arch: make sure we don't have any extra free box before the sidx
<span class="lineNum">    2734 </span>            :         //we could also use vodcache=insert but this might break http outputs
<span class="lineNum">    2735 </span><span class="lineCov">        343 :         if (gf_sys_old_arch_compat() &amp;&amp; !has_vodcache &amp;&amp; ctx-&gt;sseg) {</span>
<span class="lineNum">    2736 </span>            :                 sprintf(szSRC, &quot;%cvodcache=on&quot;, sep_args );
<span class="lineNum">    2737 </span><span class="lineCov">         19 :                 if (!strstr(szDST, szSRC))</span>
<span class="lineNum">    2738 </span><span class="lineCov">         19 :                         gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2739 </span>            :         }
<span class="lineNum">    2740 </span>            : 
<span class="lineNum">    2741 </span>            :         //we don't append mime in case of raw streams, raw format (writegen doesn't use mime types for raw media, only file ext)
<span class="lineNum">    2742 </span><span class="lineCov">        343 :         if ((ctx-&gt;muxtype!=DASHER_MUX_RAW) || (ds-&gt;codec_id != GF_CODECID_RAW)) {</span>
<span class="lineNum">    2743 </span><span class="lineCov">        343 :                 sprintf(szSRC, &quot;%cmime=%s&quot;, sep_args, rep-&gt;mime_type);</span>
<span class="lineNum">    2744 </span><span class="lineCov">        343 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2745 </span>            :         }
<span class="lineNum">    2746 </span>            : 
<span class="lineNum">    2747 </span><span class="lineCov">        343 :         if (ds-&gt;moof_sn&gt;1) {</span>
<span class="lineNum">    2748 </span>            :                 sprintf(szSRC, &quot;%cmsn%c%d&quot;, sep_args, sep_name, ds-&gt;moof_sn);
<span class="lineNum">    2749 </span><span class="lineCov">         36 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2750 </span>            :         }
<span class="lineNum">    2751 </span><span class="lineCov">        343 :         if (ds-&gt;moof_sn_inc&gt;1) {</span>
<span class="lineNum">    2752 </span>            :                 sprintf(szSRC, &quot;%cmsninc%c%d&quot;, sep_args, sep_name, ds-&gt;moof_sn_inc);
<span class="lineNum">    2753 </span><span class="lineCov">         41 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2754 </span>            :         }
<span class="lineNum">    2755 </span><span class="lineCov">        343 :         if (ds-&gt;sscale) {</span>
<span class="lineNum">    2756 </span>            :                 sprintf(szSRC, &quot;%cmoovts%c-1&quot;, sep_args, sep_name);
<span class="lineNum">    2757 </span><span class="lineCov">          2 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2758 </span>            :         }
<span class="lineNum">    2759 </span>            : 
<span class="lineNum">    2760 </span><span class="lineCov">        343 :         if (!has_cmaf &amp;&amp; ctx-&gt;cmaf) {</span>
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :                 sprintf(szSRC, &quot;%ccmaf%c%s&quot;, sep_args, sep_name, (ctx-&gt;cmaf==DASHER_CMAF_CMF2) ? &quot;cmf2&quot; : &quot;cmfc&quot;);</span>
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :                 gf_dynstrcat(&amp;szDST, szSRC, NULL);</span>
<span class="lineNum">    2763 </span>            :         }
<span class="lineNum">    2764 </span>            : 
<span class="lineNum">    2765 </span>            : 
<span class="lineNum">    2766 </span><span class="lineCov">        343 :         if (trailer_args)</span>
<span class="lineNum">    2767 </span><span class="lineCov">          1 :                 gf_dynstrcat(&amp;szDST, trailer_args, NULL);</span>
<span class="lineNum">    2768 </span>            :                 
<span class="lineNum">    2769 </span><span class="lineCov">        343 :         ds-&gt;dst_filter = gf_filter_connect_destination(filter, szDST, &amp;e);</span>
<span class="lineNum">    2770 </span><span class="lineCov">        343 :         gf_free(szDST);</span>
<span class="lineNum">    2771 </span><span class="lineCov">        343 :         szDST = NULL;</span>
<span class="lineNum">    2772 </span><span class="lineCov">        343 :         if (e) {</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't create output file %s: %s\n&quot;, szInitURL, gf_error_to_string(e) ));</span>
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :                 ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    2775 </span>            :                 return;
<span class="lineNum">    2776 </span>            :         }
<span class="lineNum">    2777 </span>            :         //reset any sourceID given in the dst_arg and assign sourceID to be the dasher filter
<span class="lineNum">    2778 </span><span class="lineCov">        343 :         sprintf(szSRC, &quot;MuxSrc%cdasher_%p&quot;, sep_name, ds-&gt;dst_filter);</span>
<span class="lineNum">    2779 </span><span class="lineCov">        343 :         gf_filter_reset_source(ds-&gt;dst_filter);</span>
<span class="lineNum">    2780 </span><span class="lineCov">        343 :         gf_filter_set_source(ds-&gt;dst_filter, filter, szSRC);</span>
<span class="lineNum">    2781 </span>            : 
<span class="lineNum">    2782 </span><span class="lineCov">        343 :         if (ds-&gt;tci &amp;&amp; !trash_init) {</span>
<span class="lineNum">    2783 </span>            :                 //push NULL key, we are not encrypting the init segment
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :                 gf_cryptfout_push_key(ds-&gt;dst_filter, NULL, NULL);</span>
<span class="lineNum">    2785 </span>            :         }
<a name="2786"><span class="lineNum">    2786 </span>            : }</a>
<span class="lineNum">    2787 </span>            : 
<span class="lineNum">    2788 </span><span class="lineCov">          3 : static void dasher_gather_deps(GF_DasherCtx *ctx, u32 dependency_id, GF_List *multi_tracks)</span>
<span class="lineNum">    2789 </span>            : {
<span class="lineNum">    2790 </span><span class="lineCov">          3 :         u32 i, count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    2791 </span><span class="lineCov">         11 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    2792 </span><span class="lineCov">          8 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    2793 </span><span class="lineCov">          8 :                 if (ds-&gt;id == dependency_id) {</span>
<span class="lineNum">    2794 </span><span class="lineCov">          3 :                         if (ds-&gt;tile_base) continue;</span>
<span class="lineNum">    2795 </span>            : 
<span class="lineNum">    2796 </span>            :                         assert(ds-&gt;opid);
<span class="lineNum">    2797 </span><span class="lineCov">          3 :                         gf_list_insert(multi_tracks, ds-&gt;opid, 0);</span>
<span class="lineNum">    2798 </span><span class="lineCov">          3 :                         if (ds-&gt;dep_id) dasher_gather_deps(ctx, ds-&gt;dep_id, multi_tracks);</span>
<span class="lineNum">    2799 </span>            :                 }
<span class="lineNum">    2800 </span>            :         }
<a name="2801"><span class="lineNum">    2801 </span><span class="lineCov">          3 : }</span></a>
<span class="lineNum">    2802 </span>            : 
<span class="lineNum">    2803 </span><span class="lineCov">         16 : static void dasher_update_dep_list(GF_DasherCtx *ctx, GF_DashStream *ds, const char *ref_type)</span>
<span class="lineNum">    2804 </span>            : {
<span class="lineNum">    2805 </span>            :         u32 i, j, count, base_id;
<span class="lineNum">    2806 </span><span class="lineCov">         16 :         GF_PropertyValue *p = (GF_PropertyValue *) gf_filter_pid_get_property_str(ds-&gt;opid, ref_type);</span>
<span class="lineNum">    2807 </span><span class="lineCov">         16 :         if (!p) return;</span>
<span class="lineNum">    2808 </span><span class="lineNoCov">          0 :         base_id = ds-&gt;dep_id ? ds-&gt;dep_id : ds-&gt;id;</span>
<span class="lineNum">    2809 </span><span class="lineNoCov">          0 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    2810 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;p-&gt;value.uint_list.nb_items; i++) {</span>
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :                 for (j=0; j&lt;count; j++) {</span>
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :                         GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :                         if (a_ds-&gt;dep_id != base_id) continue;</span>
<span class="lineNum">    2814 </span><span class="lineNoCov">          0 :                         if ((a_ds-&gt;id == p-&gt;value.uint_list.vals[i]) &amp;&amp; a_ds-&gt;pid_id) {</span>
<span class="lineNum">    2815 </span><span class="lineNoCov">          0 :                                 p-&gt;value.uint_list.vals[i] = a_ds-&gt;pid_id;</span>
<span class="lineNum">    2816 </span>            :                         }
<span class="lineNum">    2817 </span>            :                 }
<span class="lineNum">    2818 </span>            :         }
<a name="2819"><span class="lineNum">    2819 </span>            : }</a>
<span class="lineNum">    2820 </span>            : 
<span class="lineNum">    2821 </span><span class="lineCov">        364 : static void dasher_open_pid(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *ds, GF_List *multi_pids, Bool init_trashed)</span>
<span class="lineNum">    2822 </span>            : {
<span class="lineNum">    2823 </span><span class="lineCov">        364 :         GF_DashStream *base_ds = ds-&gt;muxed_base ? ds-&gt;muxed_base : ds;</span>
<span class="lineNum">    2824 </span>            :         char szSRC[1024];
<span class="lineNum">    2825 </span>            : 
<span class="lineNum">    2826 </span><span class="lineCov">        364 :         if (ctx-&gt;sigfrag || ctx-&gt;in_error)</span>
<span class="lineNum">    2827 </span><span class="lineCov">          9 :                 return;</span>
<span class="lineNum">    2828 </span>            : 
<span class="lineNum">    2829 </span>            :         assert(!ds-&gt;opid);
<span class="lineNum">    2830 </span>            :         assert(base_ds-&gt;dst_filter);
<span class="lineNum">    2831 </span>            : 
<span class="lineNum">    2832 </span><span class="lineCov">        361 :         if (ds-&gt;tile_base &amp;&amp; !init_trashed) {</span>
<span class="lineNum">    2833 </span><span class="lineCov">          6 :                 s32 res = gf_list_find(ctx-&gt;postponed_pids, ds);</span>
<span class="lineNum">    2834 </span><span class="lineCov">          6 :                 if (res &lt; 0) {</span>
<span class="lineNum">    2835 </span><span class="lineCov">          3 :                         gf_list_add(ctx-&gt;postponed_pids, ds);</span>
<span class="lineNum">    2836 </span><span class="lineCov">          3 :                         return;</span>
<span class="lineNum">    2837 </span>            :                 } else {
<span class="lineNum">    2838 </span><span class="lineCov">          3 :                         gf_list_rem(ctx-&gt;postponed_pids, res);</span>
<span class="lineNum">    2839 </span>            :                 }
<span class="lineNum">    2840 </span><span class="lineCov">        352 :         } else if (!ds-&gt;tile_base) {</span>
<span class="lineNum">    2841 </span><span class="lineCov">        352 :                 gf_list_del_item(ctx-&gt;postponed_pids, ds);</span>
<span class="lineNum">    2842 </span>            :         }
<span class="lineNum">    2843 </span>            : 
<span class="lineNum">    2844 </span>            :         //tile base not live profile, make sure all our deps are ready
<span class="lineNum">    2845 </span><span class="lineCov">        355 :         if (ds-&gt;tile_base &amp;&amp; !ctx-&gt;sseg) {</span>
<span class="lineNum">    2846 </span><span class="lineCov">          3 :                 u32 i, count = gf_list_count(ds-&gt;complementary_streams);</span>
<span class="lineNum">    2847 </span><span class="lineCov">         30 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    2848 </span><span class="lineCov">         27 :                         GF_DashStream *a_ds = gf_list_get(ds-&gt;complementary_streams, i);</span>
<span class="lineNum">    2849 </span>            :                         //dep not ready
<span class="lineNum">    2850 </span><span class="lineCov">         27 :                         if (!a_ds-&gt;opid) {</span>
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 :                                 if (gf_list_find(ctx-&gt;postponed_pids, a_ds)&lt;0) {</span>
<span class="lineNum">    2852 </span><span class="lineNoCov">          0 :                                         gf_list_add(ctx-&gt;postponed_pids, a_ds);</span>
<span class="lineNum">    2853 </span>            :                                 }
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :                                 gf_list_del_item(ctx-&gt;postponed_pids, ds);</span>
<span class="lineNum">    2855 </span><span class="lineNoCov">          0 :                                 gf_list_add(ctx-&gt;postponed_pids, ds);</span>
<span class="lineNum">    2856 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    2857 </span>            :                         }
<span class="lineNum">    2858 </span>            :                 }
<span class="lineNum">    2859 </span>            :         }
<span class="lineNum">    2860 </span>            : 
<span class="lineNum">    2861 </span><span class="lineCov">        355 :         if (ctx-&gt;sigfrag)</span>
<span class="lineNum">    2862 </span>            :                 return;
<span class="lineNum">    2863 </span>            : 
<span class="lineNum">    2864 </span><span class="lineCov">        355 :         sprintf(szSRC, &quot;dasher_%p&quot;, base_ds-&gt;dst_filter);</span>
<span class="lineNum">    2865 </span><span class="lineCov">        355 :         ds-&gt;opid = gf_filter_pid_new(filter);</span>
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span>            : #ifdef GPAC_64_BITS
<span class="lineNum">    2868 </span><span class="lineCov">        355 :         ds-&gt;hls_ref_id = (u64) ds-&gt;opid;</span>
<span class="lineNum">    2869 </span>            : #else
<span class="lineNum">    2870 </span>            :         ds-&gt;hls_ref_id = (u64) ((u32) ds-&gt;opid);
<span class="lineNum">    2871 </span>            : #endif
<span class="lineNum">    2872 </span>            : 
<span class="lineNum">    2873 </span><span class="lineCov">        355 :         gf_filter_pid_copy_properties(ds-&gt;opid, ds-&gt;ipid);</span>
<span class="lineNum">    2874 </span><span class="lineCov">        355 :         if (!ds-&gt;muxed_base) {</span>
<span class="lineNum">    2875 </span><span class="lineCov">        343 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_FILE_EXT, &amp;PROP_STRING(&quot;*&quot;));</span>
<span class="lineNum">    2876 </span><span class="lineCov">        343 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_MIME, &amp;PROP_STRING(ds-&gt;rep-&gt;mime_type));</span>
<span class="lineNum">    2877 </span>            :         }
<span class="lineNum">    2878 </span><span class="lineCov">        355 :         if (ds-&gt;nb_cues) {</span>
<span class="lineNum">    2879 </span>            :                 u32 ncues = ds-&gt;nb_cues;
<span class="lineNum">    2880 </span><span class="lineCov">         10 :                 if ((ds-&gt;cues[0].sample_num&gt;0) || (ds-&gt;cues[0].cts&gt;0) || (ds-&gt;cues[0].dts&gt;0))</span>
<span class="lineNum">    2881 </span><span class="lineCov">         10 :                         ncues++;</span>
<span class="lineNum">    2882 </span><span class="lineCov">         10 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_SEGMENTS, &amp;PROP_UINT(ncues) );</span>
<span class="lineNum">    2883 </span>            :         }
<span class="lineNum">    2884 </span>            :         //for route out
<span class="lineNum">    2885 </span><span class="lineCov">        355 :         if (ctx-&gt;is_route) {</span>
<span class="lineNum">    2886 </span><span class="lineCov">          4 :                 if (ctx-&gt;do_m3u8)</span>
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :                         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PCK_HLS_REF, &amp;PROP_LONGUINT( ds-&gt;hls_ref_id ) );</span>
<span class="lineNum">    2888 </span>            : 
<span class="lineNum">    2889 </span><span class="lineCov">          4 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_REP_ID, &amp;PROP_STRING( ds-&gt;rep-&gt;id ) );</span>
<span class="lineNum">    2890 </span>            : 
<span class="lineNum">    2891 </span>            : 
<span class="lineNum">    2892 </span><span class="lineCov">          4 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_DUR, &amp;PROP_FRAC( ds-&gt;dash_dur ) );</span>
<span class="lineNum">    2893 </span>            :         }
<span class="lineNum">    2894 </span>            : 
<span class="lineNum">    2895 </span><span class="lineCov">        355 :         gf_filter_pid_require_source_id(ds-&gt;opid);</span>
<span class="lineNum">    2896 </span>            : 
<span class="lineNum">    2897 </span><span class="lineCov">        355 :         if (ctx-&gt;pssh == GF_DASH_PSSH_MPD) {</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_CENC_PSSH, NULL);</span>
<span class="lineNum">    2899 </span>            :         }
<span class="lineNum">    2900 </span>            : 
<span class="lineNum">    2901 </span>            : 
<span class="lineNum">    2902 </span>            :         //force PID ID
<span class="lineNum">    2903 </span><span class="lineCov">        355 :         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_ID, &amp;PROP_UINT(ds-&gt;pid_id) );</span>
<span class="lineNum">    2904 </span><span class="lineCov">        355 :         if (ds-&gt;dep_pid_id)</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DEPENDENCY_ID, &amp;PROP_UINT(ds-&gt;dep_pid_id) );</span>
<span class="lineNum">    2906 </span><span class="lineCov">        355 :         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_MUX_SRC, &amp;PROP_STRING(szSRC) );</span>
<span class="lineNum">    2907 </span><span class="lineCov">        355 :         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_MODE, &amp;PROP_UINT(ctx-&gt;sseg ? 2 : 1) );</span>
<span class="lineNum">    2908 </span><span class="lineCov">        355 :         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_DUR, &amp;PROP_FRAC(ds-&gt;dash_dur) );</span>
<span class="lineNum">    2909 </span>            : 
<span class="lineNum">    2910 </span><span class="lineCov">        355 :         if (ds-&gt;id != ds-&gt;pid_id) {</span>
<span class="lineNum">    2911 </span><span class="lineCov">          8 :                 dasher_update_dep_list(ctx, ds, &quot;isom:scal&quot;);</span>
<span class="lineNum">    2912 </span><span class="lineCov">          8 :                 dasher_update_dep_list(ctx, ds, &quot;isom:sabt&quot;);</span>
<span class="lineNum">    2913 </span>            :         }
<span class="lineNum">    2914 </span>            : 
<span class="lineNum">    2915 </span>            :         /*timescale forced (bitstream switching) */
<span class="lineNum">    2916 </span><span class="lineCov">        355 :         if (ds-&gt;force_timescale)</span>
<span class="lineNum">    2917 </span><span class="lineNoCov">          0 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_TIMESCALE, &amp;PROP_UINT(ds-&gt;force_timescale) );</span>
<span class="lineNum">    2918 </span>            : 
<span class="lineNum">    2919 </span><span class="lineCov">        355 :         if (ds-&gt;rep &amp;&amp; ds-&gt;rep-&gt;segment_template)</span>
<span class="lineNum">    2920 </span><span class="lineCov">         57 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_TEMPLATE, &amp;PROP_STRING(ds-&gt;rep-&gt;segment_template-&gt;media));</span>
<span class="lineNum">    2921 </span><span class="lineCov">        298 :         else if (ds-&gt;set &amp;&amp; ds-&gt;set-&gt;segment_template)</span>
<span class="lineNum">    2922 </span><span class="lineCov">        237 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_TEMPLATE, &amp;PROP_STRING(ds-&gt;set-&gt;segment_template-&gt;media));</span>
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span><span class="lineCov">        355 :         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_BITRATE, &amp;PROP_UINT(ds-&gt;bitrate));</span>
<span class="lineNum">    2925 </span><span class="lineCov">        355 :         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PCK_FILENAME, &amp;PROP_STRING(ds-&gt;init_seg));</span>
<span class="lineNum">    2926 </span>            : 
<span class="lineNum">    2927 </span><span class="lineCov">        355 :         if (ds-&gt;rep &amp;&amp; ds-&gt;rep-&gt;codecs)</span>
<span class="lineNum">    2928 </span><span class="lineCov">        343 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_CODEC, &amp;PROP_STRING(ds-&gt;rep-&gt;codecs));</span>
<span class="lineNum">    2929 </span>            : 
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span><span class="lineCov">        355 :         if (multi_pids) {</span>
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 :                 s32 idx = 1+gf_list_find(multi_pids, ds-&gt;ipid);</span>
<span class="lineNum">    2933 </span>            :                 assert(idx&gt;0);
<span class="lineNum">    2934 </span><span class="lineNoCov">          0 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_MULTI_PID, &amp;PROP_POINTER(multi_pids) );</span>
<span class="lineNum">    2935 </span><span class="lineNoCov">          0 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_MULTI_PID_IDX, &amp;PROP_UINT(idx) );</span>
<span class="lineNum">    2936 </span>            :         }
<span class="lineNum">    2937 </span>            : 
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span><span class="lineCov">        355 :         if (ds-&gt;tile_base &amp;&amp; !ctx-&gt;sseg &amp;&amp; !ctx-&gt;sfile) {</span>
<span class="lineNum">    2940 </span><span class="lineCov">          3 :                 u32 i, count = gf_list_count(ds-&gt;complementary_streams);</span>
<span class="lineNum">    2941 </span><span class="lineCov">          3 :                 if (!ds-&gt;multi_tracks) ds-&gt;multi_tracks = gf_list_new();</span>
<span class="lineNum">    2942 </span><span class="lineCov">          3 :                 gf_list_reset(ds-&gt;multi_tracks);</span>
<span class="lineNum">    2943 </span>            : 
<span class="lineNum">    2944 </span>            :                 //gather all streams depending on our base
<span class="lineNum">    2945 </span><span class="lineCov">         30 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    2946 </span><span class="lineCov">         27 :                         GF_DashStream *a_ds = gf_list_get(ds-&gt;complementary_streams, i);</span>
<span class="lineNum">    2947 </span>            :                         assert(a_ds-&gt;opid);
<span class="lineNum">    2948 </span><span class="lineCov">         27 :                         gf_list_add(ds-&gt;multi_tracks, a_ds-&gt;opid);</span>
<span class="lineNum">    2949 </span>            :                 }
<span class="lineNum">    2950 </span><span class="lineCov">          3 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_MULTI_TRACK, &amp;PROP_POINTER(ds-&gt;multi_tracks) );</span>
<span class="lineNum">    2951 </span>            :         }
<span class="lineNum">    2952 </span><span class="lineCov">        355 :         if (ds-&gt;dep_id &amp;&amp; !init_trashed) {</span>
<span class="lineNum">    2953 </span><span class="lineCov">          3 :                 if (!ds-&gt;multi_tracks) ds-&gt;multi_tracks = gf_list_new();</span>
<span class="lineNum">    2954 </span><span class="lineCov">          3 :                 gf_list_reset(ds-&gt;multi_tracks);</span>
<span class="lineNum">    2955 </span><span class="lineCov">          3 :                 dasher_gather_deps(ctx, ds-&gt;dep_id, ds-&gt;multi_tracks);</span>
<span class="lineNum">    2956 </span><span class="lineCov">          3 :                 if (gf_list_count(ds-&gt;multi_tracks)) {</span>
<span class="lineNum">    2957 </span><span class="lineCov">          3 :                         gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_DASH_MULTI_TRACK, &amp;PROP_POINTER(ds-&gt;multi_tracks) );</span>
<span class="lineNum">    2958 </span>            :                 } else {
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :                         gf_list_del(ds-&gt;multi_tracks);</span>
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :                         ds-&gt;multi_tracks = NULL;</span>
<span class="lineNum">    2961 </span>            :                 }
<span class="lineNum">    2962 </span>            :         }
<span class="lineNum">    2963 </span>            : 
<span class="lineNum">    2964 </span><span class="lineCov">        355 :         if (ctx-&gt;llhls) {</span>
<span class="lineNum">    2965 </span><span class="lineCov">         12 :                 gf_filter_pid_set_property(ds-&gt;opid, GF_PROP_PID_LLHLS, &amp;PROP_UINT(ctx-&gt;llhls) );</span>
<span class="lineNum">    2966 </span>            :         }
<a name="2967"><span class="lineNum">    2967 </span>            : }</a>
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span><span class="lineCov">        880 : static Bool dasher_template_use_source_url(const char *template)</span>
<span class="lineNum">    2970 </span>            : {
<span class="lineNum">    2971 </span><span class="lineCov">        880 :         if (strstr(template, &quot;$File$&quot;) != NULL) return GF_TRUE;</span>
<span class="lineNum">    2972 </span><span class="lineCov">        111 :         else if (strstr(template, &quot;$FSRC$&quot;) != NULL) return GF_TRUE;</span>
<span class="lineNum">    2973 </span><span class="lineCov">        111 :         else if (strstr(template, &quot;$SourcePath$&quot;) != NULL) return GF_TRUE;</span>
<span class="lineNum">    2974 </span><span class="lineCov">        111 :         else if (strstr(template, &quot;$FURL$&quot;) != NULL) return GF_TRUE;</span>
<span class="lineNum">    2975 </span><span class="lineCov">        111 :         else if (strstr(template, &quot;$URL$&quot;) != NULL) return GF_TRUE;</span>
<span class="lineNum">    2976 </span><span class="lineCov">        111 :         return GF_FALSE;</span>
<a name="2977"><span class="lineNum">    2977 </span>            : }</a>
<span class="lineNum">    2978 </span>            : 
<span class="lineNum">    2979 </span><span class="lineCov">         19 : static void dasher_set_content_components(GF_DashStream *ds)</span>
<span class="lineNum">    2980 </span>            : {
<span class="lineNum">    2981 </span>            :         GF_MPD_ContentComponent *component;
<span class="lineNum">    2982 </span><span class="lineCov">         19 :         GF_DashStream *base_ds = ds-&gt;muxed_base ? ds-&gt;muxed_base : ds;</span>
<span class="lineNum">    2983 </span>            : 
<span class="lineNum">    2984 </span><span class="lineCov">         19 :         GF_SAFEALLOC(component, GF_MPD_ContentComponent);</span>
<span class="lineNum">    2985 </span><span class="lineCov">         19 :         if (!component) return;</span>
<span class="lineNum">    2986 </span>            : 
<span class="lineNum">    2987 </span><span class="lineCov">         19 :         component-&gt;id = ds-&gt;pid_id;</span>
<span class="lineNum">    2988 </span><span class="lineCov">         19 :         switch (ds-&gt;stream_type) {</span>
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :         case GF_STREAM_TEXT:</span>
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :                 component-&gt;type = gf_strdup(&quot;text&quot;);</span>
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2992 </span><span class="lineCov">         12 :         case GF_STREAM_VISUAL:</span>
<span class="lineNum">    2993 </span><span class="lineCov">         12 :                 component-&gt;type = gf_strdup(&quot;video&quot;);</span>
<span class="lineNum">    2994 </span><span class="lineCov">         12 :                 break;</span>
<span class="lineNum">    2995 </span><span class="lineCov">          7 :         case GF_STREAM_AUDIO:</span>
<span class="lineNum">    2996 </span><span class="lineCov">          7 :                 component-&gt;type = gf_strdup(&quot;audio&quot;);</span>
<span class="lineNum">    2997 </span><span class="lineCov">          7 :                 break;</span>
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :         case GF_STREAM_SCENE:</span>
<span class="lineNum">    2999 </span>            :         case GF_STREAM_OD:
<span class="lineNum">    3000 </span>            :         default:
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :                 component-&gt;type = gf_strdup(&quot;application&quot;);</span>
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3003 </span>            :         }
<span class="lineNum">    3004 </span>            :         /*if lang not specified at adaptationSet level, put it here*/
<span class="lineNum">    3005 </span><span class="lineCov">         19 :         if (!base_ds-&gt;set-&gt;lang &amp;&amp; ds-&gt;lang &amp;&amp; strcmp(ds-&gt;lang, &quot;und&quot;)) {</span>
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :                 component-&gt;lang = gf_strdup(ds-&gt;lang);</span>
<span class="lineNum">    3007 </span>            :         }
<span class="lineNum">    3008 </span><span class="lineCov">         19 :         gf_list_add(base_ds-&gt;set-&gt;content_component, component);</span>
<span class="lineNum">    3009 </span>            : }
<span class="lineNum">    3010 </span>            : 
<span class="lineNum">    3011 </span>            : typedef struct
<span class="lineNum">    3012 </span>            : {
<span class="lineNum">    3013 </span>            :         char *tpl;
<span class="lineNum">    3014 </span>            :         u32 nb_reused;
<a name="3015"><span class="lineNum">    3015 </span>            : } DashTemplateRecord;</a>
<span class="lineNum">    3016 </span>            : 
<span class="lineNum">    3017 </span><span class="lineCov">        346 : static u32 dasher_check_template_reuse(GF_DasherCtx *ctx, const char *tpl)</span>
<span class="lineNum">    3018 </span>            : {
<span class="lineNum">    3019 </span>            :         DashTemplateRecord *tr;
<span class="lineNum">    3020 </span><span class="lineCov">        346 :         u32 i, count = gf_list_count(ctx-&gt;tpl_records);</span>
<span class="lineNum">    3021 </span><span class="lineCov">        362 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3022 </span><span class="lineCov">        362 :                 tr = gf_list_get(ctx-&gt;tpl_records, i);</span>
<span class="lineNum">    3023 </span><span class="lineCov">        362 :                 if (!strcmp(tr-&gt;tpl, tpl)) {</span>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :                         tr-&gt;nb_reused++;</span>
<span class="lineNum">    3025 </span>            :                         return tr-&gt;nb_reused;
<span class="lineNum">    3026 </span>            :                 }
<span class="lineNum">    3027 </span>            :         }
<span class="lineNum">    3028 </span><span class="lineCov">        346 :         GF_SAFEALLOC(tr, DashTemplateRecord)</span>
<span class="lineNum">    3029 </span><span class="lineCov">        346 :         tr-&gt;tpl = gf_strdup(tpl);</span>
<span class="lineNum">    3030 </span><span class="lineCov">        346 :         gf_list_add(ctx-&gt;tpl_records, tr);</span>
<span class="lineNum">    3031 </span>            :         return 0;
<a name="3032"><span class="lineNum">    3032 </span>            : }</a>
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span><span class="lineCov">        317 : static void dasher_setup_sources(GF_Filter *filter, GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)</span>
<span class="lineNum">    3035 </span>            : {
<span class="lineNum">    3036 </span>            :         char szDASHTemplate[GF_MAX_PATH];
<span class="lineNum">    3037 </span>            :         char szTemplate[GF_MAX_PATH];
<span class="lineNum">    3038 </span>            :         char szSegmentName[GF_MAX_PATH];
<span class="lineNum">    3039 </span>            :         char szInitSegmentTemplate[GF_MAX_PATH];
<span class="lineNum">    3040 </span>            :         char szInitSegmentFilename[GF_MAX_PATH];
<span class="lineNum">    3041 </span>            :         char szIndexSegmentName[GF_MAX_PATH];
<span class="lineNum">    3042 </span>            :         char szSetFileSuffix[200], szDASHSuffix[220];
<span class="lineNum">    3043 </span>            :         const char *template = NULL;
<span class="lineNum">    3044 </span>            :         u32 as_id = 0;
<span class="lineNum">    3045 </span>            :         Bool single_template = GF_TRUE;
<span class="lineNum">    3046 </span>            :         u32 i, j, count, nb_base, nb_streams;
<span class="lineNum">    3047 </span>            :         GF_List *multi_pids = NULL;
<span class="lineNum">    3048 </span>            :         u32 set_timescale = 0;
<span class="lineNum">    3049 </span>            :         Bool init_template_done=GF_FALSE;
<span class="lineNum">    3050 </span><span class="lineCov">        317 :         Bool use_inband = (ctx-&gt;bs_switch==DASHER_BS_SWITCH_INBAND) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    3051 </span>            :         Bool template_use_source = GF_FALSE;
<span class="lineNum">    3052 </span>            :         Bool split_rep_names = GF_FALSE;
<span class="lineNum">    3053 </span>            :         Bool split_set_names = GF_FALSE;
<span class="lineNum">    3054 </span>            :         u32 force_ds_id;
<span class="lineNum">    3055 </span>            :         GF_DashStream *ds;
<span class="lineNum">    3056 </span><span class="lineCov">        317 :         GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, 0);</span>
<span class="lineNum">    3057 </span><span class="lineCov">        317 :         if (!rep) {</span>
<span class="lineNum">    3058 </span>            :                 assert(0);
<span class="lineNum">    3059 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3060 </span>            :         }
<span class="lineNum">    3061 </span><span class="lineCov">        317 :         ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3062 </span>            : 
<span class="lineNum">    3063 </span><span class="lineCov">        317 :         count = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    3064 </span>            : 
<span class="lineNum">    3065 </span><span class="lineCov">        317 :         if (!ctx-&gt;sigfrag) {</span>
<span class="lineNum">    3066 </span>            :                 assert(ctx-&gt;template);
<span class="lineNum">    3067 </span><span class="lineCov">        311 :                 template = ((GF_DashStream *)set-&gt;udta)-&gt;template;</span>
<span class="lineNum">    3068 </span>            :         }
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span><span class="lineCov">        673 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3071 </span><span class="lineCov">        356 :                 rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    3072 </span><span class="lineCov">        356 :                 ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3073 </span><span class="lineCov">        356 :                 if (!ds-&gt;template &amp;&amp; !template) {}</span>
<span class="lineNum">    3074 </span><span class="lineCov">         27 :                 else if (ds-&gt;template &amp;&amp; template &amp;&amp; !strcmp(ds-&gt;template, template) ) {</span>
<span class="lineNum">    3075 </span>            :                 } else {
<span class="lineNum">    3076 </span>            :                         single_template = GF_FALSE;
<span class="lineNum">    3077 </span>            :                 }
<span class="lineNum">    3078 </span><span class="lineCov">        356 :                 if (ds-&gt;template) template_use_source = dasher_template_use_source_url(ds-&gt;template);</span>
<span class="lineNum">    3079 </span>            : 
<span class="lineNum">    3080 </span><span class="lineCov">        356 :                 if (template_use_source) {</span>
<span class="lineNum">    3081 </span>            :                         single_template = GF_FALSE;
<span class="lineNum">    3082 </span>            :                 }
<span class="lineNum">    3083 </span>            : 
<span class="lineNum">    3084 </span><span class="lineCov">        356 :                 if (ds-&gt;as_id &amp;&amp; !as_id)</span>
<span class="lineNum">    3085 </span>            :                         as_id = ds-&gt;as_id;
<span class="lineNum">    3086 </span>            : 
<span class="lineNum">    3087 </span><span class="lineCov">        356 :                 if (ds-&gt;fps.den &amp;&amp; ( (ds-&gt;fps.num*set-&gt;max_framerate.den) &gt;= (s32) (set-&gt;max_framerate.num*ds-&gt;fps.den) )) {</span>
<span class="lineNum">    3088 </span><span class="lineCov">        241 :                         set-&gt;max_framerate.num = ds-&gt;fps.num;</span>
<span class="lineNum">    3089 </span><span class="lineCov">        241 :                         set-&gt;max_framerate.den = ds-&gt;fps.den;</span>
<span class="lineNum">    3090 </span><span class="lineCov">        241 :                         gf_media_get_reduced_frame_rate(&amp;set-&gt;max_framerate.num, &amp;set-&gt;max_framerate.den);</span>
<span class="lineNum">    3091 </span>            :                 }
<span class="lineNum">    3092 </span><span class="lineCov">        356 :                 if (ds-&gt;width &amp;&amp; ds-&gt;height) {</span>
<span class="lineNum">    3093 </span><span class="lineCov">        265 :                         if (!set-&gt;par) {</span>
<span class="lineNum">    3094 </span><span class="lineNoCov">          0 :                                 GF_SAFEALLOC(set-&gt;par, GF_MPD_Fractional);</span>
<span class="lineNum">    3095 </span>            :                         }
<span class="lineNum">    3096 </span><span class="lineCov">        265 :                         if (set-&gt;par) {</span>
<span class="lineNum">    3097 </span><span class="lineCov">        265 :                                 set-&gt;par-&gt;num = ds-&gt;width;</span>
<span class="lineNum">    3098 </span><span class="lineCov">        265 :                                 set-&gt;par-&gt;den = ds-&gt;height;</span>
<span class="lineNum">    3099 </span><span class="lineCov">        265 :                                 gf_media_reduce_aspect_ratio(&amp;set-&gt;par-&gt;num, &amp;set-&gt;par-&gt;den);</span>
<span class="lineNum">    3100 </span>            :                         }
<span class="lineNum">    3101 </span>            :                 }
<span class="lineNum">    3102 </span>            :         }
<span class="lineNum">    3103 </span><span class="lineCov">        317 :         if (!template) template = ctx-&gt;template;</span>
<span class="lineNum">    3104 </span>            : 
<span class="lineNum">    3105 </span><span class="lineCov">        317 :         if (as_id) {</span>
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 :                 set-&gt;id = ds-&gt;as_id;</span>
<span class="lineNum">    3107 </span>            :         }
<span class="lineNum">    3108 </span><span class="lineCov">        317 :         if (ctx-&gt;sseg) {</span>
<span class="lineNum">    3109 </span><span class="lineCov">         21 :                 set-&gt;segment_alignment = GF_TRUE;</span>
<span class="lineNum">    3110 </span><span class="lineCov">         21 :                 set-&gt;starts_with_sap = 1;</span>
<span class="lineNum">    3111 </span>            :         }
<span class="lineNum">    3112 </span>            : 
<span class="lineNum">    3113 </span><span class="lineCov">        317 :         if (count==1)</span>
<span class="lineNum">    3114 </span>            :                 single_template = GF_TRUE;
<span class="lineNum">    3115 </span><span class="lineCov">         38 :         else if (single_template) {</span>
<span class="lineNum">    3116 </span>            :                 //for regular reps, if we depend on filename we cannot mutualize the template
<span class="lineNum">    3117 </span><span class="lineCov">         32 :                 if (dasher_template_use_source_url(template) ) {</span>
<span class="lineNum">    3118 </span>            :                         single_template = GF_FALSE;
<span class="lineNum">    3119 </span>            :                 }
<span class="lineNum">    3120 </span>            :                 //and for scalable reps, if we don't have bandwidth /repID we cannot mutualize the template
<span class="lineNum">    3121 </span><span class="lineCov">          3 :                 else if (gf_list_count(ds-&gt;complementary_streams) ) {</span>
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :                         if (strstr(template, &quot;$Bandwidth$&quot;) != NULL) single_template = GF_FALSE;</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :                         else if (strstr(template, &quot;$RepresentationId$&quot;) != NULL) single_template = GF_FALSE;</span>
<span class="lineNum">    3124 </span>            :                 }
<span class="lineNum">    3125 </span>            :         }
<span class="lineNum">    3126 </span>            : 
<span class="lineNum">    3127 </span><span class="lineCov">        317 :         if (set-&gt;lang) gf_free(set-&gt;lang);</span>
<span class="lineNum">    3128 </span><span class="lineCov">        317 :         set-&gt;lang = gf_strdup(ds-&gt;lang ? ds-&gt;lang : &quot;und&quot;);</span>
<span class="lineNum">    3129 </span>            : 
<span class="lineNum">    3130 </span>            :         //check all streams in active period not in this set
<span class="lineNum">    3131 </span><span class="lineCov">        317 :         force_ds_id = ds-&gt;id;</span>
<span class="lineNum">    3132 </span><span class="lineCov">        317 :         nb_streams = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    3133 </span><span class="lineCov">        763 :         for (i=0; i&lt;nb_streams; i++) {</span>
<span class="lineNum">    3134 </span>            :                 char *frag_uri;
<span class="lineNum">    3135 </span>            :                 u32 len1, len2;
<span class="lineNum">    3136 </span><span class="lineCov">        522 :                 GF_DashStream *ads = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span><span class="lineCov">        522 :                 if (force_ds_id &amp;&amp; (ads != ds) &amp;&amp; (ads-&gt;id == ds-&gt;id)) {</span>
<span class="lineNum">    3139 </span>            :                         force_ds_id = 0;
<span class="lineNum">    3140 </span>            :                 }
<span class="lineNum">    3141 </span>            : 
<span class="lineNum">    3142 </span><span class="lineCov">        522 :                 if (ads-&gt;set == set) continue;</span>
<span class="lineNum">    3143 </span><span class="lineCov">        217 :                 frag_uri = strrchr(ds-&gt;src_url, '#');</span>
<span class="lineNum">    3144 </span><span class="lineCov">        217 :                 if (frag_uri) len1 = (u32) (frag_uri-1 - ds-&gt;src_url);</span>
<span class="lineNum">    3145 </span><span class="lineCov">        217 :                 else len1 = (u32) strlen(ds-&gt;src_url);</span>
<span class="lineNum">    3146 </span><span class="lineCov">        217 :                 frag_uri = strrchr(ads-&gt;src_url, '#');</span>
<span class="lineNum">    3147 </span><span class="lineCov">        217 :                 if (frag_uri) len2 = (u32) (frag_uri-1 - ads-&gt;src_url);</span>
<span class="lineNum">    3148 </span><span class="lineCov">        217 :                 else len2 = (u32) strlen(ads-&gt;src_url);</span>
<span class="lineNum">    3149 </span>            : 
<span class="lineNum">    3150 </span><span class="lineCov">        217 :                 if ((len1==len2) &amp;&amp; !strncmp(ds-&gt;src_url, ads-&gt;src_url, len1)) {</span>
<span class="lineNum">    3151 </span>            :                         split_set_names = GF_TRUE;
<span class="lineNum">    3152 </span>            :                         break;
<span class="lineNum">    3153 </span>            :                 }
<span class="lineNum">    3154 </span>            :         }
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span><span class="lineCov">        317 :         if (ctx-&gt;timescale&gt;0) {</span>
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :                 set_timescale = ctx-&gt;timescale;</span>
<span class="lineNum">    3158 </span>            :         } else {
<span class="lineNum">    3159 </span>            :                 u32 first_timescale;
<span class="lineNum">    3160 </span><span class="lineCov">        317 :                 rep = gf_list_get(set-&gt;representations, 0);</span>
<span class="lineNum">    3161 </span><span class="lineCov">        317 :                 ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3162 </span><span class="lineCov">        317 :                 first_timescale = ds-&gt;timescale;</span>
<span class="lineNum">    3163 </span><span class="lineCov">        351 :                 for (i=1; i&lt;count; i++) {</span>
<span class="lineNum">    3164 </span><span class="lineCov">         39 :                         rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    3165 </span><span class="lineCov">         39 :                         ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3166 </span><span class="lineCov">         39 :                         if (ds-&gt;timescale != first_timescale) {</span>
<span class="lineNum">    3167 </span>            :                                 //we cannot use a single template if enforcing timescales which are not identical
<span class="lineNum">    3168 </span>            :                                 single_template = GF_FALSE;
<span class="lineNum">    3169 </span>            :                                 break;
<span class="lineNum">    3170 </span>            :                         }
<span class="lineNum">    3171 </span>            :                 }
<span class="lineNum">    3172 </span>            :         }
<span class="lineNum">    3173 </span>            : 
<span class="lineNum">    3174 </span><span class="lineCov">        655 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3175 </span><span class="lineCov">        350 :                 if (ctx-&gt;sigfrag)</span>
<span class="lineNum">    3176 </span>            :                         break;
<span class="lineNum">    3177 </span>            : 
<span class="lineNum">    3178 </span><span class="lineCov">        344 :                 rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    3179 </span><span class="lineCov">        344 :                 ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3180 </span>            : 
<span class="lineNum">    3181 </span><span class="lineCov">        344 :                 if (!dasher_template_use_source_url(template))</span>
<span class="lineNum">    3182 </span><span class="lineCov">         45 :                         continue;</span>
<span class="lineNum">    3183 </span>            : 
<span class="lineNum">    3184 </span><span class="lineCov">        299 :                 if (ds-&gt;muxed_base)</span>
<span class="lineNum">    3185 </span><span class="lineCov">          8 :                         continue;</span>
<span class="lineNum">    3186 </span>            : 
<span class="lineNum">    3187 </span><span class="lineCov">        315 :                 for (j=i+1; j&lt;count; j++) {</span>
<span class="lineNum">    3188 </span>            :                         const GF_PropertyValue *p1, *p2;
<span class="lineNum">    3189 </span>            :                         GF_DashStream *a_ds;
<span class="lineNum">    3190 </span><span class="lineCov">         30 :                         rep = gf_list_get(set-&gt;representations, j);</span>
<span class="lineNum">    3191 </span><span class="lineCov">         30 :                         a_ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3192 </span>            : 
<span class="lineNum">    3193 </span><span class="lineCov">         30 :                         if (a_ds-&gt;muxed_base == ds)</span>
<span class="lineNum">    3194 </span><span class="lineCov">          8 :                                 continue;</span>
<span class="lineNum">    3195 </span>            : 
<span class="lineNum">    3196 </span><span class="lineCov">         22 :                         p1 = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">    3197 </span><span class="lineCov">         22 :                         p2 = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">    3198 </span><span class="lineCov">         22 :                         if (p1 &amp;&amp; p2 &amp;&amp; gf_props_equal(p1, p2)) split_rep_names = GF_TRUE;</span>
<span class="lineNum">    3199 </span><span class="lineCov">         16 :                         else if (!p1 &amp;&amp; !p2) split_rep_names = GF_TRUE;</span>
<span class="lineNum">    3200 </span><span class="lineCov">         22 :                         p1 = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_URL);</span>
<span class="lineNum">    3201 </span><span class="lineCov">         22 :                         p2 = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_URL);</span>
<span class="lineNum">    3202 </span><span class="lineCov">         22 :                         if (p1 &amp;&amp; p2 &amp;&amp; gf_props_equal(p1, p2)) split_rep_names = GF_TRUE;</span>
<span class="lineNum">    3203 </span><span class="lineCov">         16 :                         else if (!p1 &amp;&amp; !p2) split_rep_names = GF_TRUE;</span>
<span class="lineNum">    3204 </span>            : 
<span class="lineNum">    3205 </span><span class="lineCov">         16 :                         if (split_rep_names) break;</span>
<span class="lineNum">    3206 </span>            :                 }
<span class="lineNum">    3207 </span><span class="lineCov">        291 :                 if (split_rep_names) break;</span>
<span class="lineNum">    3208 </span>            :         }
<span class="lineNum">    3209 </span>            : 
<span class="lineNum">    3210 </span><span class="lineCov">        317 :         if (split_set_names) {</span>
<span class="lineNum">    3211 </span><span class="lineCov">         76 :                 if (!force_ds_id) {</span>
<span class="lineNum">    3212 </span><span class="lineCov">         17 :                         if (split_rep_names || !ds-&gt;split_set_names)</span>
<span class="lineNum">    3213 </span><span class="lineCov">         11 :                                 force_ds_id = ds-&gt;id;</span>
<span class="lineNum">    3214 </span>            :                         else
<span class="lineNum">    3215 </span><span class="lineCov">          6 :                                 force_ds_id = gf_list_find(ctx-&gt;pids, ds) + 1;</span>
<span class="lineNum">    3216 </span>            :                 }
<span class="lineNum">    3217 </span>            :                 sprintf(szSetFileSuffix, &quot;_track%d_&quot;, force_ds_id);
<span class="lineNum">    3218 </span>            :         }
<span class="lineNum">    3219 </span>            : 
<span class="lineNum">    3220 </span>            :         //assign PID IDs - we assume only one component of a given media type per adaptation set
<span class="lineNum">    3221 </span>            :         //and assign the same PID ID for each component of the same type
<span class="lineNum">    3222 </span>            :         //we could refine this using roles, but most HAS solutions don't use roles at the mulitplexed level
<span class="lineNum">    3223 </span><span class="lineCov">        356 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3224 </span>            :                 Bool is_bs_switching;
<span class="lineNum">    3225 </span><span class="lineCov">        356 :                 rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    3226 </span><span class="lineCov">        356 :                 ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3227 </span><span class="lineCov">        356 :                 if (ds-&gt;pid_id) continue;</span>
<span class="lineNum">    3228 </span>            :                 //in bitstream switching mode, ensure each track in the set has the same ID
<span class="lineNum">    3229 </span>            :                 //except when tile merge is used
<span class="lineNum">    3230 </span><span class="lineCov">        351 :                 is_bs_switching = ds-&gt;tile_dep_id_merged ? GF_FALSE : set-&gt;bitstream_switching;</span>
<span class="lineNum">    3231 </span><span class="lineCov">        342 :                 if (is_bs_switching) {</span>
<span class="lineNum">    3232 </span><span class="lineCov">         28 :                         ctx-&gt;next_pid_id_in_period++;</span>
<span class="lineNum">    3233 </span><span class="lineCov">         28 :                         ds-&gt;pid_id = ctx-&gt;next_pid_id_in_period;</span>
<span class="lineNum">    3234 </span>            : 
<span class="lineNum">    3235 </span><span class="lineCov">         45 :                         for (j=i+1; j&lt;count; j++) {</span>
<span class="lineNum">    3236 </span>            :                                 GF_DashStream *a_ds;
<span class="lineNum">    3237 </span><span class="lineCov">         17 :                                 rep = gf_list_get(set-&gt;representations, j);</span>
<span class="lineNum">    3238 </span><span class="lineCov">         17 :                                 a_ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3239 </span><span class="lineCov">         17 :                                 if (a_ds-&gt;pid_id) continue;</span>
<span class="lineNum">    3240 </span><span class="lineCov">         17 :                                 if (a_ds-&gt;dep_id) continue;</span>
<span class="lineNum">    3241 </span><span class="lineCov">          8 :                                 if (a_ds-&gt;stream_type == ds-&gt;stream_type) a_ds-&gt;pid_id = ds-&gt;pid_id;</span>
<span class="lineNum">    3242 </span>            :                         }
<span class="lineNum">    3243 </span>            :                 }
<span class="lineNum">    3244 </span>            :                 //otherwise copy over the source PID
<span class="lineNum">    3245 </span>            :                 else {
<span class="lineNum">    3246 </span><span class="lineCov">        323 :                         ds-&gt;pid_id = ds-&gt;id;</span>
<span class="lineNum">    3247 </span>            :                 }
<span class="lineNum">    3248 </span>            :         }
<span class="lineNum">    3249 </span>            : 
<span class="lineNum">    3250 </span><span class="lineCov">        356 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3251 </span><span class="lineCov">        356 :                 rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    3252 </span><span class="lineCov">        356 :                 ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3253 </span><span class="lineCov">        356 :                 if (!ds-&gt;dep_id) continue;</span>
<span class="lineNum">    3254 </span>            : 
<span class="lineNum">    3255 </span><span class="lineCov">         49 :                 for (j=i+1; j&lt;count; j++) {</span>
<span class="lineNum">    3256 </span>            :                         GF_DashStream *a_ds;
<span class="lineNum">    3257 </span><span class="lineCov">         10 :                         rep = gf_list_get(set-&gt;representations, j);</span>
<span class="lineNum">    3258 </span><span class="lineCov">         10 :                         a_ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3259 </span><span class="lineCov">         10 :                         if (ds-&gt;dep_id == a_ds-&gt;id) {</span>
<span class="lineNum">    3260 </span><span class="lineNoCov">          0 :                                 ds-&gt;dep_pid_id = a_ds-&gt;pid_id;</span>
<span class="lineNum">    3261 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    3262 </span>            :                         }
<span class="lineNum">    3263 </span>            :                 }
<span class="lineNum">    3264 </span>            :         }
<span class="lineNum">    3265 </span>            : 
<span class="lineNum">    3266 </span>            :         //this is crude because we don't copy the properties, we just pass a list of pids to the destination muxer !!
<span class="lineNum">    3267 </span>            :         //we should cleanup one of these days
<span class="lineNum">    3268 </span><span class="lineCov">        317 :         if (set-&gt;bitstream_switching &amp;&amp; (ctx-&gt;bs_switch==DASHER_BS_SWITCH_MULTI)) {</span>
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :                 multi_pids = gf_list_new();</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3271 </span><span class="lineNoCov">          0 :                         rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :                         ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 :                         if (ds-&gt;owns_set) ds-&gt;multi_pids = multi_pids;</span>
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 :                         gf_list_add(multi_pids, ds-&gt;ipid);</span>
<span class="lineNum">    3275 </span>            :                 }
<span class="lineNum">    3276 </span>            :         }
<span class="lineNum">    3277 </span>            : 
<span class="lineNum">    3278 </span><span class="lineCov">        317 :         if (ctx-&gt;cp!=GF_DASH_CPMODE_REPRESENTATION) {</span>
<span class="lineNum">    3279 </span><span class="lineCov">        317 :                 gf_mpd_del_list(set-&gt;content_protection, gf_mpd_descriptor_free, 0);</span>
<span class="lineNum">    3280 </span><span class="lineCov">        317 :                 set-&gt;content_protection = dasher_get_content_protection_desc(ctx, NULL, set);</span>
<span class="lineNum">    3281 </span>            :         }
<span class="lineNum">    3282 </span>            : 
<span class="lineNum">    3283 </span><span class="lineCov">        356 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3284 </span>            :                 GF_Err e;
<span class="lineNum">    3285 </span>            :                 char szRawExt[20];
<span class="lineNum">    3286 </span>            :                 Bool use_dash_suffix = GF_FALSE;
<span class="lineNum">    3287 </span>            :                 const char *seg_ext, *init_ext, *idx_ext, *force_init_seg_tpl;
<span class="lineNum">    3288 </span>            : #if 0
<span class="lineNum">    3289 </span>            :                 GF_MPD_URL *force_init_seg_sl;
<span class="lineNum">    3290 </span>            : #endif
<span class="lineNum">    3291 </span>            :                 Bool skip_init = GF_FALSE;
<span class="lineNum">    3292 </span>            :                 GF_DashStream *tile_base_ds = NULL;
<span class="lineNum">    3293 </span>            :                 Bool is_bs_switch;
<span class="lineNum">    3294 </span>            :                 u32 reused_template_idx;
<span class="lineNum">    3295 </span>            :                 u32 init_template_mode = GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE;
<span class="lineNum">    3296 </span><span class="lineCov">        356 :                 rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    3297 </span><span class="lineCov">        356 :                 ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    3298 </span>            : 
<span class="lineNum">    3299 </span>            :                 //remove representations for streams muxed with others, but still open the output
<span class="lineNum">    3300 </span><span class="lineCov">        356 :                 if (ds-&gt;muxed_base) {</span>
<span class="lineNum">    3301 </span><span class="lineCov">         10 :                         GF_DashStream *ds_set = set-&gt;udta;</span>
<span class="lineNum">    3302 </span><span class="lineCov">         10 :                         gf_list_rem(set-&gt;representations, i);</span>
<span class="lineNum">    3303 </span><span class="lineCov">         10 :                         i--;</span>
<span class="lineNum">    3304 </span><span class="lineCov">         10 :                         count--;</span>
<span class="lineNum">    3305 </span>            :                         assert(ds_set-&gt;nb_rep);
<span class="lineNum">    3306 </span><span class="lineCov">         10 :                         ds_set-&gt;nb_rep--;</span>
<span class="lineNum">    3307 </span>            :                         assert(ds-&gt;muxed_base-&gt;dst_filter);
<span class="lineNum">    3308 </span><span class="lineCov">         10 :                         gf_list_transfer(ds-&gt;muxed_base-&gt;rep-&gt;audio_channels, rep-&gt;audio_channels);</span>
<span class="lineNum">    3309 </span><span class="lineCov">         10 :                         gf_list_transfer(ds-&gt;muxed_base-&gt;rep-&gt;base_URLs, rep-&gt;base_URLs);</span>
<span class="lineNum">    3310 </span><span class="lineCov">         10 :                         gf_list_transfer(ds-&gt;muxed_base-&gt;rep-&gt;content_protection , rep-&gt;content_protection);</span>
<span class="lineNum">    3311 </span><span class="lineCov">         10 :                         gf_list_transfer(ds-&gt;muxed_base-&gt;rep-&gt;essential_properties , rep-&gt;essential_properties);</span>
<span class="lineNum">    3312 </span><span class="lineCov">         10 :                         gf_list_transfer(ds-&gt;muxed_base-&gt;rep-&gt;frame_packing , rep-&gt;frame_packing);</span>
<span class="lineNum">    3313 </span><span class="lineCov">         10 :                         if (rep-&gt;x_children) {</span>
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 :                                 if (!ds-&gt;muxed_base-&gt;rep-&gt;x_children) ds-&gt;muxed_base-&gt;rep-&gt;x_children = gf_list_new();</span>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 :                                 gf_list_transfer(ds-&gt;muxed_base-&gt;rep-&gt;x_children, rep-&gt;x_children);</span>
<span class="lineNum">    3316 </span>            :                         }
<span class="lineNum">    3317 </span><span class="lineCov">         10 :                         gf_list_transfer(ds-&gt;muxed_base-&gt;rep-&gt;supplemental_properties , rep-&gt;supplemental_properties);</span>
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span><span class="lineCov">         10 :                         gf_mpd_representation_free(ds-&gt;rep);</span>
<span class="lineNum">    3320 </span><span class="lineCov">         10 :                         ds-&gt;rep = NULL;</span>
<span class="lineNum">    3321 </span>            : 
<span class="lineNum">    3322 </span><span class="lineCov">         10 :                         if (!gf_list_count(ds-&gt;set-&gt;content_component)) {</span>
<span class="lineNum">    3323 </span><span class="lineCov">          9 :                                 dasher_set_content_components(ds-&gt;muxed_base);</span>
<span class="lineNum">    3324 </span>            :                         }
<span class="lineNum">    3325 </span><span class="lineCov">         10 :                         dasher_set_content_components(ds);</span>
<span class="lineNum">    3326 </span>            :                         assert(!multi_pids);
<span class="lineNum">    3327 </span>            :                         //open PID
<span class="lineNum">    3328 </span><span class="lineCov">         10 :                         dasher_open_pid(filter, ctx, ds, NULL, GF_FALSE);</span>
<span class="lineNum">    3329 </span><span class="lineCov">         20 :                         continue;</span>
<span class="lineNum">    3330 </span>            :                 }
<span class="lineNum">    3331 </span><span class="lineCov">        346 :                 if (ds-&gt;template) strcpy(szTemplate, ds-&gt;template);</span>
<span class="lineNum">    3332 </span><span class="lineCov">        319 :                 else strcpy(szTemplate, ctx-&gt;template ? ctx-&gt;template : &quot;&quot;);</span>
<span class="lineNum">    3333 </span>            : 
<span class="lineNum">    3334 </span><span class="lineCov">        346 :                 if (use_inband)</span>
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 :                         ds-&gt;inband_params = GF_TRUE;</span>
<span class="lineNum">    3336 </span>            : 
<span class="lineNum">    3337 </span>            :                 //if bitstream switching and templating, only set for the first one
<span class="lineNum">    3338 </span><span class="lineCov">        346 :                 if (i &amp;&amp; set-&gt;bitstream_switching &amp;&amp; ctx-&gt;stl &amp;&amp; single_template) continue;</span>
<span class="lineNum">    3339 </span>            : 
<span class="lineNum">    3340 </span><span class="lineCov">        346 :                 if (!set_timescale) set_timescale = ds-&gt;timescale;</span>
<span class="lineNum">    3341 </span>            : 
<span class="lineNum">    3342 </span><span class="lineCov">        346 :                 if (ctx-&gt;timescale&lt;0) ds-&gt;mpd_timescale = ds-&gt;timescale;</span>
<span class="lineNum">    3343 </span><span class="lineCov">        346 :                 else ds-&gt;mpd_timescale = set_timescale;</span>
<span class="lineNum">    3344 </span>            : 
<span class="lineNum">    3345 </span><span class="lineCov">        346 :                 if (ds-&gt;nb_repeat &amp;&amp; !ctx-&gt;loop) {</span>
<span class="lineNum">    3346 </span><span class="lineCov">          6 :                         if (split_set_names) {</span>
<span class="lineNum">    3347 </span><span class="lineCov">          6 :                                 sprintf(szDASHSuffix, &quot;%sp%d_&quot;, szSetFileSuffix, ds-&gt;nb_repeat+1);</span>
<span class="lineNum">    3348 </span>            :                         } else {
<span class="lineNum">    3349 </span>            :                                 sprintf(szDASHSuffix, &quot;p%d_&quot;, ds-&gt;nb_repeat);
<span class="lineNum">    3350 </span>            :                         }
<span class="lineNum">    3351 </span>            :                         use_dash_suffix = GF_TRUE;
<span class="lineNum">    3352 </span><span class="lineCov">        340 :                 } else if (split_set_names) {</span>
<span class="lineNum">    3353 </span>            :                         strcpy(szDASHSuffix, szSetFileSuffix);
<span class="lineNum">    3354 </span>            :                         use_dash_suffix = GF_TRUE;
<span class="lineNum">    3355 </span>            :                 }
<span class="lineNum">    3356 </span>            : 
<span class="lineNum">    3357 </span>            :                 //resolve segment template
<span class="lineNum">    3358 </span><span class="lineCov">        346 :                 e = gf_filter_pid_resolve_file_template(ds-&gt;ipid, szTemplate, szDASHTemplate, 0, use_dash_suffix ? szDASHSuffix : NULL);</span>
<span class="lineNum">    3359 </span><span class="lineCov">        346 :                 if (e) {</span>
<span class="lineNum">    3360 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Cannot resolve template name %s, cannot derive output segment names, disabling rep %s\n&quot;, szTemplate, ds-&gt;src_url));</span>
<span class="lineNum">    3361 </span><span class="lineNoCov">          0 :                         gf_filter_pid_set_discard(ds-&gt;ipid, GF_TRUE);</span>
<span class="lineNum">    3362 </span><span class="lineNoCov">          0 :                         ds-&gt;done = 1;</span>
<span class="lineNum">    3363 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    3364 </span>            :                 }
<span class="lineNum">    3365 </span>            : 
<span class="lineNum">    3366 </span>            : 
<span class="lineNum">    3367 </span><span class="lineCov">        346 :                 if (single_template &amp;&amp; ds-&gt;split_set_names &amp;&amp; !use_dash_suffix) {</span>
<span class="lineNum">    3368 </span>            :                         char szStrName[20];
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :                         sprintf(szStrName, &quot;_set%d&quot;, 1 + gf_list_find(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets, set)  );</span>
<span class="lineNum">    3370 </span>            :                         strcat(szDASHTemplate, szStrName);
<span class="lineNum">    3371 </span>            :                 }
<span class="lineNum">    3372 </span><span class="lineCov">        346 :                 else if (split_rep_names) {</span>
<span class="lineNum">    3373 </span>            :                         char szStrName[20];
<span class="lineNum">    3374 </span><span class="lineCov">         12 :                         sprintf(szStrName, &quot;_rep%d&quot;, 1 + gf_list_find(set-&gt;representations, ds-&gt;rep)  );</span>
<span class="lineNum">    3375 </span>            :                         strcat(szDASHTemplate, szStrName);
<span class="lineNum">    3376 </span>            :                 }
<span class="lineNum">    3377 </span>            : 
<span class="lineNum">    3378 </span>            :                 idx_ext = NULL;
<span class="lineNum">    3379 </span><span class="lineCov">        346 :                 if (ctx-&gt;m2ts) {</span>
<span class="lineNum">    3380 </span>            :                         seg_ext = init_ext = &quot;ts&quot;;
<span class="lineNum">    3381 </span><span class="lineCov">          8 :                         if (!ctx-&gt;do_m3u8 &amp;&amp; (ctx-&gt;subs_sidx&gt;=0) )</span>
<span class="lineNum">    3382 </span>            :                                 idx_ext = &quot;idx&quot;;
<span class="lineNum">    3383 </span>            :                 } else {
<span class="lineNum">    3384 </span>            :                         const char *def_ext = NULL;
<span class="lineNum">    3385 </span>            : 
<span class="lineNum">    3386 </span>            :                         seg_ext = init_ext = NULL;
<span class="lineNum">    3387 </span>            : 
<span class="lineNum">    3388 </span><span class="lineCov">        338 :                         if (ctx-&gt;muxtype==DASHER_MUX_TS) def_ext = &quot;ts&quot;;</span>
<span class="lineNum">    3389 </span><span class="lineCov">        338 :                         else if (ctx-&gt;muxtype==DASHER_MUX_MKV) def_ext = &quot;mkv&quot;;</span>
<span class="lineNum">    3390 </span><span class="lineCov">        336 :                         else if (ctx-&gt;muxtype==DASHER_MUX_WEBM) def_ext = &quot;webm&quot;;</span>
<span class="lineNum">    3391 </span><span class="lineCov">        336 :                         else if (ctx-&gt;muxtype==DASHER_MUX_OGG) def_ext = &quot;ogg&quot;;</span>
<span class="lineNum">    3392 </span><span class="lineCov">        336 :                         else if (ctx-&gt;muxtype==DASHER_MUX_RAW) {</span>
<span class="lineNum">    3393 </span><span class="lineCov">          8 :                                 char *ext = (char *) gf_codecid_file_ext(ds-&gt;codec_id);</span>
<span class="lineNum">    3394 </span><span class="lineCov">          8 :                                 if (ds-&gt;codec_id==GF_CODECID_RAW) {</span>
<span class="lineNum">    3395 </span>            :                                         const GF_PropertyValue *p;
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :                                         if (ds-&gt;stream_type==GF_STREAM_VISUAL) {</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :                                                 p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PIXFMT);</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :                                                 if (p) ext = (char *) gf_pixel_fmt_sname(p-&gt;value.uint);</span>
<span class="lineNum">    3399 </span>            :                                         }
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :                                         else if (ds-&gt;stream_type==GF_STREAM_AUDIO) {</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :                                                 p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_AUDIO_FORMAT);</span>
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :                                                 if (p) ext = (char *) gf_audio_fmt_sname(p-&gt;value.uint);</span>
<span class="lineNum">    3403 </span>            :                                         }
<span class="lineNum">    3404 </span>            :                                 }
<span class="lineNum">    3405 </span><span class="lineCov">          8 :                                 strncpy(szRawExt, ext ? ext : &quot;raw&quot;, 19);</span>
<span class="lineNum">    3406 </span><span class="lineCov">          8 :                                 szRawExt[19] = 0;</span>
<span class="lineNum">    3407 </span><span class="lineCov">          8 :                                 ext = strchr(szRawExt, '|');</span>
<span class="lineNum">    3408 </span><span class="lineCov">          8 :                                 if (ext) ext[0] = 0;</span>
<span class="lineNum">    3409 </span>            :                                 def_ext = szRawExt;
<span class="lineNum">    3410 </span>            :                         }
<span class="lineNum">    3411 </span>            : 
<span class="lineNum">    3412 </span><span class="lineCov">        338 :                         if (ctx-&gt;segext &amp;&amp; !stricmp(ctx-&gt;segext, &quot;null&quot;)) {</span>
<span class="lineNum">    3413 </span>            :                                 seg_ext = NULL;
<span class="lineNum">    3414 </span>            :                         } else {
<span class="lineNum">    3415 </span>            :                                 seg_ext = ctx-&gt;segext;
<span class="lineNum">    3416 </span><span class="lineCov">        338 :                                 if (!seg_ext) seg_ext = def_ext ? def_ext : &quot;m4s&quot;;</span>
<span class="lineNum">    3417 </span>            :                         }
<span class="lineNum">    3418 </span><span class="lineCov">        338 :                         if (ctx-&gt;initext &amp;&amp; !stricmp(ctx-&gt;initext, &quot;null&quot;)) {</span>
<span class="lineNum">    3419 </span>            :                                 init_ext = NULL;
<span class="lineNum">    3420 </span>            :                         } else {
<span class="lineNum">    3421 </span>            :                                 init_ext = ctx-&gt;initext;
<span class="lineNum">    3422 </span><span class="lineCov">        338 :                                 if (!init_ext) init_ext = def_ext ? def_ext : &quot;mp4&quot;;</span>
<span class="lineNum">    3423 </span>            :                         }
<span class="lineNum">    3424 </span>            :                 }
<span class="lineNum">    3425 </span>            : 
<span class="lineNum">    3426 </span><span class="lineCov">        346 :                 is_bs_switch = set-&gt;bitstream_switching;</span>
<span class="lineNum">    3427 </span>            :                 //only used to force _init in default templates
<span class="lineNum">    3428 </span><span class="lineCov">        346 :                 if (ds-&gt;tile_base) is_bs_switch = GF_FALSE;</span>
<span class="lineNum">    3429 </span>            : 
<span class="lineNum">    3430 </span>            : 
<span class="lineNum">    3431 </span>            :                 //check we are not reusing an existing template from previous periods, if so append a suffix
<span class="lineNum">    3432 </span>            :                 //we check the final init name
<span class="lineNum">    3433 </span><span class="lineCov">        346 :                 if (!ds-&gt;skip_tpl_reuse) {</span>
<span class="lineNum">    3434 </span><span class="lineCov">        346 :                         gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switch, szInitSegmentFilename, ds-&gt;rep_id, NULL, szDASHTemplate, init_ext, 0, ds-&gt;bitrate, 0, ctx-&gt;stl);</span>
<span class="lineNum">    3435 </span><span class="lineCov">        346 :                         reused_template_idx = dasher_check_template_reuse(ctx, szInitSegmentFilename);</span>
<span class="lineNum">    3436 </span><span class="lineCov">        346 :                         if (reused_template_idx) {</span>
<span class="lineNum">    3437 </span>            :                                 char szExName[20];
<span class="lineNum">    3438 </span>            :                                 sprintf(szExName, &quot;_r%d_&quot;, reused_template_idx);
<span class="lineNum">    3439 </span>            :                                 strcat(szDASHTemplate, szExName);
<span class="lineNum">    3440 </span>            :                         }
<span class="lineNum">    3441 </span>            :                 }
<span class="lineNum">    3442 </span>            :                 
<span class="lineNum">    3443 </span>            :                 //get final segment template with path resolution - output file name is NULL, we already have solved this
<span class="lineNum">    3444 </span><span class="lineCov">        346 :                 gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE_WITH_PATH, is_bs_switch, szSegmentName, ds-&gt;rep_id, NULL, szDASHTemplate, seg_ext, 0, 0, 0, ctx-&gt;stl);</span>
<span class="lineNum">    3445 </span><span class="lineCov">        346 :                 ds-&gt;seg_template = gf_strdup(szSegmentName);</span>
<span class="lineNum">    3446 </span>            : 
<span class="lineNum">    3447 </span>            :                 //get final segment template - output file name is NULL, we already have solved this
<span class="lineNum">    3448 </span><span class="lineCov">        346 :                 gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, is_bs_switch, szSegmentName, ds-&gt;rep_id, NULL, szDASHTemplate, seg_ext, 0, 0, 0, ctx-&gt;stl);</span>
<span class="lineNum">    3449 </span>            : 
<span class="lineNum">    3450 </span>            :                 //get index templates
<span class="lineNum">    3451 </span><span class="lineCov">        346 :                 if (idx_ext) {</span>
<span class="lineNum">    3452 </span><span class="lineCov">          1 :                         gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX_TEMPLATE_WITH_PATH, is_bs_switch, szIndexSegmentName, ds-&gt;rep_id, NULL, szDASHTemplate, idx_ext, 0, 0, 0, ctx-&gt;stl);</span>
<span class="lineNum">    3453 </span><span class="lineCov">          1 :                         ds-&gt;idx_template = gf_strdup(szIndexSegmentName);</span>
<span class="lineNum">    3454 </span>            : 
<span class="lineNum">    3455 </span><span class="lineCov">          1 :                         gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX_TEMPLATE, is_bs_switch, szIndexSegmentName, ds-&gt;rep_id, NULL, szDASHTemplate, idx_ext, 0, 0, 0, ctx-&gt;stl);</span>
<span class="lineNum">    3456 </span>            :                 }
<span class="lineNum">    3457 </span>            : 
<span class="lineNum">    3458 </span>            :                 //get final init name - output file name is NULL, we already have solved this
<span class="lineNum">    3459 </span><span class="lineCov">        346 :                 gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switch, szInitSegmentFilename, ds-&gt;rep_id, NULL, szDASHTemplate, init_ext, 0, ds-&gt;bitrate, 0, ctx-&gt;stl);</span>
<span class="lineNum">    3460 </span>            : 
<span class="lineNum">    3461 </span>            :                 //get final init template name - output file name is NULL, we already have solved this
<span class="lineNum">    3462 </span><span class="lineCov">        346 :                 gf_media_mpd_format_segment_name(init_template_mode, is_bs_switch, szInitSegmentTemplate, ds-&gt;rep_id, NULL, szDASHTemplate, init_ext, 0, 0, 0, ctx-&gt;stl);</span>
<span class="lineNum">    3463 </span>            : 
<span class="lineNum">    3464 </span><span class="lineCov">        346 :                 if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    3465 </span><span class="lineCov">          6 :                         if (ctx-&gt;template || ds-&gt;template) {</span>
<span class="lineNum">    3466 </span>            :                         } else {
<span class="lineNum">    3467 </span><span class="lineCov">          5 :                                 strcpy(szInitSegmentFilename, gf_file_basename(ds-&gt;src_url));</span>
<span class="lineNum">    3468 </span><span class="lineCov">          5 :                                 strcpy(szSegmentName, gf_file_basename(ds-&gt;src_url));</span>
<span class="lineNum">    3469 </span>            :                         }
<span class="lineNum">    3470 </span>            :                 }
<span class="lineNum">    3471 </span>            : 
<span class="lineNum">    3472 </span><span class="lineCov">        346 :                 if (ctx-&gt;store_seg_states) {</span>
<span class="lineNum">    3473 </span>            :                         assert(!ds-&gt;pending_segment_states);
<span class="lineNum">    3474 </span><span class="lineCov">         74 :                         ds-&gt;pending_segment_states = gf_list_new();</span>
<span class="lineNum">    3475 </span>            :                 }
<span class="lineNum">    3476 </span>            :                 /* baseURLs */
<span class="lineNum">    3477 </span><span class="lineCov">        346 :                 nb_base = ds-&gt;p_base_url ? ds-&gt;p_base_url-&gt;value.string_list.nb_items : 0;</span>
<span class="lineNum">    3478 </span><span class="lineCov">        347 :                 for (j=0; j&lt;nb_base; j++) {</span>
<span class="lineNum">    3479 </span>            :                         GF_MPD_BaseURL *base_url;
<span class="lineNum">    3480 </span><span class="lineCov">          1 :                         char *url = ds-&gt;p_base_url-&gt;value.string_list.vals[j];</span>
<span class="lineNum">    3481 </span><span class="lineCov">          1 :                         GF_SAFEALLOC(base_url, GF_MPD_BaseURL);</span>
<span class="lineNum">    3482 </span><span class="lineCov">          1 :                         if (base_url) {</span>
<span class="lineNum">    3483 </span><span class="lineCov">          1 :                                 base_url-&gt;URL = gf_strdup(url);</span>
<span class="lineNum">    3484 </span><span class="lineCov">          1 :                                 gf_list_add(rep-&gt;base_URLs, base_url);</span>
<span class="lineNum">    3485 </span>            :                         }
<span class="lineNum">    3486 </span>            :                 }
<span class="lineNum">    3487 </span>            : 
<span class="lineNum">    3488 </span>            :                 force_init_seg_tpl = NULL;
<span class="lineNum">    3489 </span>            : #if 0
<span class="lineNum">    3490 </span>            :                 force_init_seg_sl = NULL;
<span class="lineNum">    3491 </span>            : #endif
<span class="lineNum">    3492 </span><span class="lineCov">        346 :                 if (ds-&gt;codec_id==GF_CODECID_HEVC_TILES) {</span>
<span class="lineNum">    3493 </span><span class="lineCov">         36 :                         tile_base_ds = get_base_ds(ctx, ds);</span>
<span class="lineNum">    3494 </span>            :                         skip_init = GF_TRUE;
<span class="lineNum">    3495 </span><span class="lineCov">         36 :                         if (tile_base_ds-&gt;rep-&gt;segment_template) force_init_seg_tpl = tile_base_ds-&gt;rep-&gt;segment_template-&gt;initialization;</span>
<span class="lineNum">    3496 </span><span class="lineNoCov">          0 :                         if (!force_init_seg_tpl &amp;&amp; tile_base_ds-&gt;set-&gt;segment_template) force_init_seg_tpl = tile_base_ds-&gt;set-&gt;segment_template-&gt;initialization;</span>
<span class="lineNum">    3497 </span>            : 
<span class="lineNum">    3498 </span>            : #if 0
<span class="lineNum">    3499 </span>            :                         if (tile_base_ds-&gt;rep-&gt;segment_list) force_init_seg_sl = tile_base_ds-&gt;rep-&gt;segment_list-&gt;initialization_segment;
<span class="lineNum">    3500 </span>            :                         if (!force_init_seg_sl &amp;&amp; tile_base_ds-&gt;set-&gt;segment_list) force_init_seg_sl = tile_base_ds-&gt;set-&gt;segment_list-&gt;initialization_segment;
<span class="lineNum">    3501 </span>            : #endif
<span class="lineNum">    3502 </span>            :                 }
<span class="lineNum">    3503 </span><span class="lineCov">        346 :                 if (ctx-&gt;m2ts) skip_init = GF_TRUE;</span>
<span class="lineNum">    3504 </span><span class="lineCov">        338 :                 else if (ctx-&gt;muxtype==DASHER_MUX_RAW) skip_init = GF_TRUE;</span>
<span class="lineNum">    3505 </span><span class="lineCov">        330 :                 else if (ctx-&gt;muxtype==DASHER_MUX_TS) skip_init = GF_TRUE;</span>
<span class="lineNum">    3506 </span>            : 
<span class="lineNum">    3507 </span>            : 
<span class="lineNum">    3508 </span>            :                 //forward mode, change segment names
<span class="lineNum">    3509 </span><span class="lineCov">        346 :                 if (ctx-&gt;forward_mode) {</span>
<span class="lineNum">    3510 </span><span class="lineCov">         27 :                         u32 k, nb_pids = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    3511 </span>            :                         char *src = NULL;
<span class="lineNum">    3512 </span><span class="lineCov">         27 :                         const GF_PropertyValue *p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PCK_FILENAME);</span>
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span><span class="lineCov">         27 :                         if (!p || !p-&gt;value.string) {</span>
<span class="lineNum">    3515 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't fetch source URL in forward mode, cannot forward\n&quot;));</span>
<span class="lineNum">    3516 </span><span class="lineNoCov">          0 :                                 ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    3518 </span>            :                         }
<span class="lineNum">    3519 </span>            :                         src = p-&gt;value.string;
<span class="lineNum">    3520 </span>            : 
<span class="lineNum">    3521 </span><span class="lineCov">         81 :                         for (k=0; k&lt;nb_pids; k++) {</span>
<span class="lineNum">    3522 </span><span class="lineCov">         81 :                                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;pids, k);</span>
<span class="lineNum">    3523 </span><span class="lineCov">         81 :                                 if (ds == a_ds) continue;</span>
<span class="lineNum">    3524 </span><span class="lineCov">         54 :                                 if (!a_ds-&gt;dst_filter) continue;</span>
<span class="lineNum">    3525 </span>            : 
<span class="lineNum">    3526 </span><span class="lineCov">         27 :                                 p = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PCK_FILENAME);</span>
<span class="lineNum">    3527 </span><span class="lineCov">         27 :                                 if (!p || !p-&gt;value.string) {</span>
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't fetch source URL in forward mode, cannot forward\n&quot;));</span>
<span class="lineNum">    3529 </span><span class="lineNoCov">          0 :                                         ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    3530 </span><span class="lineNoCov">          0 :                                         return;</span>
<span class="lineNum">    3531 </span>            :                                 }
<span class="lineNum">    3532 </span>            :                                 //same init segment used (bs switching)
<span class="lineNum">    3533 </span><span class="lineCov">         27 :                                 if (!strcmp(p-&gt;value.string, src))</span>
<span class="lineNum">    3534 </span>            :                                         skip_init = GF_TRUE;
<span class="lineNum">    3535 </span>            :                         }
<span class="lineNum">    3536 </span>            :                         strcpy(szInitSegmentFilename, src);
<span class="lineNum">    3537 </span>            :                         strcpy(szInitSegmentTemplate, src);
<span class="lineNum">    3538 </span>            : 
<span class="lineNum">    3539 </span><span class="lineCov">         27 :                         if (ctx-&gt;tpl) {</span>
<span class="lineNum">    3540 </span><span class="lineCov">         27 :                                 p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_TEMPLATE);</span>
<span class="lineNum">    3541 </span><span class="lineCov">         27 :                                 if (!p || !p-&gt;value.string) {</span>
<span class="lineNum">    3542 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't fetch source template in forward mode, cannot forward\n&quot;));</span>
<span class="lineNum">    3543 </span><span class="lineNoCov">          0 :                                         ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    3544 </span><span class="lineNoCov">          0 :                                         return;</span>
<span class="lineNum">    3545 </span>            :                                 }
<span class="lineNum">    3546 </span>            :                                 strcpy(szSegmentName, p-&gt;value.string);
<span class="lineNum">    3547 </span>            :                         }
<span class="lineNum">    3548 </span>            :                 }
<span class="lineNum">    3549 </span>            : 
<span class="lineNum">    3550 </span><span class="lineCov">        346 :                 ds-&gt;init_seg = gf_strdup(szInitSegmentFilename);</span>
<span class="lineNum">    3551 </span>            : 
<span class="lineNum">    3552 </span>            :                 //we use segment template
<span class="lineNum">    3553 </span><span class="lineCov">        346 :                 if (ctx-&gt;tpl) {</span>
<span class="lineNum">    3554 </span>            :                         GF_MPD_SegmentTemplate *seg_template;
<span class="lineNum">    3555 </span><span class="lineCov">        289 :                         u32 start_number = ds-&gt;startNumber ? ds-&gt;startNumber : 1;</span>
<span class="lineNum">    3556 </span><span class="lineCov">        289 :                         u64 seg_duration = (u64)(ds-&gt;dash_dur.num) * ds-&gt;mpd_timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span>            :                         //first rep in set and bs switching or single template, create segment template at set level
<span class="lineNum">    3559 </span><span class="lineCov">        289 :                         if (!i &amp;&amp; (set-&gt;bitstream_switching || single_template) ) {</span>
<span class="lineNum">    3560 </span>            :                                 init_template_done = GF_TRUE;
<span class="lineNum">    3561 </span>            :                                 seg_template = NULL;
<span class="lineNum">    3562 </span><span class="lineCov">        247 :                                 if (!skip_init || force_init_seg_tpl || single_template) {</span>
<span class="lineNum">    3563 </span><span class="lineCov">        245 :                                         GF_SAFEALLOC(seg_template, GF_MPD_SegmentTemplate);</span>
<span class="lineNum">    3564 </span><span class="lineCov">        245 :                                         if (seg_template) {</span>
<span class="lineNum">    3565 </span><span class="lineCov">        245 :                                                 if (skip_init) {</span>
<span class="lineNum">    3566 </span><span class="lineCov">         35 :                                                         seg_template-&gt;initialization = force_init_seg_tpl ? gf_strdup(force_init_seg_tpl) : NULL;</span>
<span class="lineNum">    3567 </span><span class="lineCov">         35 :                                                         seg_template-&gt;hls_init_name = force_init_seg_tpl ? tile_base_ds-&gt;init_seg : NULL;</span>
<span class="lineNum">    3568 </span>            :                                                 } else {
<span class="lineNum">    3569 </span><span class="lineCov">        210 :                                                         seg_template-&gt;initialization = gf_strdup(szInitSegmentTemplate);</span>
<span class="lineNum">    3570 </span><span class="lineCov">        210 :                                                         seg_template-&gt;hls_init_name = ds-&gt;init_seg;</span>
<span class="lineNum">    3571 </span>            :                                                 }
<span class="lineNum">    3572 </span>            :                                         }
<span class="lineNum">    3573 </span>            :                                 }
<span class="lineNum">    3574 </span><span class="lineCov">        247 :                                 set-&gt;segment_template = seg_template;</span>
<span class="lineNum">    3575 </span>            : 
<span class="lineNum">    3576 </span><span class="lineCov">        247 :                                 dasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init);</span>
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span><span class="lineCov">        247 :                                 if (single_template) {</span>
<span class="lineNum">    3579 </span><span class="lineCov">        233 :                                         seg_template-&gt;media = gf_strdup(szSegmentName);</span>
<span class="lineNum">    3580 </span><span class="lineCov">        233 :                                         if (ds-&gt;idx_template)</span>
<span class="lineNum">    3581 </span><span class="lineNoCov">          0 :                                                 seg_template-&gt;index = gf_strdup(szIndexSegmentName);</span>
<span class="lineNum">    3582 </span>            : 
<span class="lineNum">    3583 </span><span class="lineCov">        233 :                                         seg_template-&gt;timescale = ds-&gt;mpd_timescale;</span>
<span class="lineNum">    3584 </span><span class="lineCov">        233 :                                         seg_template-&gt;start_number = start_number;</span>
<span class="lineNum">    3585 </span><span class="lineCov">        233 :                                         seg_template-&gt;duration = seg_duration;</span>
<span class="lineNum">    3586 </span>            : 
<span class="lineNum">    3587 </span><span class="lineCov">        233 :                                         if (ctx-&gt;asto&gt;0) {</span>
<span class="lineNum">    3588 </span><span class="lineCov">          2 :                                                 seg_template-&gt;availability_time_offset = ctx-&gt;asto;</span>
<span class="lineNum">    3589 </span>            :                                         }
<span class="lineNum">    3590 </span><span class="lineCov">         14 :                                 } else if (seg_template) {</span>
<span class="lineNum">    3591 </span><span class="lineCov">         12 :                                         seg_template-&gt;start_number = (u32)-1;</span>
<span class="lineNum">    3592 </span>            :                                 }
<span class="lineNum">    3593 </span>            :                         }
<span class="lineNum">    3594 </span>            :                         //non-first rep in set and single template, only open destination
<span class="lineNum">    3595 </span><span class="lineCov">        289 :                         if (i &amp;&amp; single_template) {</span>
<span class="lineNum">    3596 </span><span class="lineCov">          1 :                                 dasher_open_destination(filter, ctx, rep, szInitSegmentFilename, (set-&gt;bitstream_switching || skip_init) ? GF_TRUE : GF_FALSE);</span>
<span class="lineNum">    3597 </span>            :                         }
<span class="lineNum">    3598 </span>            :                         //first rep in set and no bs switching or mutliple templates, create segment template at rep level
<span class="lineNum">    3599 </span><span class="lineCov">        288 :                         else if (i || !single_template) {</span>
<span class="lineNum">    3600 </span><span class="lineCov">         55 :                                 GF_SAFEALLOC(seg_template, GF_MPD_SegmentTemplate);</span>
<span class="lineNum">    3601 </span><span class="lineCov">         55 :                                 if (seg_template) {</span>
<span class="lineNum">    3602 </span><span class="lineCov">         55 :                                         rep-&gt;segment_template = seg_template;</span>
<span class="lineNum">    3603 </span><span class="lineCov">         55 :                                         if (!init_template_done) {</span>
<span class="lineNum">    3604 </span><span class="lineCov">         29 :                                                 if (skip_init) {</span>
<span class="lineNum">    3605 </span><span class="lineNoCov">          0 :                                                         seg_template-&gt;initialization = force_init_seg_tpl ? gf_strdup(force_init_seg_tpl) : NULL;</span>
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :                                                         seg_template-&gt;hls_init_name = force_init_seg_tpl ? tile_base_ds-&gt;init_seg : NULL;</span>
<span class="lineNum">    3607 </span>            :                                                 } else {
<span class="lineNum">    3608 </span><span class="lineCov">         29 :                                                         seg_template-&gt;initialization = gf_strdup(szInitSegmentTemplate);</span>
<span class="lineNum">    3609 </span><span class="lineCov">         29 :                                                         seg_template-&gt;hls_init_name = ds-&gt;init_seg;</span>
<span class="lineNum">    3610 </span>            :                                                 }
<span class="lineNum">    3611 </span><span class="lineCov">         29 :                                                 dasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init);</span>
<span class="lineNum">    3612 </span><span class="lineCov">         26 :                                         } else if (i) {</span>
<span class="lineNum">    3613 </span><span class="lineCov">         12 :                                                 dasher_open_destination(filter, ctx, rep, szInitSegmentFilename, (set-&gt;bitstream_switching || skip_init) ? GF_TRUE : GF_FALSE);</span>
<span class="lineNum">    3614 </span>            :                                         }
<span class="lineNum">    3615 </span><span class="lineCov">         55 :                                         seg_template-&gt;media = gf_strdup(szSegmentName);</span>
<span class="lineNum">    3616 </span><span class="lineCov">         55 :                                         if (ds-&gt;idx_template)</span>
<span class="lineNum">    3617 </span><span class="lineCov">          1 :                                                 seg_template-&gt;index = gf_strdup(szIndexSegmentName);</span>
<span class="lineNum">    3618 </span><span class="lineCov">         55 :                                         seg_template-&gt;duration = seg_duration;</span>
<span class="lineNum">    3619 </span><span class="lineCov">         55 :                                         seg_template-&gt;timescale = ds-&gt;mpd_timescale;</span>
<span class="lineNum">    3620 </span><span class="lineCov">         55 :                                         seg_template-&gt;start_number = start_number;</span>
<span class="lineNum">    3621 </span><span class="lineCov">         55 :                                         if (ctx-&gt;asto &gt; 0) {</span>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :                                                 seg_template-&gt;availability_time_offset = ctx-&gt;asto;</span>
<span class="lineNum">    3623 </span>            :                                         }
<span class="lineNum">    3624 </span>            :                                 }
<span class="lineNum">    3625 </span>            :                         }
<span class="lineNum">    3626 </span>            :                 }
<span class="lineNum">    3627 </span>            :                 /*we are using a single file or segment, use base url*/
<span class="lineNum">    3628 </span><span class="lineCov">         57 :                 else if (ctx-&gt;sseg || ctx-&gt;sfile) {</span>
<span class="lineNum">    3629 </span>            :                         GF_MPD_BaseURL *baseURL;
<span class="lineNum">    3630 </span>            : /*                      char *segext = (ctx-&gt;segext &amp;&amp; !stricmp(ctx-&gt;segext, &quot;null&quot;)) ? NULL : &quot;mp4&quot;;
<span class="lineNum">    3631 </span>            :                         if (ctx-&gt;m2ts) segext = &quot;ts&quot;;
<span class="lineNum">    3632 </span>            : 
<span class="lineNum">    3633 </span>            :                         //use GF_DASH_TEMPLATE_INITIALIZATION_SKIPINIT to get rid of default &quot;init&quot; added for init templates
<span class="lineNum">    3634 </span>            :                         gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, set-&gt;bitstream_switching, szInitSegmentName, ds-&gt;rep_id, NULL, szDASHTemplate, segext, 0, 0, 0, ctx-&gt;stl);
<span class="lineNum">    3635 </span>            : */
<span class="lineNum">    3636 </span>            : 
<span class="lineNum">    3637 </span><span class="lineCov">         55 :                         if (ds-&gt;init_seg) gf_free(ds-&gt;init_seg);</span>
<span class="lineNum">    3638 </span><span class="lineCov">         55 :                         ds-&gt;init_seg = gf_strdup(szInitSegmentFilename);</span>
<span class="lineNum">    3639 </span>            : 
<span class="lineNum">    3640 </span><span class="lineCov">         55 :                         GF_SAFEALLOC(baseURL, GF_MPD_BaseURL);</span>
<span class="lineNum">    3641 </span><span class="lineCov">         55 :                         if (!baseURL) continue;</span>
<span class="lineNum">    3642 </span>            : 
<span class="lineNum">    3643 </span><span class="lineCov">         55 :                         if (!rep-&gt;base_URLs) rep-&gt;base_URLs = gf_list_new();</span>
<span class="lineNum">    3644 </span><span class="lineCov">         55 :                         gf_list_add(rep-&gt;base_URLs, baseURL);</span>
<span class="lineNum">    3645 </span>            : 
<span class="lineNum">    3646 </span><span class="lineCov">         55 :                         if (ctx-&gt;sseg) {</span>
<span class="lineNum">    3647 </span>            :                                 GF_MPD_SegmentBase *segment_base;
<span class="lineNum">    3648 </span><span class="lineCov">         21 :                                 baseURL-&gt;URL = gf_strdup(szInitSegmentFilename);</span>
<span class="lineNum">    3649 </span><span class="lineCov">         21 :                                 GF_SAFEALLOC(segment_base, GF_MPD_SegmentBase);</span>
<span class="lineNum">    3650 </span><span class="lineCov">         21 :                                 if (!segment_base) continue;</span>
<span class="lineNum">    3651 </span><span class="lineCov">         21 :                                 rep-&gt;segment_base = segment_base;</span>
<span class="lineNum">    3652 </span><span class="lineCov">         21 :                                 dasher_open_destination(filter, ctx, rep, szInitSegmentFilename, GF_FALSE);</span>
<span class="lineNum">    3653 </span>            :                         } else {
<span class="lineNum">    3654 </span>            :                                 GF_MPD_SegmentList *seg_list;
<span class="lineNum">    3655 </span><span class="lineCov">         34 :                                 GF_SAFEALLOC(seg_list, GF_MPD_SegmentList);</span>
<span class="lineNum">    3656 </span><span class="lineCov">         34 :                                 if (!seg_list) continue;</span>
<span class="lineNum">    3657 </span><span class="lineCov">         34 :                                 GF_SAFEALLOC(seg_list-&gt;initialization_segment, GF_MPD_URL);</span>
<span class="lineNum">    3658 </span><span class="lineCov">         34 :                                 if (!seg_list-&gt;initialization_segment) continue;</span>
<span class="lineNum">    3659 </span><span class="lineCov">         34 :                                 seg_list-&gt;start_number = (u32) -1;</span>
<span class="lineNum">    3660 </span><span class="lineCov">         34 :                                 baseURL-&gt;URL = gf_strdup(szInitSegmentFilename);</span>
<span class="lineNum">    3661 </span><span class="lineCov">         34 :                                 seg_list-&gt;dasher_segment_name = gf_strdup(szSegmentName);</span>
<span class="lineNum">    3662 </span><span class="lineCov">         34 :                                 seg_list-&gt;timescale = ds-&gt;mpd_timescale;</span>
<span class="lineNum">    3663 </span><span class="lineCov">         34 :                                 seg_list-&gt;duration = (u64) (ds-&gt;dash_dur.num) * ds-&gt;mpd_timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    3664 </span><span class="lineCov">         34 :                                 seg_list-&gt;segment_URLs = gf_list_new();</span>
<span class="lineNum">    3665 </span><span class="lineCov">         34 :                                 rep-&gt;segment_list = seg_list;</span>
<span class="lineNum">    3666 </span><span class="lineCov">         34 :                                 ds-&gt;pending_segment_urls = gf_list_new();</span>
<span class="lineNum">    3667 </span>            : 
<span class="lineNum">    3668 </span><span class="lineCov">         34 :                                 dasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init);</span>
<span class="lineNum">    3669 </span>            :                         }
<span class="lineNum">    3670 </span>            :                 }
<span class="lineNum">    3671 </span>            :                 //no template, no single file, we need a file list
<span class="lineNum">    3672 </span>            :                 else {
<span class="lineNum">    3673 </span>            :                         GF_MPD_SegmentList *seg_list;
<span class="lineNum">    3674 </span><span class="lineCov">          2 :                         GF_SAFEALLOC(seg_list, GF_MPD_SegmentList);</span>
<span class="lineNum">    3675 </span><span class="lineCov">          2 :                         if (!seg_list) continue;</span>
<span class="lineNum">    3676 </span>            : 
<span class="lineNum">    3677 </span><span class="lineCov">          2 :                         if (!skip_init) {</span>
<span class="lineNum">    3678 </span><span class="lineCov">          1 :                                 GF_SAFEALLOC(seg_list-&gt;initialization_segment, GF_MPD_URL);</span>
<span class="lineNum">    3679 </span><span class="lineCov">          1 :                                 if (!seg_list-&gt;initialization_segment) continue;</span>
<span class="lineNum">    3680 </span>            : 
<span class="lineNum">    3681 </span><span class="lineCov">          1 :                                 seg_list-&gt;initialization_segment-&gt;sourceURL = gf_strdup(szInitSegmentFilename);</span>
<span class="lineNum">    3682 </span>            :                         }
<span class="lineNum">    3683 </span><span class="lineCov">          2 :                         seg_list-&gt;dasher_segment_name = gf_strdup(szSegmentName);</span>
<span class="lineNum">    3684 </span><span class="lineCov">          2 :                         seg_list-&gt;timescale = ds-&gt;mpd_timescale;</span>
<span class="lineNum">    3685 </span><span class="lineCov">          2 :                         seg_list-&gt;segment_URLs = gf_list_new();</span>
<span class="lineNum">    3686 </span><span class="lineCov">          2 :                         seg_list-&gt;start_number = (u32) -1;</span>
<span class="lineNum">    3687 </span><span class="lineCov">          2 :                         seg_list-&gt;duration = (u64) (ds-&gt;dash_dur.num) * ds-&gt;mpd_timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    3688 </span><span class="lineCov">          2 :                         rep-&gt;segment_list = seg_list;</span>
<span class="lineNum">    3689 </span><span class="lineCov">          2 :                         ds-&gt;pending_segment_urls = gf_list_new();</span>
<span class="lineNum">    3690 </span>            : 
<span class="lineNum">    3691 </span><span class="lineCov">          2 :                         dasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init);</span>
<span class="lineNum">    3692 </span>            :                 }
<span class="lineNum">    3693 </span>            : 
<span class="lineNum">    3694 </span>            :                 //open PID
<span class="lineNum">    3695 </span><span class="lineCov">        346 :                 dasher_open_pid(filter, ctx, ds, multi_pids, skip_init);</span>
<span class="lineNum">    3696 </span>            :         }
<a name="3697"><span class="lineNum">    3697 </span>            : }</a>
<span class="lineNum">    3698 </span>            : 
<span class="lineNum">    3699 </span><span class="lineCov">          1 : static void dahser_purge_segment_timeline(GF_DashStream *ds, GF_MPD_SegmentTimeline *stl, GF_DASH_SegmentContext *sctx)</span>
<span class="lineNum">    3700 </span>            : {
<span class="lineNum">    3701 </span><span class="lineCov">          1 :         GF_MPD_SegmentTimelineEntry *stl_e = gf_list_get(stl-&gt;entries, 0);</span>
<span class="lineNum">    3702 </span><span class="lineCov">          1 :         if (!stl_e) return;</span>
<span class="lineNum">    3703 </span>            : 
<span class="lineNum">    3704 </span><span class="lineCov">          1 :         if (stl_e-&gt;repeat_count) {</span>
<span class="lineNum">    3705 </span><span class="lineCov">          1 :                 stl_e-&gt;repeat_count--;</span>
<span class="lineNum">    3706 </span><span class="lineCov">          1 :                 stl_e-&gt;start_time += stl_e-&gt;duration;</span>
<span class="lineNum">    3707 </span>            :         } else {
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :                 u64 start_time = stl_e-&gt;start_time + stl_e-&gt;duration;</span>
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :                 gf_list_rem(stl-&gt;entries, 0);</span>
<span class="lineNum">    3710 </span><span class="lineNoCov">          0 :                 gf_free(stl_e);</span>
<span class="lineNum">    3711 </span><span class="lineNoCov">          0 :                 stl_e = gf_list_get(stl-&gt;entries, 0);</span>
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :                 if (!stl_e) {</span>
<span class="lineNum">    3713 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] No timeline entry after currently removed segment, cannot update start time\n&quot; ));</span>
<span class="lineNum">    3714 </span>            :                         return;
<span class="lineNum">    3715 </span>            :                 }
<span class="lineNum">    3716 </span>            : 
<span class="lineNum">    3717 </span><span class="lineNoCov">          0 :                 if (!stl_e-&gt;start_time) stl_e-&gt;start_time = start_time;</span>
<span class="lineNum">    3718 </span><span class="lineNoCov">          0 :                 else if (stl_e-&gt;start_time != start_time) {</span>
<span class="lineNum">    3719 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Mismatch in segment timeline while purging, new start time &quot;LLU&quot; but entry indicates &quot;LLU&quot;, keeping original one\n&quot;, start_time, stl_e-&gt;start_time ));</span>
<span class="lineNum">    3720 </span>            :                 }
<span class="lineNum">    3721 </span>            :         }
<a name="3722"><span class="lineNum">    3722 </span>            : }</a>
<span class="lineNum">    3723 </span>            : 
<span class="lineNum">    3724 </span><span class="lineCov">        356 : static void dasher_purge_segments(GF_DasherCtx *ctx, u64 *period_dur)</span>
<span class="lineNum">    3725 </span>            : {
<span class="lineNum">    3726 </span>            :         Double min_valid_mpd_time;
<span class="lineNum">    3727 </span>            :         u64 max_rem_dur = 0;
<span class="lineNum">    3728 </span>            :         u32 i, count;
<span class="lineNum">    3729 </span>            : 
<span class="lineNum">    3730 </span>            :         //non-static mode, purge segments
<span class="lineNum">    3731 </span><span class="lineCov">        356 :         if (ctx-&gt;dmode == GF_MPD_TYPE_STATIC) return;</span>
<span class="lineNum">    3732 </span><span class="lineCov">        136 :         if (ctx-&gt;tsb&lt;0) return;</span>
<span class="lineNum">    3733 </span>            : 
<span class="lineNum">    3734 </span>            : 
<span class="lineNum">    3735 </span><span class="lineCov">        114 :         min_valid_mpd_time = (Double) *period_dur;</span>
<span class="lineNum">    3736 </span><span class="lineCov">        114 :         min_valid_mpd_time /= 1000;</span>
<span class="lineNum">    3737 </span><span class="lineCov">        114 :         min_valid_mpd_time -= ctx-&gt;tsb;</span>
<span class="lineNum">    3738 </span>            :         //negative asto, we produce segments earlier but we don't want to delete them before the asto
<span class="lineNum">    3739 </span><span class="lineCov">        114 :         if (ctx-&gt;asto&lt;0) {</span>
<span class="lineNum">    3740 </span><span class="lineNoCov">          0 :                 min_valid_mpd_time += ctx-&gt;asto;</span>
<span class="lineNum">    3741 </span>            :         }
<span class="lineNum">    3742 </span><span class="lineCov">        114 :         if (min_valid_mpd_time&lt;=0) return;</span>
<span class="lineNum">    3743 </span>            : 
<span class="lineNum">    3744 </span><span class="lineCov">         11 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    3745 </span><span class="lineCov">         26 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3746 </span><span class="lineCov">         15 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    3747 </span><span class="lineCov">         15 :                 if (ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    3748 </span><span class="lineCov">         11 :                 if (!ds-&gt;rep) continue;</span>
<span class="lineNum">    3749 </span><span class="lineCov">         10 :                 if (!ds-&gt;rep-&gt;state_seg_list) continue;</span>
<span class="lineNum">    3750 </span>            : 
<span class="lineNum">    3751 </span><span class="lineCov">          3 :                 while (1) {</span>
<span class="lineNum">    3752 </span>            :                         Double time, dur;
<span class="lineNum">    3753 </span>            :                         Bool seg_url_found = GF_FALSE;
<span class="lineNum">    3754 </span>            :                         Bool has_seg_list = GF_FALSE;
<span class="lineNum">    3755 </span><span class="lineCov">         13 :                         GF_DASH_SegmentContext *sctx = gf_list_get(ds-&gt;rep-&gt;state_seg_list, 0);</span>
<span class="lineNum">    3756 </span><span class="lineCov">         13 :                         if (!sctx) break;</span>
<span class="lineNum">    3757 </span>            :                         /*not yet flushed*/
<span class="lineNum">    3758 </span><span class="lineCov">         13 :                         if (gf_list_find(ds-&gt;pending_segment_states, sctx)&gt;=0) break;</span>
<span class="lineNum">    3759 </span><span class="lineCov">          8 :                         time = (Double) sctx-&gt;time;</span>
<span class="lineNum">    3760 </span><span class="lineCov">          8 :                         time /= ds-&gt;mpd_timescale;</span>
<span class="lineNum">    3761 </span><span class="lineCov">          8 :                         dur = (Double) sctx-&gt;dur;</span>
<span class="lineNum">    3762 </span><span class="lineCov">          8 :                         dur/= ds-&gt;timescale;</span>
<span class="lineNum">    3763 </span><span class="lineCov">          8 :                         if (time + dur &gt;= min_valid_mpd_time) break;</span>
<span class="lineNum">    3764 </span><span class="lineCov">          3 :                         if (sctx-&gt;filepath) {</span>
<span class="lineNum">    3765 </span>            :                                 GF_FilterEvent evt;
<span class="lineNum">    3766 </span><span class="lineCov">          3 :                                 GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] removing segment %s\n&quot;, sctx-&gt;filename ? sctx-&gt;filename : sctx-&gt;filepath));</span>
<span class="lineNum">    3767 </span>            : 
<span class="lineNum">    3768 </span><span class="lineCov">          3 :                                 GF_FEVT_INIT(evt, GF_FEVT_FILE_DELETE, ds-&gt;opid);</span>
<span class="lineNum">    3769 </span><span class="lineCov">          3 :                                 evt.file_del.url = sctx-&gt;filepath;</span>
<span class="lineNum">    3770 </span><span class="lineCov">          3 :                                 gf_filter_pid_send_event(ds-&gt;opid, &amp;evt);</span>
<span class="lineNum">    3771 </span><span class="lineCov">          3 :                                 gf_free(sctx-&gt;filepath);</span>
<span class="lineNum">    3772 </span>            :                         }
<span class="lineNum">    3773 </span>            : 
<span class="lineNum">    3774 </span><span class="lineCov">          3 :                         if (ds-&gt;rep-&gt;segment_list) {</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :                                 GF_MPD_SegmentURL *surl = gf_list_pop_front(ds-&gt;rep-&gt;segment_list-&gt;segment_URLs);</span>
<span class="lineNum">    3776 </span>            :                                 has_seg_list = GF_TRUE;
<span class="lineNum">    3777 </span>            :                                 //can be NULL if we mutualize everything at AdaptatioSet level
<span class="lineNum">    3778 </span><span class="lineNoCov">          0 :                                 if (surl) {</span>
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :                                         gf_mpd_segment_url_free(surl);</span>
<span class="lineNum">    3780 </span>            :                                         seg_url_found = GF_TRUE;
<span class="lineNum">    3781 </span>            :                                 }
<span class="lineNum">    3782 </span>            :                         }
<span class="lineNum">    3783 </span>            :                         //not an else due to inheritance
<span class="lineNum">    3784 </span><span class="lineCov">          3 :                         if (ds-&gt;owns_set &amp;&amp; ds-&gt;set-&gt;segment_list) {</span>
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :                                 GF_MPD_SegmentURL *surl = gf_list_pop_front(ds-&gt;set-&gt;segment_list-&gt;segment_URLs);</span>
<span class="lineNum">    3786 </span>            :                                 has_seg_list = GF_TRUE;
<span class="lineNum">    3787 </span>            :                                 //can be NULL if we don't mutualize at AdaptatioSet level
<span class="lineNum">    3788 </span><span class="lineNoCov">          0 :                                 if (surl) {</span>
<span class="lineNum">    3789 </span><span class="lineNoCov">          0 :                                         gf_mpd_segment_url_free(surl);</span>
<span class="lineNum">    3790 </span>            :                                         seg_url_found = GF_TRUE;
<span class="lineNum">    3791 </span>            :                                 }
<span class="lineNum">    3792 </span>            :                         }
<span class="lineNum">    3793 </span>            :                         //but we must have at least one segment URL entry
<span class="lineNum">    3794 </span><span class="lineCov">          3 :                         if (has_seg_list &amp;&amp; !seg_url_found) {</span>
<span class="lineNum">    3795 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] purging segment %s for AS %d rep %s but segment list is empty!\n&quot;,</span>
<span class="lineNum">    3796 </span>            :                                                 sctx-&gt;filename ? sctx-&gt;filename : &quot;&quot;, ds-&gt;set-&gt;id, ds-&gt;rep-&gt;id));
<span class="lineNum">    3797 </span>            :                         }
<span class="lineNum">    3798 </span>            : 
<span class="lineNum">    3799 </span><span class="lineCov">          3 :                         if (ds-&gt;rep-&gt;segment_template) {</span>
<span class="lineNum">    3800 </span><span class="lineCov">          1 :                                 if (ds-&gt;rep-&gt;segment_template-&gt;segment_timeline) {</span>
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :                                         dahser_purge_segment_timeline(ds, ds-&gt;rep-&gt;segment_template-&gt;segment_timeline, sctx);</span>
<span class="lineNum">    3802 </span>            :                                 }
<span class="lineNum">    3803 </span>            :                         }
<span class="lineNum">    3804 </span>            :                         //not an else due to inheritance
<span class="lineNum">    3805 </span><span class="lineCov">          3 :                         if (ds-&gt;owns_set &amp;&amp; ds-&gt;set-&gt;segment_template) {</span>
<span class="lineNum">    3806 </span><span class="lineCov">          3 :                                 if (ds-&gt;set-&gt;segment_template-&gt;segment_timeline) {</span>
<span class="lineNum">    3807 </span><span class="lineCov">          1 :                                         dahser_purge_segment_timeline(ds, ds-&gt;set-&gt;segment_template-&gt;segment_timeline, sctx);</span>
<span class="lineNum">    3808 </span>            :                                 }
<span class="lineNum">    3809 </span>            :                         }
<span class="lineNum">    3810 </span>            : 
<span class="lineNum">    3811 </span><span class="lineCov">          3 :                         ds-&gt;nb_segments_purged ++;</span>
<span class="lineNum">    3812 </span><span class="lineCov">          3 :                         ds-&gt;dur_purged += dur;</span>
<span class="lineNum">    3813 </span>            :                         assert(gf_list_find(ds-&gt;pending_segment_states, sctx)&lt;0);
<span class="lineNum">    3814 </span><span class="lineCov">          3 :                         if (sctx-&gt;filename) gf_free(sctx-&gt;filename);</span>
<span class="lineNum">    3815 </span><span class="lineCov">          3 :                         if (sctx-&gt;hls_key_uri) gf_free(sctx-&gt;hls_key_uri);</span>
<span class="lineNum">    3816 </span><span class="lineCov">          3 :                         gf_free(sctx);</span>
<span class="lineNum">    3817 </span><span class="lineCov">          3 :                         gf_list_rem(ds-&gt;rep-&gt;state_seg_list, 0);</span>
<span class="lineNum">    3818 </span>            :                 }
<span class="lineNum">    3819 </span><span class="lineCov">         10 :                 if (max_rem_dur &lt; ds-&gt;dur_purged*1000) max_rem_dur = (u64) (ds-&gt;dur_purged * 1000);</span>
<span class="lineNum">    3820 </span>            :                 //final flush to static of live session: update start number
<span class="lineNum">    3821 </span><span class="lineCov">         10 :                 if (ctx-&gt;dmode!=GF_MPD_TYPE_DYNAMIC) {</span>
<span class="lineNum">    3822 </span><span class="lineNoCov">          0 :                         if (ds-&gt;owns_set &amp;&amp; ds-&gt;set &amp;&amp; ds-&gt;set-&gt;segment_template) {</span>
<span class="lineNum">    3823 </span><span class="lineNoCov">          0 :                                 ds-&gt;set-&gt;segment_template-&gt;start_number += ds-&gt;nb_segments_purged;</span>
<span class="lineNum">    3824 </span><span class="lineNoCov">          0 :                         } else if (ds-&gt;rep &amp;&amp; ds-&gt;rep-&gt;segment_template) {</span>
<span class="lineNum">    3825 </span><span class="lineNoCov">          0 :                                 ds-&gt;rep-&gt;segment_template-&gt;start_number += ds-&gt;nb_segments_purged;</span>
<span class="lineNum">    3826 </span>            :                         }
<span class="lineNum">    3827 </span><span class="lineNoCov">          0 :                         ds-&gt;nb_segments_purged = 0;</span>
<span class="lineNum">    3828 </span>            :                 }
<span class="lineNum">    3829 </span>            :         }
<span class="lineNum">    3830 </span>            :         //final flush to static of live session: update period duration
<span class="lineNum">    3831 </span><span class="lineCov">         11 :         if (ctx-&gt;dmode!=GF_MPD_TYPE_DYNAMIC) {</span>
<span class="lineNum">    3832 </span><span class="lineCov">          1 :                 if (max_rem_dur &gt; *period_dur) *period_dur = 0;</span>
<span class="lineNum">    3833 </span><span class="lineCov">          1 :                 else *period_dur = *period_dur - max_rem_dur;</span>
<span class="lineNum">    3834 </span>            :         }
<a name="3835"><span class="lineNum">    3835 </span>            : }</a>
<span class="lineNum">    3836 </span>            : 
<span class="lineNum">    3837 </span><span class="lineCov">        356 : static void dasher_update_period_duration(GF_DasherCtx *ctx, Bool is_period_switch)</span>
<span class="lineNum">    3838 </span>            : {
<span class="lineNum">    3839 </span>            :         u32 i, count;
<span class="lineNum">    3840 </span><span class="lineCov">        356 :         u64 pdur = 0;</span>
<span class="lineNum">    3841 </span>            :         u64 min_dur = 0;
<span class="lineNum">    3842 </span>            :         u64 p_start=0;
<span class="lineNum">    3843 </span>            :         GF_MPD_Period *prev_p = NULL;
<span class="lineNum">    3844 </span><span class="lineCov">        356 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    3845 </span><span class="lineCov">        530 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3846 </span><span class="lineCov">        530 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    3847 </span><span class="lineCov">        530 :                 if (ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    3848 </span>            : 
<span class="lineNum">    3849 </span><span class="lineCov">        516 :                 if (ds-&gt;xlink &amp;&amp; (ds-&gt;stream_type==GF_STREAM_FILE) ) {</span>
<span class="lineNum">    3850 </span><span class="lineNoCov">          0 :                         pdur = (u32) (1000*(s64)ds-&gt;period_dur.num / ds-&gt;period_dur.den);</span>
<span class="lineNum">    3851 </span>            :                 } else {
<span class="lineNum">    3852 </span><span class="lineCov">        516 :                         u64 ds_dur = ds-&gt;max_period_dur;</span>
<span class="lineNum">    3853 </span>            : 
<span class="lineNum">    3854 </span>            :                         //we had to generate one extra segment to unlock looping, but we don't want to advertise it in the manifest duration
<span class="lineNum">    3855 </span>            :                         //because other sets may not be ready for this time interval
<span class="lineNum">    3856 </span><span class="lineCov">        516 :                         if (ds-&gt;subdur_forced_use_period_dur)</span>
<span class="lineNum">    3857 </span>            :                                 ds_dur = ds-&gt;subdur_forced_use_period_dur;
<span class="lineNum">    3858 </span>            : 
<span class="lineNum">    3859 </span><span class="lineCov">        516 :                         if (ds-&gt;clamped_dur.num &amp;&amp; !ctx-&gt;loop) {</span>
<span class="lineNum">    3860 </span><span class="lineCov">        177 :                                 u64 clamp_dur = (u64) (ds-&gt;clamped_dur.num * 1000);</span>
<span class="lineNum">    3861 </span><span class="lineCov">        177 :                                 if (clamp_dur &lt; ds-&gt;clamped_dur.den * ds_dur) ds_dur = clamp_dur / ds-&gt;clamped_dur.den;</span>
<span class="lineNum">    3862 </span>            :                         }
<span class="lineNum">    3863 </span>            : 
<span class="lineNum">    3864 </span><span class="lineCov">        516 :                         if (ds-&gt;dur_purged &amp;&amp; (ctx-&gt;mpd-&gt;type != GF_MPD_TYPE_DYNAMIC)) {</span>
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :                                 u64 rem_dur = (u64) (ds-&gt;dur_purged * 1000);</span>
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :                                 if (ds_dur&gt;rem_dur) ds_dur -= rem_dur;</span>
<span class="lineNum">    3867 </span>            :                                 else ds_dur = 0;
<span class="lineNum">    3868 </span>            :                         }
<span class="lineNum">    3869 </span>            : 
<span class="lineNum">    3870 </span><span class="lineCov">        516 :                         if (!min_dur || (min_dur &gt; ds_dur)) min_dur = ds-&gt;max_period_dur;</span>
<span class="lineNum">    3871 </span><span class="lineCov">        516 :                         if (pdur &lt; ds_dur) pdur = ds_dur;</span>
<span class="lineNum">    3872 </span>            :                 }
<span class="lineNum">    3873 </span>            :         }
<span class="lineNum">    3874 </span>            : 
<span class="lineNum">    3875 </span><span class="lineCov">        356 :         if (!count) {</span>
<span class="lineNum">    3876 </span><span class="lineCov">          1 :                 if (ctx-&gt;current_period-&gt;period &amp;&amp; ctx-&gt;current_period-&gt;period-&gt;duration)</span>
<span class="lineNum">    3877 </span><span class="lineCov">          1 :                         pdur = ctx-&gt;current_period-&gt;period-&gt;duration;</span>
<span class="lineNum">    3878 </span>            :         }
<span class="lineNum">    3879 </span>            : 
<span class="lineNum">    3880 </span><span class="lineCov">        356 :         if (!ctx-&gt;check_dur) {</span>
<span class="lineNum">    3881 </span><span class="lineCov">        202 :                 s32 diff = (s32) ((s64) pdur - (s64) min_dur);</span>
<span class="lineNum">    3882 </span><span class="lineCov">        202 :                 if (ABS(diff)&gt;2000) {</span>
<span class="lineNum">    3883 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Adaptation sets in period are of unequal duration min %g max %g seconds\n&quot;, ((Double)min_dur)/1000, ((Double)pdur)/1000));</span>
<span class="lineNum">    3884 </span>            :                 }
<span class="lineNum">    3885 </span>            :         }
<span class="lineNum">    3886 </span>            : 
<span class="lineNum">    3887 </span><span class="lineCov">        356 :         dasher_purge_segments(ctx, &amp;pdur);</span>
<span class="lineNum">    3888 </span>            : 
<span class="lineNum">    3889 </span><span class="lineCov">        356 :         if (ctx-&gt;current_period-&gt;period) {</span>
<span class="lineNum">    3890 </span><span class="lineCov">        356 :                 ctx-&gt;current_period-&gt;period-&gt;duration = pdur;</span>
<span class="lineNum">    3891 </span>            : 
<span class="lineNum">    3892 </span>            :                 //update MPD duration in any case
<span class="lineNum">    3893 </span><span class="lineCov">        356 :                 if (ctx-&gt;current_period-&gt;period-&gt;start) {</span>
<span class="lineNum">    3894 </span><span class="lineCov">          3 :                         ctx-&gt;mpd-&gt;media_presentation_duration = ctx-&gt;current_period-&gt;period-&gt;start + pdur;</span>
<span class="lineNum">    3895 </span>            :                 } else {
<span class="lineNum">    3896 </span><span class="lineCov">        353 :                         u32 k, pcount = gf_list_count(ctx-&gt;mpd-&gt;periods);</span>
<span class="lineNum">    3897 </span><span class="lineCov">        353 :                         ctx-&gt;mpd-&gt;media_presentation_duration = 0;</span>
<span class="lineNum">    3898 </span><span class="lineCov">          8 :                         for (k=0; k&lt;pcount; k++) {</span>
<span class="lineNum">    3899 </span><span class="lineCov">        361 :                                 GF_MPD_Period *p = gf_list_get(ctx-&gt;mpd-&gt;periods, k);</span>
<span class="lineNum">    3900 </span><span class="lineCov">        361 :                                 if (p-&gt;start)</span>
<span class="lineNum">    3901 </span><span class="lineCov">          1 :                                         ctx-&gt;mpd-&gt;media_presentation_duration = p-&gt;start + p-&gt;duration;</span>
<span class="lineNum">    3902 </span>            :                                 else
<span class="lineNum">    3903 </span><span class="lineCov">        360 :                                         ctx-&gt;mpd-&gt;media_presentation_duration += p-&gt;duration;</span>
<span class="lineNum">    3904 </span><span class="lineCov">        361 :                                 if (p==ctx-&gt;current_period-&gt;period)</span>
<span class="lineNum">    3905 </span>            :                                         break;
<span class="lineNum">    3906 </span>            :                         }
<span class="lineNum">    3907 </span>            :                 }
<span class="lineNum">    3908 </span>            :         }
<span class="lineNum">    3909 </span>            : 
<span class="lineNum">    3910 </span><span class="lineCov">        356 :         if (ctx-&gt;refresh&lt;0)</span>
<span class="lineNum">    3911 </span><span class="lineNoCov">          0 :                 ctx-&gt;mpd-&gt;media_presentation_duration = (u32) ( (-ctx-&gt;refresh) * 1000 );</span>
<span class="lineNum">    3912 </span>            : 
<span class="lineNum">    3913 </span>            :         //static mode, done
<span class="lineNum">    3914 </span><span class="lineCov">        356 :         if (ctx-&gt;dmode != GF_MPD_TYPE_DYNAMIC) {</span>
<span class="lineNum">    3915 </span><span class="lineCov">        228 :                 return;</span>
<span class="lineNum">    3916 </span>            :         }
<span class="lineNum">    3917 </span>            :         assert(ctx-&gt;current_period-&gt;period);
<span class="lineNum">    3918 </span>            :         //dynamic mode only, reset durations
<span class="lineNum">    3919 </span>            : 
<span class="lineNum">    3920 </span><span class="lineCov">        128 :         ctx-&gt;mpd-&gt;gpac_mpd_time = ctx-&gt;mpd-&gt;media_presentation_duration;</span>
<span class="lineNum">    3921 </span>            : 
<span class="lineNum">    3922 </span>            :         //not done yet for this period, keep duration to 0
<span class="lineNum">    3923 </span><span class="lineCov">        128 :         if (ctx-&gt;subdur_done) {</span>
<span class="lineNum">    3924 </span><span class="lineCov">         22 :                 if (ctx-&gt;mpd-&gt;media_presentation_duration &gt; ctx-&gt;current_period-&gt;period-&gt;duration)</span>
<span class="lineNum">    3925 </span><span class="lineCov">          3 :                         ctx-&gt;mpd-&gt;media_presentation_duration -= ctx-&gt;current_period-&gt;period-&gt;duration;</span>
<span class="lineNum">    3926 </span>            :                 else
<span class="lineNum">    3927 </span><span class="lineCov">         19 :                         ctx-&gt;mpd-&gt;media_presentation_duration = 0;</span>
<span class="lineNum">    3928 </span><span class="lineCov">         22 :                 ctx-&gt;current_period-&gt;period-&gt;duration = 0;</span>
<span class="lineNum">    3929 </span>            :         }
<span class="lineNum">    3930 </span>            : 
<span class="lineNum">    3931 </span><span class="lineCov">        128 :         ctx-&gt;mpd-&gt;gpac_next_ntp_ms = ctx-&gt;mpd-&gt;gpac_init_ntp_ms + ctx-&gt;mpd-&gt;gpac_mpd_time;</span>
<span class="lineNum">    3932 </span><span class="lineCov">        128 :         if (ctx-&gt;asto&lt;0)</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :                 ctx-&gt;mpd-&gt;gpac_next_ntp_ms -= (u64) (-ctx-&gt;asto * 1000);</span>
<span class="lineNum">    3934 </span><span class="lineCov">        128 :         if (ctx-&gt;_p_gentime) (*ctx-&gt;_p_gentime) = ctx-&gt;mpd-&gt;gpac_next_ntp_ms;</span>
<span class="lineNum">    3935 </span><span class="lineCov">        128 :         if (ctx-&gt;_p_mpdtime) (*ctx-&gt;_p_mpdtime) = ctx-&gt;mpd-&gt;gpac_mpd_time;</span>
<span class="lineNum">    3936 </span>            : 
<span class="lineNum">    3937 </span><span class="lineCov">        128 :         GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] updated period %s duration &quot;LLU&quot; MPD time &quot;LLU&quot;\n&quot;, ctx-&gt;current_period-&gt;period-&gt;ID, pdur, ctx-&gt;mpd-&gt;gpac_mpd_time ));</span>
<span class="lineNum">    3938 </span>            : 
<span class="lineNum">    3939 </span><span class="lineCov">        128 :         count = gf_list_count(ctx-&gt;mpd-&gt;periods);</span>
<span class="lineNum">    3940 </span><span class="lineCov">        133 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    3941 </span><span class="lineCov">        133 :                 GF_MPD_Period *p = gf_list_get(ctx-&gt;mpd-&gt;periods, i);</span>
<span class="lineNum">    3942 </span><span class="lineCov">        133 :                 if (p-&gt;start) {</span>
<span class="lineNum">    3943 </span>            :                         p_start = p-&gt;start;
<span class="lineNum">    3944 </span>            :                 } else {
<span class="lineNum">    3945 </span><span class="lineCov">        131 :                         p-&gt;start = p_start;</span>
<span class="lineNum">    3946 </span>            :                 }
<span class="lineNum">    3947 </span><span class="lineCov">        133 :                 if (prev_p &amp;&amp; (prev_p-&gt;start + prev_p-&gt;duration == p_start)) {</span>
<span class="lineNum">    3948 </span><span class="lineCov">          3 :                         prev_p-&gt;duration = 0;</span>
<span class="lineNum">    3949 </span>            :                 }
<span class="lineNum">    3950 </span><span class="lineCov">        133 :                 p_start += p-&gt;duration;</span>
<span class="lineNum">    3951 </span>            :                 prev_p = p;
<span class="lineNum">    3952 </span>            :         }
<a name="3953"><span class="lineNum">    3953 </span>            : }</a>
<span class="lineNum">    3954 </span>            : 
<span class="lineNum">    3955 </span><span class="lineCov">       1014 : static void dasher_transfer_file(FILE *f, GF_FilterPid *opid, const char *name, GF_DashStream *ds)</span>
<span class="lineNum">    3956 </span>            : {
<span class="lineNum">    3957 </span>            :         GF_FilterPacket *pck;
<span class="lineNum">    3958 </span>            :         u32 size, nb_read;
<span class="lineNum">    3959 </span>            :         u8 *output;
<span class="lineNum">    3960 </span>            : 
<span class="lineNum">    3961 </span><span class="lineCov">       1014 :         size = (u32) gf_fsize(f);</span>
<span class="lineNum">    3962 </span>            : 
<span class="lineNum">    3963 </span><span class="lineCov">       1014 :         pck = gf_filter_pck_new_alloc(opid, size, &amp;output);</span>
<span class="lineNum">    3964 </span><span class="lineCov">       1014 :         if (!pck) return;</span>
<span class="lineNum">    3965 </span>            : 
<span class="lineNum">    3966 </span><span class="lineCov">       1014 :         nb_read = (u32) gf_fread(output, size, f);</span>
<span class="lineNum">    3967 </span><span class="lineCov">       1014 :         if (nb_read != size) {</span>
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Error reading temp MPD file, read %d bytes but file size is %d\n&quot;, nb_read, size ));</span>
<span class="lineNum">    3969 </span>            :         }
<span class="lineNum">    3970 </span><span class="lineCov">       1014 :         gf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);</span>
<span class="lineNum">    3971 </span><span class="lineCov">       1014 :         gf_filter_pck_set_seek_flag(pck, GF_TRUE);</span>
<span class="lineNum">    3972 </span><span class="lineCov">       1014 :         if (name) {</span>
<span class="lineNum">    3973 </span><span class="lineCov">        612 :                 gf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &amp;PROP_STRING(name) );</span>
<span class="lineNum">    3974 </span>            :         }
<span class="lineNum">    3975 </span><span class="lineCov">       1014 :         if (ds) {</span>
<span class="lineNum">    3976 </span><span class="lineCov">        596 :                 gf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_REF, &amp;PROP_LONGUINT( ds-&gt;hls_ref_id ) );</span>
<span class="lineNum">    3977 </span>            :         }
<span class="lineNum">    3978 </span><span class="lineCov">       1014 :         gf_filter_pck_send(pck);</span>
<span class="lineNum">    3979 </span>            : }
<span class="lineNum">    3980 </span>            : 
<span class="lineNum">    3981 </span>            : 
<span class="lineNum">    3982 </span>            : static u64 dasher_get_utc(GF_DasherCtx *ctx)
<span class="lineNum">    3983 </span>            : {
<span class="lineNum">    3984 </span><span class="lineCov">        825 :         return gf_net_get_utc() - ctx-&gt;utc_diff;</span>
<a name="3985"><span class="lineNum">    3985 </span>            : }</a>
<span class="lineNum">    3986 </span>            : 
<span class="lineNum">    3987 </span><span class="lineCov">          6 : static void dasher_get_set_and_rep(GF_MPD_Period *period, const char *repid, GF_MPD_AdaptationSet **out_set, GF_MPD_Representation **out_rep)</span>
<span class="lineNum">    3988 </span>            : {
<span class="lineNum">    3989 </span><span class="lineCov">          6 :         u32 i, nb_sets = gf_list_count(period-&gt;adaptation_sets);</span>
<span class="lineNum">    3990 </span><span class="lineCov">          2 :         for (i=0; i&lt;nb_sets; i++) {</span>
<span class="lineNum">    3991 </span>            :                 u32 j, nb_reps;
<span class="lineNum">    3992 </span><span class="lineCov">          8 :                 GF_MPD_AdaptationSet *set = gf_list_get(period-&gt;adaptation_sets, i);</span>
<span class="lineNum">    3993 </span><span class="lineCov">          8 :                 nb_reps = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    3994 </span><span class="lineCov">          6 :                 for (j=0; j&lt;nb_reps; j++) {</span>
<span class="lineNum">    3995 </span><span class="lineCov">         12 :                         GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, j);</span>
<span class="lineNum">    3996 </span><span class="lineCov">         12 :                         if (rep-&gt;id &amp;&amp; !strcmp(rep-&gt;id, repid)) {</span>
<span class="lineNum">    3997 </span><span class="lineCov">          6 :                                 *out_set = set;</span>
<span class="lineNum">    3998 </span><span class="lineCov">          6 :                                 *out_rep = rep;</span>
<span class="lineNum">    3999 </span>            :                                 return;
<span class="lineNum">    4000 </span>            :                         }
<span class="lineNum">    4001 </span>            :                 }
<span class="lineNum">    4002 </span>            :         }
<a name="4003"><span class="lineNum">    4003 </span>            : }</a>
<span class="lineNum">    4004 </span>            : 
<span class="lineNum">    4005 </span><span class="lineCov">          6 : static Bool dasher_merge_rep(GF_DashStream *ds, GF_MPD_Representation *rep)</span>
<span class="lineNum">    4006 </span>            : {
<span class="lineNum">    4007 </span>            :         Bool transcode_detected = GF_FALSE;
<span class="lineNum">    4008 </span>            :         Bool recompute_set = GF_FALSE;
<span class="lineNum">    4009 </span><span class="lineCov">          6 :         GF_MPD_Representation *n_rep = ds-&gt;rep;</span>
<span class="lineNum">    4010 </span>            : 
<span class="lineNum">    4011 </span>            :         //TODO: copy other properties in case we transcode ?
<span class="lineNum">    4012 </span>            : 
<span class="lineNum">    4013 </span>            : #define CHECK_VAL(_name, _v) if (rep-&gt;_name != n_rep-&gt;_name) { rep-&gt;_name = n_rep-&gt;_name; transcode_detected = GF_TRUE; if (_v) recompute_set = GF_TRUE; }
<span class="lineNum">    4014 </span>            : 
<span class="lineNum">    4015 </span>            : #define CHECK_STR(_name) if (rep-&gt;_name &amp;&amp; n_rep-&gt;_name &amp;&amp; !strcmp(rep-&gt;_name, n_rep-&gt;_name)) {} \
<span class="lineNum">    4016 </span>            :         else if (!rep-&gt;_name &amp;&amp; !n_rep-&gt;_name) {}\
<span class="lineNum">    4017 </span>            :         else { \
<span class="lineNum">    4018 </span>            :                 if (rep-&gt;_name) gf_free(rep-&gt;_name); rep-&gt;_name = n_rep-&gt;_name ? gf_strdup(n_rep-&gt;_name) : NULL; \
<span class="lineNum">    4019 </span>            :                 transcode_detected = GF_TRUE; \
<span class="lineNum">    4020 </span>            :         }
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span>            : //for frac, if not set on source PID, consider it unchanged
<span class="lineNum">    4023 </span>            : #define CHECK_FRAC(_name) if (rep-&gt;_name &amp;&amp; n_rep-&gt;_name &amp;&amp; (rep-&gt;_name-&gt;num * n_rep-&gt;_name-&gt;den == rep-&gt;_name-&gt;den * n_rep-&gt;_name-&gt;num)) {} \
<span class="lineNum">    4024 </span>            :         else if (!n_rep-&gt;_name) {}\
<span class="lineNum">    4025 </span>            :         else { \
<span class="lineNum">    4026 </span>            :                 if (rep-&gt;_name) gf_free(rep-&gt;_name); \
<span class="lineNum">    4027 </span>            :                 if (n_rep-&gt;_name) { rep-&gt;_name = gf_malloc(sizeof(GF_MPD_Fractional)); memcpy(rep-&gt;_name, n_rep-&gt;_name, sizeof(GF_MPD_Fractional)); } \
<span class="lineNum">    4028 </span>            :                 else rep-&gt;_name = NULL; \
<span class="lineNum">    4029 </span>            :                 transcode_detected = GF_TRUE; \
<span class="lineNum">    4030 </span>            :         }
<span class="lineNum">    4031 </span>            : 
<span class="lineNum">    4032 </span><span class="lineCov">          6 :         CHECK_STR(codecs)</span>
<span class="lineNum">    4033 </span><span class="lineCov">          6 :         CHECK_STR(profiles)</span>
<span class="lineNum">    4034 </span><span class="lineCov">          6 :         CHECK_STR(mime_type)</span>
<span class="lineNum">    4035 </span><span class="lineCov">          6 :         CHECK_STR(segmentProfiles)</span>
<span class="lineNum">    4036 </span><span class="lineCov">          6 :         CHECK_VAL(width, 1)</span>
<span class="lineNum">    4037 </span><span class="lineCov">          6 :         CHECK_VAL(height, 1)</span>
<span class="lineNum">    4038 </span><span class="lineCov">          6 :         CHECK_VAL(bandwidth, 0)</span>
<span class="lineNum">    4039 </span><span class="lineCov">          6 :         CHECK_VAL(samplerate, 0)</span>
<span class="lineNum">    4040 </span><span class="lineCov">          6 :         CHECK_VAL(scan_type, 0)</span>
<span class="lineNum">    4041 </span><span class="lineCov">          6 :         CHECK_FRAC(sar)</span>
<span class="lineNum">    4042 </span><span class="lineCov">          6 :         CHECK_FRAC(framerate)</span>
<span class="lineNum">    4043 </span>            : 
<span class="lineNum">    4044 </span><span class="lineCov">          6 :         if (transcode_detected &amp;&amp; !ds-&gt;transcode_detected) {</span>
<span class="lineNum">    4045 </span><span class="lineNoCov">          0 :                 ds-&gt;transcode_detected = GF_TRUE;</span>
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Transcoded detected in forward mode, not fully tested !\n&quot;));</span>
<span class="lineNum">    4047 </span>            :         }
<span class="lineNum">    4048 </span>            : #undef CHECK_VAL
<span class="lineNum">    4049 </span>            : #undef CHECK_STR
<span class="lineNum">    4050 </span>            : #undef CHECK_FRAC
<span class="lineNum">    4051 </span>            : 
<a name="4052"><span class="lineNum">    4052 </span><span class="lineCov">          6 :         return recompute_set;</span></a>
<span class="lineNum">    4053 </span>            : }
<span class="lineNum">    4054 </span><span class="lineCov">          4 : static void dasher_forward_manifest_raw(GF_DasherCtx *ctx, GF_DashStream *ds, const char *manifest, const char *manifest_name)</span>
<span class="lineNum">    4055 </span>            : {
<span class="lineNum">    4056 </span>            :         GF_FilterPacket *pck;
<span class="lineNum">    4057 </span>            :         u32 size;
<span class="lineNum">    4058 </span>            :         u8 *output;
<span class="lineNum">    4059 </span>            : 
<span class="lineNum">    4060 </span><span class="lineCov">          4 :         size = (u32) strlen(manifest);</span>
<span class="lineNum">    4061 </span>            : 
<span class="lineNum">    4062 </span><span class="lineCov">          4 :         pck = gf_filter_pck_new_alloc(ctx-&gt;opid, size+1, &amp;output);</span>
<span class="lineNum">    4063 </span><span class="lineCov">          4 :         if (!pck) return;</span>
<span class="lineNum">    4064 </span>            : 
<span class="lineNum">    4065 </span><span class="lineCov">          4 :         memcpy(output, manifest, size);</span>
<span class="lineNum">    4066 </span><span class="lineCov">          4 :         output[size] = 0;</span>
<span class="lineNum">    4067 </span><span class="lineCov">          4 :         gf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);</span>
<span class="lineNum">    4068 </span><span class="lineCov">          4 :         gf_filter_pck_set_seek_flag(pck, GF_TRUE);</span>
<span class="lineNum">    4069 </span><span class="lineCov">          4 :         if (manifest_name) {</span>
<span class="lineNum">    4070 </span><span class="lineCov">          3 :                 if (ctx-&gt;out_path) {</span>
<span class="lineNum">    4071 </span><span class="lineCov">          3 :                         char *url = gf_url_concatenate(ctx-&gt;out_path, manifest_name);</span>
<span class="lineNum">    4072 </span><span class="lineCov">          3 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &amp;PROP_STRING_NO_COPY(url) );</span>
<span class="lineNum">    4073 </span>            :                 } else {
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &amp;PROP_STRING(manifest_name) );</span>
<span class="lineNum">    4075 </span>            :                 }
<span class="lineNum">    4076 </span><span class="lineCov">          3 :                 if (ds)</span>
<span class="lineNum">    4077 </span><span class="lineCov">          3 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_REF, &amp;PROP_LONGUINT( ds-&gt;hls_ref_id ) );</span>
<span class="lineNum">    4078 </span>            :         }
<span class="lineNum">    4079 </span><span class="lineCov">          4 :         gf_filter_pck_send(pck);</span>
<a name="4080"><span class="lineNum">    4080 </span>            : </a>
<span class="lineNum">    4081 </span>            : }
<span class="lineNum">    4082 </span><span class="lineCov">          2 : static void dasher_forward_mpd(GF_DasherCtx *ctx, const char *manifest)</span>
<span class="lineNum">    4083 </span>            : {
<span class="lineNum">    4084 </span>            :         u32 i, nb_periods, nb_streams;
<span class="lineNum">    4085 </span>            :         FILE *tmp = NULL;
<span class="lineNum">    4086 </span><span class="lineCov">          2 :         GF_MPD *mpd = gf_mpd_new();</span>
<span class="lineNum">    4087 </span>            :         GF_List *recompute_sets = NULL;
<span class="lineNum">    4088 </span><span class="lineCov">          2 :         GF_DOMParser *dom = gf_xml_dom_new();</span>
<span class="lineNum">    4089 </span><span class="lineCov">          2 :         GF_Err e = gf_xml_dom_parse_string(dom, (char *)manifest);</span>
<span class="lineNum">    4090 </span><span class="lineCov">          2 :         if (e) goto err_exit;</span>
<span class="lineNum">    4091 </span>            : 
<span class="lineNum">    4092 </span><span class="lineCov">          2 :         e = gf_mpd_init_from_dom(gf_xml_dom_get_root(dom), mpd, NULL);</span>
<span class="lineNum">    4093 </span><span class="lineCov">          2 :         if (e) goto err_exit;</span>
<span class="lineNum">    4094 </span>            : 
<span class="lineNum">    4095 </span><span class="lineCov">          2 :         nb_streams = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    4096 </span><span class="lineCov">          2 :         nb_periods = gf_list_count(mpd-&gt;periods);</span>
<span class="lineNum">    4097 </span><span class="lineCov">          4 :         for (i=0; i&lt;nb_periods; i++) {</span>
<span class="lineNum">    4098 </span>            :                 u32 j;
<span class="lineNum">    4099 </span><span class="lineCov">          2 :                 GF_MPD_AdaptationSet *set = NULL;</span>
<span class="lineNum">    4100 </span><span class="lineCov">          2 :                 GF_MPD_Representation *rep = NULL;</span>
<span class="lineNum">    4101 </span><span class="lineCov">          2 :                 GF_MPD_Period *period = gf_list_get(mpd-&gt;periods, i);</span>
<span class="lineNum">    4102 </span><span class="lineCov">          8 :                 for (j=0; j&lt;nb_streams; j++) {</span>
<span class="lineNum">    4103 </span>            :                         Bool invalidate_set;
<span class="lineNum">    4104 </span><span class="lineCov">          6 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;pids, j);</span>
<span class="lineNum">    4105 </span><span class="lineCov">          6 :                         if (ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    4106 </span><span class="lineCov">          6 :                         const GF_PropertyValue *ps = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_DASH_PERIOD_START);</span>
<span class="lineNum">    4107 </span><span class="lineCov">          6 :                         const GF_PropertyValue *repid = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_REP_ID);</span>
<span class="lineNum">    4108 </span><span class="lineCov">          6 :                         if (!ps || !repid) {</span>
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't fetch period start or rep ID in forward mode, cannot forward\n&quot;));</span>
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 :                                 goto err_exit;</span>
<span class="lineNum">    4111 </span>            :                         }
<span class="lineNum">    4112 </span><span class="lineCov">          6 :                         if (period-&gt;start != ps-&gt;value.longuint) continue;</span>
<span class="lineNum">    4113 </span><span class="lineCov">          6 :                         dasher_get_set_and_rep(period, repid-&gt;value.string, &amp;set, &amp;rep);</span>
<span class="lineNum">    4114 </span><span class="lineCov">          6 :                         if (!set || !rep) {</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't locate adaptation set and period in source manifest in forward mode, cannot forward\n&quot;));</span>
<span class="lineNum">    4116 </span>            :                                 goto err_exit;
<span class="lineNum">    4117 </span>            :                         }
<span class="lineNum">    4118 </span>            :                         //copy/reset common encryption
<span class="lineNum">    4119 </span><span class="lineCov">          6 :                         if (set-&gt;content_protection) {</span>
<span class="lineNum">    4120 </span><span class="lineCov">          6 :                                 gf_mpd_del_list(set-&gt;content_protection, gf_mpd_descriptor_free, 1);</span>
<span class="lineNum">    4121 </span>            :                         }
<span class="lineNum">    4122 </span><span class="lineCov">          6 :                         if (rep-&gt;content_protection) {</span>
<span class="lineNum">    4123 </span><span class="lineCov">          6 :                                 gf_mpd_del_list(rep-&gt;content_protection, gf_mpd_descriptor_free, 1);</span>
<span class="lineNum">    4124 </span>            :                         }
<span class="lineNum">    4125 </span><span class="lineCov">          6 :                         if (gf_list_count(ds-&gt;rep-&gt;content_protection)) {</span>
<span class="lineNum">    4126 </span><span class="lineNoCov">          0 :                                 gf_list_del(rep-&gt;content_protection);</span>
<span class="lineNum">    4127 </span><span class="lineNoCov">          0 :                                 rep-&gt;content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);</span>
<span class="lineNum">    4128 </span>            :                         }
<span class="lineNum">    4129 </span><span class="lineCov">          6 :                         if (gf_list_count(ds-&gt;set-&gt;content_protection)) {</span>
<span class="lineNum">    4130 </span><span class="lineCov">          6 :                                 gf_list_del(set-&gt;content_protection);</span>
<span class="lineNum">    4131 </span><span class="lineCov">          6 :                                 set-&gt;content_protection = dasher_get_content_protection_desc(ctx, ds, ds-&gt;set);</span>
<span class="lineNum">    4132 </span>            :                         }
<span class="lineNum">    4133 </span><span class="lineCov">          6 :                         invalidate_set = dasher_merge_rep(ds, rep);</span>
<span class="lineNum">    4134 </span>            :                         //wait until we are all done
<span class="lineNum">    4135 </span><span class="lineCov">          6 :                         if (invalidate_set) {</span>
<span class="lineNum">    4136 </span><span class="lineNoCov">          0 :                                 if (!recompute_sets) recompute_sets = gf_list_new();</span>
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :                                 if (gf_list_find(recompute_sets, set)&lt;0)</span>
<span class="lineNum">    4138 </span><span class="lineNoCov">          0 :                                         gf_list_add(recompute_sets, set);</span>
<span class="lineNum">    4139 </span>            : 
<span class="lineNum">    4140 </span>            :                         }
<span class="lineNum">    4141 </span>            :                 }
<span class="lineNum">    4142 </span>            :         }
<span class="lineNum">    4143 </span>            :         //update sets - TODO
<span class="lineNum">    4144 </span>            : 
<span class="lineNum">    4145 </span>            :         //and send
<span class="lineNum">    4146 </span><span class="lineCov">          2 :         tmp = gf_file_temp(NULL);</span>
<span class="lineNum">    4147 </span><span class="lineCov">          2 :         mpd-&gt;xml_namespace = ctx-&gt;mpd-&gt;xml_namespace;</span>
<span class="lineNum">    4148 </span><span class="lineCov">          2 :         mpd-&gt;publishTime = dasher_get_utc(ctx);</span>
<span class="lineNum">    4149 </span><span class="lineCov">          2 :         e = gf_mpd_write(mpd, tmp, ctx-&gt;cmpd);</span>
<span class="lineNum">    4150 </span><span class="lineCov">          2 :         if (e) {</span>
<span class="lineNum">    4151 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Error serializing manifest in forward mode: %s\n&quot;, gf_error_to_string(e) ));</span>
<span class="lineNum">    4152 </span>            :                 e = GF_OK;
<span class="lineNum">    4153 </span>            :                 goto err_exit;
<span class="lineNum">    4154 </span>            :         }
<span class="lineNum">    4155 </span><span class="lineCov">          2 :         dasher_transfer_file(tmp, ctx-&gt;opid, NULL, NULL);</span>
<span class="lineNum">    4156 </span>            : 
<span class="lineNum">    4157 </span><span class="lineCov">          2 : err_exit:</span>
<span class="lineNum">    4158 </span><span class="lineCov">          2 :         if (tmp) gf_fclose(tmp);</span>
<span class="lineNum">    4159 </span><span class="lineCov">          2 :         gf_mpd_del(mpd);</span>
<span class="lineNum">    4160 </span><span class="lineCov">          2 :         gf_xml_dom_del(dom);</span>
<span class="lineNum">    4161 </span><span class="lineCov">          2 :         gf_list_del(recompute_sets);</span>
<span class="lineNum">    4162 </span><span class="lineCov">          2 :         if (e)</span>
<span class="lineNum">    4163 </span><span class="lineNoCov">          0 :                 ctx-&gt;in_error = GF_TRUE;</span>
<a name="4164"><span class="lineNum">    4164 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">    4165 </span>            : 
<span class="lineNum">    4166 </span><span class="lineCov">        658 : static GF_Err dasher_write_and_send_manifest(GF_DasherCtx *ctx, u64 last_period_dur, Bool do_m3u8, Bool m3u8_second_pass, GF_FilterPid *opid, char *alt_name)</span>
<span class="lineNum">    4167 </span>            : {
<span class="lineNum">    4168 </span>            :         void *last_signature;
<span class="lineNum">    4169 </span>            :         u8 sig[GF_SHA1_DIGEST_SIZE];
<span class="lineNum">    4170 </span>            :         GF_Err e;
<span class="lineNum">    4171 </span><span class="lineCov">        658 :         FILE *tmp = gf_file_temp(NULL);</span>
<span class="lineNum">    4172 </span><span class="lineCov">        658 :         if (do_m3u8) {</span>
<span class="lineNum">    4173 </span><span class="lineCov">        386 :                 ctx-&gt;mpd-&gt;m3u8_time = ctx-&gt;hlsc;</span>
<span class="lineNum">    4174 </span><span class="lineCov">        386 :                 if (ctx-&gt;llhls==3)</span>
<span class="lineNum">    4175 </span><span class="lineCov">         42 :                         ctx-&gt;mpd-&gt;force_llhls_mode = m3u8_second_pass ? 2 : 1;</span>
<span class="lineNum">    4176 </span>            :                 else
<span class="lineNum">    4177 </span><span class="lineCov">        344 :                         ctx-&gt;mpd-&gt;force_llhls_mode = 0;</span>
<span class="lineNum">    4178 </span>            : 
<span class="lineNum">    4179 </span><span class="lineCov">        386 :                 if (m3u8_second_pass) {</span>
<span class="lineNum">    4180 </span><span class="lineCov">         21 :                         e = gf_mpd_write_m3u8_master_playlist(ctx-&gt;mpd, tmp, ctx-&gt;out_path, gf_list_get(ctx-&gt;mpd-&gt;periods, 0) );</span>
<span class="lineNum">    4181 </span>            :                 } else {
<span class="lineNum">    4182 </span><span class="lineCov">        365 :                         e = gf_mpd_write_m3u8_master_playlist(ctx-&gt;mpd, tmp, ctx-&gt;out_path, gf_list_get(ctx-&gt;mpd-&gt;periods, 0) );</span>
<span class="lineNum">    4183 </span>            :                 }
<span class="lineNum">    4184 </span>            :         } else {
<span class="lineNum">    4185 </span><span class="lineCov">        272 :                 e = gf_mpd_write(ctx-&gt;mpd, tmp, ctx-&gt;cmpd);</span>
<span class="lineNum">    4186 </span>            :         }
<span class="lineNum">    4187 </span>            : 
<span class="lineNum">    4188 </span><span class="lineCov">        658 :         if (e) {</span>
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] failed to write %s file: %s\n&quot;, do_m3u8 ? &quot;M3U8&quot; : &quot;MPD&quot;, gf_error_to_string(e) ));</span>
<span class="lineNum">    4190 </span><span class="lineNoCov">          0 :                 gf_fclose(tmp);</span>
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;current_period-&gt;period)</span>
<span class="lineNum">    4192 </span><span class="lineNoCov">          0 :                         ctx-&gt;current_period-&gt;period-&gt;duration = last_period_dur;</span>
<span class="lineNum">    4193 </span>            :                 return e;
<span class="lineNum">    4194 </span>            :         }
<span class="lineNum">    4195 </span>            : 
<span class="lineNum">    4196 </span><span class="lineCov">        658 :         if (ctx-&gt;profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {</span>
<span class="lineNum">    4197 </span><span class="lineNoCov">          0 :                 if (gf_ftell(tmp) &gt; 100 * 1024)</span>
<span class="lineNum">    4198 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] manifest MPD is too big for HbbTV 1.5. Limit is 100kB, current size is &quot;LLU&quot;kB\n&quot;, gf_ftell(tmp) / 1024));</span>
<span class="lineNum">    4199 </span>            :         }
<span class="lineNum">    4200 </span>            : 
<span class="lineNum">    4201 </span><span class="lineCov">        658 :         gf_sha1_file_ptr(tmp, sig);</span>
<span class="lineNum">    4202 </span><span class="lineCov">        658 :         if (do_m3u8) {</span>
<span class="lineNum">    4203 </span><span class="lineCov">        386 :                 last_signature = (void *) m3u8_second_pass ? ctx-&gt;last_hls2_signature : ctx-&gt;last_hls_signature;</span>
<span class="lineNum">    4204 </span>            :         } else {
<span class="lineNum">    4205 </span><span class="lineCov">        272 :                 last_signature = (void *) ctx-&gt;last_mpd_signature;</span>
<span class="lineNum">    4206 </span>            :         }
<span class="lineNum">    4207 </span>            : 
<span class="lineNum">    4208 </span><span class="lineCov">        658 :         if (memcmp(sig, last_signature, GF_SHA1_DIGEST_SIZE)) {</span>
<span class="lineNum">    4209 </span>            :                 memcpy(last_signature, sig, GF_SHA1_DIGEST_SIZE);
<span class="lineNum">    4210 </span>            : 
<span class="lineNum">    4211 </span><span class="lineCov">        416 :                 dasher_transfer_file(tmp, opid, alt_name, NULL);</span>
<span class="lineNum">    4212 </span>            :         }
<span class="lineNum">    4213 </span><span class="lineCov">        658 :         gf_fclose(tmp);</span>
<span class="lineNum">    4214 </span><span class="lineCov">        658 :         return GF_OK;</span>
<a name="4215"><span class="lineNum">    4215 </span>            : }</a>
<span class="lineNum">    4216 </span>            : 
<span class="lineNum">    4217 </span><span class="lineCov">        253 : static void dasher_update_dyn_bitrates(GF_DasherCtx *ctx)</span>
<span class="lineNum">    4218 </span>            : {
<span class="lineNum">    4219 </span><span class="lineCov">        253 :         u32 i, count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    4220 </span><span class="lineCov">        530 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    4221 </span><span class="lineCov">        277 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    4222 </span><span class="lineCov">        277 :                 if (ds-&gt;dyn_bitrate) dasher_update_bitrate(ctx, ds);</span>
<span class="lineNum">    4223 </span>            :         }
<a name="4224"><span class="lineNum">    4224 </span><span class="lineCov">        253 : }</span></a>
<span class="lineNum">    4225 </span>            : 
<span class="lineNum">    4226 </span><span class="lineCov">        638 : GF_Err dasher_send_manifest(GF_Filter *filter, GF_DasherCtx *ctx, Bool for_mpd_only)</span>
<span class="lineNum">    4227 </span>            : {
<span class="lineNum">    4228 </span>            :         GF_Err e;
<span class="lineNum">    4229 </span>            :         u32 i, max_opid;
<span class="lineNum">    4230 </span>            :         FILE *tmp;
<span class="lineNum">    4231 </span>            :         u64 store_mpd_dur=0;
<span class="lineNum">    4232 </span>            :         u64 max_seg_dur=0;
<span class="lineNum">    4233 </span>            :         u64 last_period_dur;
<span class="lineNum">    4234 </span>            : 
<span class="lineNum">    4235 </span>            :         //manifest forwarding
<span class="lineNum">    4236 </span><span class="lineCov">        638 :         if (ctx-&gt;forward_mode == DASHER_FWD_ALL)</span>
<span class="lineNum">    4237 </span>            :                 return GF_OK;
<span class="lineNum">    4238 </span>            : 
<span class="lineNum">    4239 </span><span class="lineCov">        635 :         if (ctx-&gt;dyn_rate)</span>
<span class="lineNum">    4240 </span><span class="lineCov">        209 :                 dasher_update_dyn_bitrates(ctx);</span>
<span class="lineNum">    4241 </span>            : 
<span class="lineNum">    4242 </span>            :         //UGLY PATCH, to remove - we don't have the same algos in old arch and new arch, which result in slightly different max segment duration
<span class="lineNum">    4243 </span>            :         //on audio for our test suite - patch it manually to avoid hash failures :(
<span class="lineNum">    4244 </span>            :         //TODO, remove as soon as we switch archs
<span class="lineNum">    4245 </span><span class="lineCov">        635 :         if (gf_sys_old_arch_compat() &amp;&amp; (ctx-&gt;mpd-&gt;max_segment_duration==1022) &amp;&amp; (ctx-&gt;mpd-&gt;media_presentation_duration==10160) ) {</span>
<span class="lineNum">    4246 </span><span class="lineCov">          1 :                 ctx-&gt;mpd-&gt;max_segment_duration = 1080;</span>
<span class="lineNum">    4247 </span><span class="lineCov">          1 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] patch for old regression tests hit, changing max seg dur from 1022 to 1080\nPlease notify GPAC devs to remove this, and do not use fot_test modes in dash filter\n&quot;));</span>
<span class="lineNum">    4248 </span>            :         }
<span class="lineNum">    4249 </span>            : 
<span class="lineNum">    4250 </span><span class="lineCov">       1270 :         ctx-&gt;mpd-&gt;publishTime = dasher_get_utc(ctx);</span>
<span class="lineNum">    4251 </span><span class="lineCov">        635 :         if (ctx-&gt;utc_timing_type==DASHER_UTCREF_INBAND) {</span>
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :                 GF_MPD_Descriptor *d = gf_list_get(ctx-&gt;mpd-&gt;utc_timings, 0);</span>
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :                 if (d) {</span>
<span class="lineNum">    4254 </span>            :                         time_t gtime;
<span class="lineNum">    4255 </span>            :                         struct tm *t;
<span class="lineNum">    4256 </span>            :                         u32 sec;
<span class="lineNum">    4257 </span>            :                         u32 ms;
<span class="lineNum">    4258 </span>            :                         char szTime[100];
<span class="lineNum">    4259 </span><span class="lineNoCov">          0 :                         if (d-&gt;value) gf_free(d-&gt;value);</span>
<span class="lineNum">    4260 </span>            : 
<span class="lineNum">    4261 </span><span class="lineNoCov">          0 :                         gtime = ctx-&gt;mpd-&gt;publishTime / 1000;</span>
<span class="lineNum">    4262 </span><span class="lineNoCov">          0 :                         sec = (u32)(ctx-&gt;mpd-&gt;publishTime / 1000);</span>
<span class="lineNum">    4263 </span><span class="lineNoCov">          0 :                         ms = (u32)(ctx-&gt;mpd-&gt;publishTime - ((u64)sec) * 1000);</span>
<span class="lineNum">    4264 </span>            : 
<span class="lineNum">    4265 </span><span class="lineNoCov">          0 :                         t = gf_gmtime(&amp;gtime);</span>
<span class="lineNum">    4266 </span><span class="lineNoCov">          0 :                         sec = t-&gt;tm_sec;</span>
<span class="lineNum">    4267 </span>            :                         //see issue #859, no clue how this happened...
<span class="lineNum">    4268 </span><span class="lineNoCov">          0 :                         if (sec &gt; 60)</span>
<span class="lineNum">    4269 </span>            :                                 sec = 60;
<span class="lineNum">    4270 </span><span class="lineNoCov">          0 :                         snprintf(szTime, 100, &quot;%d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, 1900 + t-&gt;tm_year, t-&gt;tm_mon + 1, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, sec, ms);</span>
<span class="lineNum">    4271 </span><span class="lineNoCov">          0 :                         d-&gt;value = gf_strdup(szTime);</span>
<span class="lineNum">    4272 </span>            :                 }
<span class="lineNum">    4273 </span>            :         }
<span class="lineNum">    4274 </span><span class="lineCov">        635 :         dasher_update_mpd(ctx);</span>
<span class="lineNum">    4275 </span><span class="lineCov">        635 :         ctx-&gt;mpd-&gt;write_context = GF_FALSE;</span>
<span class="lineNum">    4276 </span><span class="lineCov">        635 :         ctx-&gt;mpd-&gt;was_dynamic = GF_FALSE;</span>
<span class="lineNum">    4277 </span><span class="lineCov">        635 :         if (ctx-&gt;dmode==GF_DASH_DYNAMIC_LAST)</span>
<span class="lineNum">    4278 </span><span class="lineCov">          8 :                 ctx-&gt;mpd-&gt;was_dynamic = GF_TRUE;</span>
<span class="lineNum">    4279 </span>            : 
<span class="lineNum">    4280 </span><span class="lineCov">        635 :         if ((ctx-&gt;refresh&gt;=0) &amp;&amp; (ctx-&gt;dmode==GF_DASH_DYNAMIC)) {</span>
<span class="lineNum">    4281 </span><span class="lineCov">        408 :                 store_mpd_dur= ctx-&gt;mpd-&gt;media_presentation_duration;</span>
<span class="lineNum">    4282 </span>            :         }
<span class="lineNum">    4283 </span>            : 
<span class="lineNum">    4284 </span><span class="lineCov">        635 :         if (ctx-&gt;sseg &amp;&amp; ctx-&gt;mpd-&gt;max_segment_duration) {</span>
<span class="lineNum">    4285 </span><span class="lineCov">         18 :                 max_seg_dur = ctx-&gt;mpd-&gt;max_subsegment_duration = ctx-&gt;mpd-&gt;max_segment_duration;</span>
<span class="lineNum">    4286 </span><span class="lineCov">         18 :                 ctx-&gt;mpd-&gt;max_segment_duration = 0;</span>
<span class="lineNum">    4287 </span>            :         }
<span class="lineNum">    4288 </span>            : 
<span class="lineNum">    4289 </span>            :         last_period_dur = 0;
<span class="lineNum">    4290 </span><span class="lineCov">        635 :         if (ctx-&gt;current_period-&gt;period) {</span>
<span class="lineNum">    4291 </span><span class="lineCov">        635 :                 last_period_dur = ctx-&gt;current_period-&gt;period-&gt;duration;</span>
<span class="lineNum">    4292 </span><span class="lineCov">        635 :                 if (ctx-&gt;dmode==GF_DASH_DYNAMIC) {</span>
<span class="lineNum">    4293 </span><span class="lineCov">        408 :                         ctx-&gt;current_period-&gt;period-&gt;duration = 0;</span>
<span class="lineNum">    4294 </span><span class="lineCov">        408 :                         ctx-&gt;mpd-&gt;media_presentation_duration = 0;</span>
<span class="lineNum">    4295 </span>            :                 }
<span class="lineNum">    4296 </span>            :         }
<span class="lineNum">    4297 </span>            : 
<span class="lineNum">    4298 </span><span class="lineCov">        635 :         max_opid = (ctx-&gt;dual &amp;&amp; ctx-&gt;opid_alt) ? 2 : 1;</span>
<span class="lineNum">    4299 </span><span class="lineCov">       1272 :         for (i=0; i &lt; max_opid; i++) {</span>
<span class="lineNum">    4300 </span>            :                 Bool do_m3u8 = GF_FALSE;
<span class="lineNum">    4301 </span>            :                 GF_FilterPid *opid;
<span class="lineNum">    4302 </span>            : 
<span class="lineNum">    4303 </span><span class="lineCov">        637 :                 if (i==0) {</span>
<span class="lineNum">    4304 </span><span class="lineCov">        635 :                         if (max_opid&gt;1) {</span>
<span class="lineNum">    4305 </span><span class="lineCov">          2 :                                 do_m3u8 = ctx-&gt;opid_alt_m3u8 ? GF_FALSE : GF_TRUE;</span>
<span class="lineNum">    4306 </span>            :                         } else {
<span class="lineNum">    4307 </span><span class="lineCov">        633 :                                 do_m3u8 = ctx-&gt;do_m3u8;</span>
<span class="lineNum">    4308 </span>            :                         }
<span class="lineNum">    4309 </span><span class="lineCov">        635 :                         opid = ctx-&gt;opid;</span>
<span class="lineNum">    4310 </span>            :                 } else {
<span class="lineNum">    4311 </span><span class="lineCov">          2 :                         do_m3u8 = ctx-&gt;opid_alt_m3u8;</span>
<span class="lineNum">    4312 </span><span class="lineCov">          2 :                         opid = ctx-&gt;opid_alt;</span>
<span class="lineNum">    4313 </span>            :                 }
<span class="lineNum">    4314 </span><span class="lineCov">        637 :                 if (do_m3u8 &amp;&amp; for_mpd_only) {</span>
<span class="lineNum">    4315 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    4316 </span>            :                 }
<span class="lineNum">    4317 </span><span class="lineCov">        637 :                 if ((ctx-&gt;llhls==3) &amp;&amp; do_m3u8)</span>
<span class="lineNum">    4318 </span><span class="lineCov">         21 :                         ctx-&gt;mpd-&gt;force_llhls_mode = 1;</span>
<span class="lineNum">    4319 </span><span class="lineCov">        637 :                 e = dasher_write_and_send_manifest(ctx, last_period_dur, do_m3u8, GF_FALSE, opid, NULL);</span>
<span class="lineNum">    4320 </span><span class="lineCov">        637 :                 if (e) return e;</span>
<span class="lineNum">    4321 </span>            : 
<span class="lineNum">    4322 </span><span class="lineCov">        637 :                 ctx-&gt;mpd-&gt;force_llhls_mode = 0;</span>
<span class="lineNum">    4323 </span>            :         }
<span class="lineNum">    4324 </span>            : 
<span class="lineNum">    4325 </span><span class="lineCov">        635 :         if (ctx-&gt;current_period-&gt;period)</span>
<span class="lineNum">    4326 </span><span class="lineCov">        635 :                 ctx-&gt;current_period-&gt;period-&gt;duration = last_period_dur;</span>
<span class="lineNum">    4327 </span>            : 
<span class="lineNum">    4328 </span><span class="lineCov">        635 :         if (store_mpd_dur) {</span>
<span class="lineNum">    4329 </span><span class="lineCov">        303 :                 ctx-&gt;mpd-&gt;media_presentation_duration = store_mpd_dur;</span>
<span class="lineNum">    4330 </span>            :         }
<span class="lineNum">    4331 </span><span class="lineCov">        635 :         if (max_seg_dur) {</span>
<span class="lineNum">    4332 </span><span class="lineCov">         18 :                 ctx-&gt;mpd-&gt;max_segment_duration = (u32) max_seg_dur;</span>
<span class="lineNum">    4333 </span><span class="lineCov">         18 :                 ctx-&gt;mpd-&gt;max_subsegment_duration = 0;</span>
<span class="lineNum">    4334 </span>            :         }
<span class="lineNum">    4335 </span>            : 
<span class="lineNum">    4336 </span><span class="lineCov">        635 :         if (ctx-&gt;do_m3u8) {</span>
<span class="lineNum">    4337 </span>            :                 Bool m3u8_second_pass = GF_FALSE;
<span class="lineNum">    4338 </span>            :                 u32 j;
<span class="lineNum">    4339 </span><span class="lineCov">        365 :                 GF_MPD_Period *period = gf_list_get(ctx-&gt;mpd-&gt;periods, 0);</span>
<span class="lineNum">    4340 </span>            :                 GF_MPD_AdaptationSet *as;
<span class="lineNum">    4341 </span>            :                 GF_MPD_Representation *rep;
<span class="lineNum">    4342 </span>            :                 GF_FilterPid *opid;
<span class="lineNum">    4343 </span>            :                 assert(period);
<span class="lineNum">    4344 </span><span class="lineCov">        365 :                 if (ctx-&gt;opid_alt_m3u8) opid = ctx-&gt;opid_alt;</span>
<span class="lineNum">    4345 </span><span class="lineCov">        365 :                 else opid = ctx-&gt;opid;</span>
<span class="lineNum">    4346 </span>            : 
<span class="lineNum">    4347 </span><span class="lineCov">        365 : resend:</span>
<span class="lineNum">    4348 </span><span class="lineCov">        386 :                 i=0;</span>
<span class="lineNum">    4349 </span><span class="lineCov">       1168 :                 while ( (as = (GF_MPD_AdaptationSet *) gf_list_enum(period-&gt;adaptation_sets, &amp;i))) {</span>
<span class="lineNum">    4350 </span><span class="lineCov">        396 :                         j=0;</span>
<span class="lineNum">    4351 </span><span class="lineCov">       1388 :                         while ( (rep = (GF_MPD_Representation *) gf_list_enum(as-&gt;representations, &amp;j))) {</span>
<span class="lineNum">    4352 </span><span class="lineCov">        596 :                                 if (rep-&gt;m3u8_var_file) {</span>
<span class="lineNum">    4353 </span>            :                                         GF_DashStream *ds;
<span class="lineNum">    4354 </span><span class="lineCov">        596 :                                         char *outfile = rep-&gt;m3u8_var_name;</span>
<span class="lineNum">    4355 </span>            :                                         Bool do_free = GF_FALSE;
<span class="lineNum">    4356 </span>            : 
<span class="lineNum">    4357 </span><span class="lineCov">        596 :                                         if (rep-&gt;m3u8_name) {</span>
<span class="lineNum">    4358 </span>            :                                                 outfile = (char *) rep-&gt;m3u8_name;
<span class="lineNum">    4359 </span><span class="lineNoCov">          0 :                                                 if (ctx-&gt;out_path) {</span>
<span class="lineNum">    4360 </span><span class="lineNoCov">          0 :                                                         outfile = gf_url_concatenate(ctx-&gt;out_path, rep-&gt;m3u8_name);</span>
<span class="lineNum">    4361 </span>            :                                                         do_free = GF_TRUE;
<span class="lineNum">    4362 </span>            :                                                 }
<span class="lineNum">    4363 </span>            :                                         }
<span class="lineNum">    4364 </span><span class="lineCov">        596 :                                         if (m3u8_second_pass) {</span>
<span class="lineNum">    4365 </span>            :                                                 char *sep;
<span class="lineNum">    4366 </span><span class="lineCov">         21 :                                                 char *new_name = gf_strdup(outfile);</span>
<span class="lineNum">    4367 </span>            : 
<span class="lineNum">    4368 </span><span class="lineCov">         21 :                                                 sep = gf_file_ext_start(new_name);</span>
<span class="lineNum">    4369 </span><span class="lineCov">         21 :                                                 if (sep) sep[0] = 0;</span>
<span class="lineNum">    4370 </span><span class="lineCov">         21 :                                                 gf_dynstrcat(&amp;new_name, &quot;_IF&quot;, NULL);</span>
<span class="lineNum">    4371 </span><span class="lineCov">         21 :                                                 sep = gf_file_ext_start(outfile);</span>
<span class="lineNum">    4372 </span><span class="lineCov">         21 :                                                 if (sep)</span>
<span class="lineNum">    4373 </span><span class="lineCov">         21 :                                                         gf_dynstrcat(&amp;new_name, sep, NULL);</span>
<span class="lineNum">    4374 </span>            : 
<span class="lineNum">    4375 </span><span class="lineCov">         21 :                                                 if (do_free) gf_free(outfile);</span>
<span class="lineNum">    4376 </span><span class="lineCov">         21 :                                                 outfile = new_name;</span>
<span class="lineNum">    4377 </span>            :                                                 do_free = GF_TRUE;
<span class="lineNum">    4378 </span>            :                                         }
<span class="lineNum">    4379 </span><span class="lineCov">        596 :                                         ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    4380 </span><span class="lineCov">        596 :                                         dasher_transfer_file(rep-&gt;m3u8_var_file, opid, outfile, ds);</span>
<span class="lineNum">    4381 </span><span class="lineCov">        596 :                                         gf_fclose(rep-&gt;m3u8_var_file);</span>
<span class="lineNum">    4382 </span><span class="lineCov">        596 :                                         rep-&gt;m3u8_var_file = NULL;</span>
<span class="lineNum">    4383 </span><span class="lineCov">        596 :                                         if (do_free) gf_free(outfile);</span>
<span class="lineNum">    4384 </span>            :                                 }
<span class="lineNum">    4385 </span>            :                         }
<span class="lineNum">    4386 </span>            :                 }
<span class="lineNum">    4387 </span>            : 
<span class="lineNum">    4388 </span><span class="lineCov">        386 :                 if ((ctx-&gt;llhls==3) &amp;&amp; !m3u8_second_pass &amp;&amp; ctx-&gt;out_path) {</span>
<span class="lineNum">    4389 </span>            :                         char *sep;
<span class="lineNum">    4390 </span>            :                         char szAltName[GF_MAX_PATH];
<span class="lineNum">    4391 </span>            :                         strcpy(szAltName, ctx-&gt;out_path);
<span class="lineNum">    4392 </span><span class="lineCov">         21 :                         sep = gf_file_ext_start(szAltName);</span>
<span class="lineNum">    4393 </span><span class="lineCov">         21 :                         if (sep) sep[0] = 0;</span>
<span class="lineNum">    4394 </span>            :                         strcat(szAltName, &quot;_IF&quot;);
<span class="lineNum">    4395 </span><span class="lineCov">         21 :                         sep = gf_file_ext_start(ctx-&gt;out_path);</span>
<span class="lineNum">    4396 </span><span class="lineCov">         21 :                         if (sep) strcat(szAltName, sep);</span>
<span class="lineNum">    4397 </span>            : 
<span class="lineNum">    4398 </span><span class="lineCov">         21 :                         ctx-&gt;mpd-&gt;force_llhls_mode = 2;</span>
<span class="lineNum">    4399 </span><span class="lineCov">         21 :                         e = dasher_write_and_send_manifest(ctx, last_period_dur, GF_TRUE, GF_TRUE, ctx-&gt;opid, szAltName);</span>
<span class="lineNum">    4400 </span><span class="lineCov">         21 :                         if (e) return e;</span>
<span class="lineNum">    4401 </span>            : 
<span class="lineNum">    4402 </span>            :                         m3u8_second_pass = GF_TRUE;
<span class="lineNum">    4403 </span><span class="lineCov">         21 :                         goto resend;</span>
<span class="lineNum">    4404 </span>            : 
<span class="lineNum">    4405 </span>            :                 }
<span class="lineNum">    4406 </span>            :         }
<span class="lineNum">    4407 </span>            : 
<span class="lineNum">    4408 </span>            : 
<span class="lineNum">    4409 </span><span class="lineCov">        635 :         if (ctx-&gt;state) {</span>
<span class="lineNum">    4410 </span><span class="lineCov">         49 :                 tmp = gf_fopen(ctx-&gt;state, &quot;w&quot;);</span>
<span class="lineNum">    4411 </span><span class="lineCov">         49 :                 if (!tmp) {</span>
<span class="lineNum">    4412 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] failed to open context MPD %s for write\n&quot;, ctx-&gt;state ));</span>
<span class="lineNum">    4413 </span>            :                         return GF_IO_ERR;
<span class="lineNum">    4414 </span>            :                 }
<span class="lineNum">    4415 </span><span class="lineCov">         49 :                 ctx-&gt;mpd-&gt;write_context = GF_TRUE;</span>
<span class="lineNum">    4416 </span><span class="lineCov">         49 :                 e = gf_mpd_write(ctx-&gt;mpd, tmp, ctx-&gt;cmpd);</span>
<span class="lineNum">    4417 </span><span class="lineCov">         49 :                 gf_fclose(tmp);</span>
<span class="lineNum">    4418 </span><span class="lineCov">         49 :                 ctx-&gt;mpd-&gt;write_context = GF_FALSE;</span>
<span class="lineNum">    4419 </span><span class="lineCov">         49 :                 if (e) {</span>
<span class="lineNum">    4420 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] failed to write MPD file: %s\n&quot;, gf_error_to_string(e) ));</span>
<span class="lineNum">    4421 </span>            :                 }
<span class="lineNum">    4422 </span>            :                 return e;
<span class="lineNum">    4423 </span>            :         }
<span class="lineNum">    4424 </span>            :         return GF_OK;
<a name="4425"><span class="lineNum">    4425 </span>            : }</a>
<span class="lineNum">    4426 </span>            : 
<span class="lineNum">    4427 </span><span class="lineCov">        731 : static void dasher_reset_stream(GF_Filter *filter, GF_DashStream *ds, Bool is_destroy)</span>
<span class="lineNum">    4428 </span>            : {
<span class="lineNum">    4429 </span>            :         //we do not remove the destination filter, it will be removed automatically once all remove_pids are called
<span class="lineNum">    4430 </span>            :         //removing it explicetly will discard the upper chain and any packets not yet processed
<span class="lineNum">    4431 </span>            : 
<span class="lineNum">    4432 </span><span class="lineCov">        731 :         ds-&gt;dst_filter = NULL;</span>
<span class="lineNum">    4433 </span><span class="lineCov">        731 :         if (ds-&gt;seg_template) gf_free(ds-&gt;seg_template);</span>
<span class="lineNum">    4434 </span><span class="lineCov">        731 :         if (ds-&gt;idx_template) gf_free(ds-&gt;idx_template);</span>
<span class="lineNum">    4435 </span><span class="lineCov">        731 :         if (ds-&gt;init_seg) gf_free(ds-&gt;init_seg);</span>
<span class="lineNum">    4436 </span><span class="lineCov">        731 :         if (ds-&gt;multi_pids) gf_list_del(ds-&gt;multi_pids);</span>
<span class="lineNum">    4437 </span><span class="lineCov">        731 :         ds-&gt;multi_pids = NULL;</span>
<span class="lineNum">    4438 </span><span class="lineCov">        731 :         if (ds-&gt;multi_tracks) gf_list_del(ds-&gt;multi_tracks);</span>
<span class="lineNum">    4439 </span><span class="lineCov">        731 :         ds-&gt;multi_tracks = NULL;</span>
<span class="lineNum">    4440 </span>            : 
<span class="lineNum">    4441 </span><span class="lineCov">        731 :         if (ds-&gt;pending_segment_urls) gf_list_del(ds-&gt;pending_segment_urls);</span>
<span class="lineNum">    4442 </span><span class="lineCov">        731 :         ds-&gt;pending_segment_urls = NULL;</span>
<span class="lineNum">    4443 </span><span class="lineCov">        731 :         if (ds-&gt;pending_segment_states) gf_list_del(ds-&gt;pending_segment_states);</span>
<span class="lineNum">    4444 </span><span class="lineCov">        731 :         ds-&gt;pending_segment_states = NULL;</span>
<span class="lineNum">    4445 </span>            : 
<span class="lineNum">    4446 </span><span class="lineCov">        731 :         if (is_destroy) {</span>
<span class="lineNum">    4447 </span><span class="lineCov">        357 :                 if (ds-&gt;cues) gf_free(ds-&gt;cues);</span>
<span class="lineNum">    4448 </span><span class="lineCov">        357 :                 gf_list_del(ds-&gt;complementary_streams);</span>
<span class="lineNum">    4449 </span><span class="lineCov">        357 :                 gf_free(ds-&gt;rep_id);</span>
<span class="lineNum">    4450 </span>            :                 //string properties are locally copied
<span class="lineNum">    4451 </span>            : #define RESET_PROP_STR(_prop) \
<span class="lineNum">    4452 </span>            :                 if (_prop) gf_free(_prop);
<span class="lineNum">    4453 </span>            : 
<span class="lineNum">    4454 </span><span class="lineCov">        357 :                 RESET_PROP_STR(ds-&gt;src_url)</span>
<span class="lineNum">    4455 </span><span class="lineCov">        357 :                 RESET_PROP_STR(ds-&gt;template)</span>
<span class="lineNum">    4456 </span><span class="lineCov">        357 :                 RESET_PROP_STR(ds-&gt;lang)</span>
<span class="lineNum">    4457 </span><span class="lineCov">        357 :                 RESET_PROP_STR(ds-&gt;hls_vp_name)</span>
<span class="lineNum">    4458 </span><span class="lineCov">        357 :                 RESET_PROP_STR(ds-&gt;xlink)</span>
<span class="lineNum">    4459 </span><span class="lineCov">        357 :                 RESET_PROP_STR(ds-&gt;period_id)</span>
<span class="lineNum">    4460 </span><span class="lineCov">        357 :                 RESET_PROP_STR(ds-&gt;period_continuity_id)</span>
<span class="lineNum">    4461 </span>            : 
<span class="lineNum">    4462 </span>            : #undef RESET_PROP_STR
<span class="lineNum">    4463 </span>            :                 return;
<span class="lineNum">    4464 </span>            :         }
<span class="lineNum">    4465 </span><span class="lineCov">        374 :         ds-&gt;init_seg = ds-&gt;seg_template = ds-&gt;idx_template = NULL;</span>
<span class="lineNum">    4466 </span><span class="lineCov">        374 :         ds-&gt;split_set_names = GF_FALSE;</span>
<span class="lineNum">    4467 </span><span class="lineCov">        374 :         ds-&gt;nb_sap_3 = 0;</span>
<span class="lineNum">    4468 </span><span class="lineCov">        374 :         ds-&gt;nb_sap_4 = 0;</span>
<span class="lineNum">    4469 </span><span class="lineCov">        374 :         ds-&gt;pid_id = 0;</span>
<span class="lineNum">    4470 </span><span class="lineCov">        374 :         ds-&gt;force_timescale = 0;</span>
<span class="lineNum">    4471 </span><span class="lineCov">        374 :         ds-&gt;set = NULL;</span>
<span class="lineNum">    4472 </span><span class="lineCov">        374 :         ds-&gt;owns_set = GF_FALSE;</span>
<span class="lineNum">    4473 </span><span class="lineCov">        374 :         ds-&gt;rep = NULL;</span>
<span class="lineNum">    4474 </span><span class="lineCov">        374 :         ds-&gt;muxed_base = NULL;</span>
<span class="lineNum">    4475 </span><span class="lineCov">        374 :         ds-&gt;nb_comp = ds-&gt;nb_comp_done = 0;</span>
<span class="lineNum">    4476 </span><span class="lineCov">        374 :         gf_list_reset(ds-&gt;complementary_streams);</span>
<span class="lineNum">    4477 </span><span class="lineCov">        374 :         ds-&gt;inband_params = GF_FALSE;</span>
<span class="lineNum">    4478 </span><span class="lineCov">        374 :         ds-&gt;seg_start_time = 0;</span>
<span class="lineNum">    4479 </span><span class="lineCov">        374 :         ds-&gt;seg_number = ds-&gt;startNumber;</span>
<span class="lineNum">    4480 </span><span class="lineCov">        374 :         ds-&gt;nb_segments_purged = 0;</span>
<span class="lineNum">    4481 </span><span class="lineCov">        374 :         ds-&gt;dur_purged = 0;</span>
<span class="lineNum">    4482 </span><span class="lineCov">        374 :         ds-&gt;moof_sn_inc = 0;</span>
<span class="lineNum">    4483 </span><span class="lineCov">        374 :         ds-&gt;moof_sn = 0;</span>
<span class="lineNum">    4484 </span><span class="lineCov">        374 :         ds-&gt;seg_done = 0;</span>
<span class="lineNum">    4485 </span><span class="lineCov">        374 :         ds-&gt;subdur_done = 0;</span>
<span class="lineNum">    4486 </span><span class="lineCov">        374 :         if (ds-&gt;packet_queue) {</span>
<span class="lineNum">    4487 </span><span class="lineCov">          6 :                 while (gf_list_count(ds-&gt;packet_queue)) {</span>
<span class="lineNum">    4488 </span><span class="lineNoCov">          0 :                         GF_FilterPacket *pck = gf_list_pop_front(ds-&gt;packet_queue);</span>
<span class="lineNum">    4489 </span><span class="lineNoCov">          0 :                         gf_filter_pck_unref(pck);</span>
<span class="lineNum">    4490 </span>            :                 }
<span class="lineNum">    4491 </span><span class="lineCov">          6 :                 ds-&gt;nb_sap_in_queue = 0;</span>
<span class="lineNum">    4492 </span>            :         }
<a name="4493"><span class="lineNum">    4493 </span>            : }</a>
<span class="lineNum">    4494 </span>            : 
<span class="lineNum">    4495 </span><span class="lineCov">         32 : void dasher_context_update_period_end(GF_DasherCtx *ctx)</span>
<span class="lineNum">    4496 </span>            : {
<span class="lineNum">    4497 </span>            :         u32 i, count;
<span class="lineNum">    4498 </span>            : 
<span class="lineNum">    4499 </span><span class="lineCov">         32 :         if (!ctx-&gt;mpd) return;</span>
<span class="lineNum">    4500 </span>            : 
<span class="lineNum">    4501 </span><span class="lineCov">         32 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    4502 </span><span class="lineCov">         89 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    4503 </span><span class="lineCov">         57 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    4504 </span><span class="lineCov">         57 :                 if (!ds-&gt;rep) continue;</span>
<span class="lineNum">    4505 </span><span class="lineCov">         37 :                 if (!ds-&gt;rep-&gt;dasher_ctx) continue;</span>
<span class="lineNum">    4506 </span><span class="lineCov">         37 :                 if (ds-&gt;done == 1) {</span>
<span class="lineNum">    4507 </span><span class="lineCov">          6 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;done = 1;</span>
<span class="lineNum">    4508 </span>            :                 } else {
<span class="lineNum">    4509 </span>            :                         //store all dynamic parameters of the rep
<span class="lineNum">    4510 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;last_pck_idx = ds-&gt;nb_pck;</span>
<span class="lineNum">    4511 </span><span class="lineCov">         31 :                         ds-&gt;seek_to_pck = ds-&gt;nb_pck;</span>
<span class="lineNum">    4512 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;seg_number = ds-&gt;seg_number;</span>
<span class="lineNum">    4513 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;next_seg_start = ds-&gt;next_seg_start;</span>
<span class="lineNum">    4514 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;first_cts = ds-&gt;first_cts;</span>
<span class="lineNum">    4515 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;first_dts = ds-&gt;first_dts;</span>
<span class="lineNum">    4516 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;ts_offset = ds-&gt;ts_offset;</span>
<span class="lineNum">    4517 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;segs_purged = ds-&gt;nb_segments_purged;</span>
<span class="lineNum">    4518 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;dur_purged = ds-&gt;dur_purged;</span>
<span class="lineNum">    4519 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;moof_sn = ds-&gt;moof_sn;</span>
<span class="lineNum">    4520 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;moof_sn_inc = ds-&gt;moof_sn_inc;</span>
<span class="lineNum">    4521 </span><span class="lineCov">         31 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;subdur_forced = ds-&gt;subdur_forced_use_period_dur ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    4522 </span>            :                 }
<span class="lineNum">    4523 </span><span class="lineCov">         37 :                 if (ctx-&gt;subdur) {</span>
<span class="lineNum">    4524 </span><span class="lineCov">         35 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;cumulated_subdur = ds-&gt;cumulated_subdur + ctx-&gt;subdur;</span>
<span class="lineNum">    4525 </span><span class="lineCov">         35 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;cumulated_dur = ((Double)ds-&gt;cumulated_dur) / ds-&gt;timescale;</span>
<span class="lineNum">    4526 </span>            : 
<span class="lineNum">    4527 </span>            :                 }
<span class="lineNum">    4528 </span><span class="lineCov">         37 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;nb_repeat = ds-&gt;nb_repeat;</span>
<span class="lineNum">    4529 </span><span class="lineCov">         37 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;est_next_dts = ds-&gt;est_next_dts;</span>
<span class="lineNum">    4530 </span><span class="lineCov">         37 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;source_pid = ds-&gt;id;</span>
<span class="lineNum">    4531 </span><span class="lineCov">         37 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;mpd_timescale = ds-&gt;mpd_timescale;</span>
<span class="lineNum">    4532 </span><span class="lineCov">         37 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;last_dyn_period_id = ctx-&gt;last_dyn_period_id;</span>
<span class="lineNum">    4533 </span>            : 
<span class="lineNum">    4534 </span>            :                 assert(ds-&gt;rep-&gt;dasher_ctx-&gt;init_seg);
<span class="lineNum">    4535 </span>            :                 assert(ds-&gt;rep-&gt;dasher_ctx-&gt;src_url);
<span class="lineNum">    4536 </span>            :                 assert(ds-&gt;rep-&gt;dasher_ctx-&gt;template_seg);
<span class="lineNum">    4537 </span>            :         }
<a name="4538"><span class="lineNum">    4538 </span>            : }</a>
<span class="lineNum">    4539 </span>            : 
<span class="lineNum">    4540 </span><span class="lineCov">         14 : void dasher_context_update_period_start(GF_DasherCtx *ctx)</span>
<span class="lineNum">    4541 </span>            : {
<span class="lineNum">    4542 </span>            :         u32 i, j, count;
<span class="lineNum">    4543 </span>            : 
<span class="lineNum">    4544 </span><span class="lineCov">         14 :         if (!ctx-&gt;mpd) return;</span>
<span class="lineNum">    4545 </span><span class="lineCov">         14 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    4546 </span><span class="lineCov">         39 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    4547 </span><span class="lineCov">         25 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    4548 </span><span class="lineCov">         25 :                 if (!ds-&gt;rep) continue;</span>
<span class="lineNum">    4549 </span><span class="lineCov">         24 :                 if (ds-&gt;rep-&gt;dasher_ctx) continue;</span>
<span class="lineNum">    4550 </span>            : 
<span class="lineNum">    4551 </span>            :                 //store all static parameters of the rep
<span class="lineNum">    4552 </span><span class="lineCov">         24 :                 GF_SAFEALLOC(ds-&gt;rep-&gt;dasher_ctx, GF_DASH_SegmenterContext);</span>
<span class="lineNum">    4553 </span><span class="lineCov">         24 :                 if (!ds-&gt;rep-&gt;dasher_ctx) return;</span>
<span class="lineNum">    4554 </span>            : 
<span class="lineNum">    4555 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;done = 0;</span>
<span class="lineNum">    4556 </span>            : 
<span class="lineNum">    4557 </span>            :                 assert(ds-&gt;init_seg);
<span class="lineNum">    4558 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;init_seg = gf_strdup(ds-&gt;init_seg);</span>
<span class="lineNum">    4559 </span>            :                 assert(ds-&gt;src_url);
<span class="lineNum">    4560 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;src_url = gf_strdup(ds-&gt;src_url);</span>
<span class="lineNum">    4561 </span>            :                 assert(ds-&gt;seg_template);
<span class="lineNum">    4562 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;template_seg = gf_strdup(ds-&gt;seg_template);</span>
<span class="lineNum">    4563 </span><span class="lineCov">         24 :                 if (ds-&gt;idx_template)</span>
<span class="lineNum">    4564 </span><span class="lineNoCov">          0 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;template_idx = gf_strdup(ds-&gt;idx_template);</span>
<span class="lineNum">    4565 </span>            : 
<span class="lineNum">    4566 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;pid_id = ds-&gt;pid_id;</span>
<span class="lineNum">    4567 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;dep_pid_id = ds-&gt;dep_pid_id;</span>
<span class="lineNum">    4568 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;period_start = ds-&gt;period_start;</span>
<span class="lineNum">    4569 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;period_duration = ds-&gt;period_dur;</span>
<span class="lineNum">    4570 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;multi_pids = ds-&gt;multi_pids ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    4571 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;dash_dur = ds-&gt;dash_dur;</span>
<span class="lineNum">    4572 </span>            : 
<span class="lineNum">    4573 </span><span class="lineCov">         24 :                 if (strcmp(ds-&gt;period_id, DEFAULT_PERIOD_ID))</span>
<span class="lineNum">    4574 </span><span class="lineNoCov">          0 :                         ds-&gt;rep-&gt;dasher_ctx-&gt;period_id = ds-&gt;period_id;</span>
<span class="lineNum">    4575 </span>            : 
<span class="lineNum">    4576 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;owns_set = (ds-&gt;set-&gt;udta == ds) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    4577 </span>            : 
<span class="lineNum">    4578 </span><span class="lineCov">         24 :                 if (ds-&gt;rep-&gt;dasher_ctx-&gt;mux_pids) gf_free(ds-&gt;rep-&gt;dasher_ctx-&gt;mux_pids);</span>
<span class="lineNum">    4579 </span><span class="lineCov">         24 :                 ds-&gt;rep-&gt;dasher_ctx-&gt;mux_pids = NULL;</span>
<span class="lineNum">    4580 </span><span class="lineCov">         69 :                 for (j=0; j&lt;count; j++) {</span>
<span class="lineNum">    4581 </span>            :                         char szMuxPID[10];
<span class="lineNum">    4582 </span><span class="lineCov">         45 :                         GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    4583 </span><span class="lineCov">         89 :                         if (a_ds==ds) continue;</span>
<span class="lineNum">    4584 </span><span class="lineCov">         21 :                         if (a_ds-&gt;muxed_base != ds) continue;</span>
<span class="lineNum">    4585 </span>            : 
<span class="lineNum">    4586 </span><span class="lineCov">          1 :                         if (ds-&gt;rep-&gt;dasher_ctx-&gt;mux_pids)</span>
<span class="lineNum">    4587 </span><span class="lineNoCov">          0 :                                 sprintf(szMuxPID, &quot; %d&quot;, a_ds-&gt;id);</span>
<span class="lineNum">    4588 </span>            :                         else
<span class="lineNum">    4589 </span><span class="lineCov">          1 :                                 sprintf(szMuxPID, &quot;%d&quot;, a_ds-&gt;id);</span>
<span class="lineNum">    4590 </span>            : 
<span class="lineNum">    4591 </span><span class="lineCov">          1 :                         gf_dynstrcat(&amp;ds-&gt;rep-&gt;dasher_ctx-&gt;mux_pids, szMuxPID, NULL);</span>
<span class="lineNum">    4592 </span>            :                 }
<span class="lineNum">    4593 </span>            : 
<span class="lineNum">    4594 </span>            :         }
<a name="4595"><span class="lineNum">    4595 </span>            : }</a>
<span class="lineNum">    4596 </span>            : 
<span class="lineNum">    4597 </span><span class="lineCov">         34 : static GF_DashStream *dasher_get_stream(GF_DasherCtx *ctx, const char *src_url, u32 original_pid, u32 pid_id)</span>
<span class="lineNum">    4598 </span>            : {
<span class="lineNum">    4599 </span><span class="lineCov">         34 :         u32 i, count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    4600 </span><span class="lineCov">         14 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    4601 </span><span class="lineCov">         48 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    4602 </span><span class="lineCov">         48 :                 if (pid_id &amp;&amp; (ds-&gt;pid_id==pid_id)) return ds;</span>
<span class="lineNum">    4603 </span><span class="lineCov">         48 :                 if (src_url &amp;&amp; ds-&gt;src_url &amp;&amp; !strcmp(ds-&gt;src_url, src_url) &amp;&amp; (ds-&gt;id == original_pid) ) return ds;</span>
<span class="lineNum">    4604 </span>            :         }
<span class="lineNum">    4605 </span>            :         return NULL;
<a name="4606"><span class="lineNum">    4606 </span>            : }</a>
<span class="lineNum">    4607 </span>            : 
<span class="lineNum">    4608 </span><span class="lineCov">          4 : static GF_Err dasher_reload_muxed_comp(GF_DasherCtx *ctx, GF_DashStream *base_ds, char *mux_pids, Bool check_only)</span>
<span class="lineNum">    4609 </span>            : {
<span class="lineNum">    4610 </span>            :         GF_Err e = GF_OK;
<span class="lineNum">    4611 </span><span class="lineCov">          8 :         while (mux_pids) {</span>
<span class="lineNum">    4612 </span>            :                 u32 pid_id;
<span class="lineNum">    4613 </span>            :                 GF_DashStream *ds;
<span class="lineNum">    4614 </span><span class="lineCov">          4 :                 char *sep = strchr(mux_pids, ' ');</span>
<span class="lineNum">    4615 </span><span class="lineCov">          4 :                 if (sep) sep[0] = 0;</span>
<span class="lineNum">    4616 </span>            : 
<span class="lineNum">    4617 </span><span class="lineCov">          4 :                 pid_id = atoi(mux_pids);</span>
<span class="lineNum">    4618 </span><span class="lineCov">          4 :                 ds = dasher_get_stream(ctx, base_ds-&gt;src_url, pid_id, 0);</span>
<span class="lineNum">    4619 </span><span class="lineCov">          4 :                 if (ds) {</span>
<span class="lineNum">    4620 </span><span class="lineCov">          4 :                         if (!check_only) {</span>
<span class="lineNum">    4621 </span><span class="lineCov">          2 :                                 if (ds-&gt;rep) gf_mpd_representation_free(ds-&gt;rep);</span>
<span class="lineNum">    4622 </span><span class="lineCov">          2 :                                 ds-&gt;rep = NULL;</span>
<span class="lineNum">    4623 </span><span class="lineCov">          2 :                                 ds-&gt;set = base_ds-&gt;set;</span>
<span class="lineNum">    4624 </span><span class="lineCov">          2 :                                 ds-&gt;muxed_base = base_ds;</span>
<span class="lineNum">    4625 </span><span class="lineCov">          2 :                                 base_ds-&gt;nb_comp ++;</span>
<span class="lineNum">    4626 </span><span class="lineCov">          2 :                                 ds-&gt;nb_comp = 1;</span>
<span class="lineNum">    4627 </span><span class="lineCov">          2 :                                 ds-&gt;done = base_ds-&gt;done;</span>
<span class="lineNum">    4628 </span><span class="lineCov">          2 :                                 ds-&gt;subdur_done = base_ds-&gt;subdur_done;</span>
<span class="lineNum">    4629 </span><span class="lineCov">          2 :                                 ds-&gt;period = ctx-&gt;current_period;</span>
<span class="lineNum">    4630 </span>            : 
<span class="lineNum">    4631 </span><span class="lineCov">          2 :                                 gf_list_del_item(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">    4632 </span><span class="lineCov">          2 :                                 gf_list_add(ctx-&gt;current_period-&gt;streams, ds);</span>
<span class="lineNum">    4633 </span>            :                         }
<span class="lineNum">    4634 </span>            :                 } else {
<span class="lineNum">    4635 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't find muxed PID %d in source %s, did you modify the source ?\n&quot;, pid_id, base_ds-&gt;src_url));</span>
<span class="lineNum">    4636 </span>            :                         e = GF_BAD_PARAM;
<span class="lineNum">    4637 </span>            :                 }
<span class="lineNum">    4638 </span>            : 
<span class="lineNum">    4639 </span><span class="lineCov">          4 :                 if (!sep) break;</span>
<span class="lineNum">    4640 </span><span class="lineNoCov">          0 :                 sep[0] = ' ';</span>
<span class="lineNum">    4641 </span><span class="lineNoCov">          0 :                 mux_pids = sep+1;</span>
<span class="lineNum">    4642 </span>            : 
<span class="lineNum">    4643 </span><span class="lineNoCov">          0 :                 if (e) return e;</span>
<span class="lineNum">    4644 </span>            :         }
<span class="lineNum">    4645 </span>            :         return GF_OK;
<a name="4646"><span class="lineNum">    4646 </span>            : }</a>
<span class="lineNum">    4647 </span>            : 
<span class="lineNum">    4648 </span><span class="lineCov">         21 : static GF_Err dasher_reload_context(GF_Filter *filter, GF_DasherCtx *ctx)</span>
<span class="lineNum">    4649 </span>            : {
<span class="lineNum">    4650 </span>            :         GF_Err e;
<span class="lineNum">    4651 </span>            :         Bool last_period_active = GF_FALSE;
<span class="lineNum">    4652 </span>            :         u32 i, j, k, nb_p, nb_as, nb_rep, count;
<span class="lineNum">    4653 </span>            :         GF_DOMParser *mpd_parser;
<span class="lineNum">    4654 </span>            : 
<span class="lineNum">    4655 </span><span class="lineCov">         21 :         ctx-&gt;first_context_load = GF_FALSE;</span>
<span class="lineNum">    4656 </span>            : 
<span class="lineNum">    4657 </span><span class="lineCov">         21 :         if (!gf_file_exists(ctx-&gt;state)) return GF_OK;</span>
<span class="lineNum">    4658 </span>            : 
<span class="lineNum">    4659 </span>            :         /* parse the MPD */
<span class="lineNum">    4660 </span><span class="lineCov">         10 :         mpd_parser = gf_xml_dom_new();</span>
<span class="lineNum">    4661 </span><span class="lineCov">         10 :         e = gf_xml_dom_parse(mpd_parser, ctx-&gt;state, NULL, NULL);</span>
<span class="lineNum">    4662 </span>            : 
<span class="lineNum">    4663 </span><span class="lineCov">         10 :         if (e != GF_OK) {</span>
<span class="lineNum">    4664 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Cannot parse MPD state %s: %s\n&quot;, ctx-&gt;state, gf_xml_dom_get_error(mpd_parser) ));</span>
<span class="lineNum">    4665 </span><span class="lineNoCov">          0 :                 gf_xml_dom_del(mpd_parser);</span>
<span class="lineNum">    4666 </span><span class="lineNoCov">          0 :                 return GF_URL_ERROR;</span>
<span class="lineNum">    4667 </span>            :         }
<span class="lineNum">    4668 </span><span class="lineCov">         10 :         if (ctx-&gt;mpd) gf_mpd_del(ctx-&gt;mpd);</span>
<span class="lineNum">    4669 </span><span class="lineCov">         10 :         ctx-&gt;mpd = gf_mpd_new();</span>
<span class="lineNum">    4670 </span><span class="lineCov">         10 :         e = gf_mpd_init_from_dom(gf_xml_dom_get_root(mpd_parser), ctx-&gt;mpd, ctx-&gt;state);</span>
<span class="lineNum">    4671 </span><span class="lineCov">         10 :         gf_xml_dom_del(mpd_parser);</span>
<span class="lineNum">    4672 </span>            :         //test mode, strip URL path
<span class="lineNum">    4673 </span><span class="lineCov">         10 :         if (gf_sys_is_test_mode()) {</span>
<span class="lineNum">    4674 </span><span class="lineCov">         10 :                 count = gf_list_count(ctx-&gt;mpd-&gt;program_infos);</span>
<span class="lineNum">    4675 </span><span class="lineCov">         20 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    4676 </span><span class="lineCov">         10 :                         GF_MPD_ProgramInfo *info = gf_list_get(ctx-&gt;mpd-&gt;program_infos, i);</span>
<span class="lineNum">    4677 </span><span class="lineCov">         10 :                         if (info-&gt;title &amp;&amp; strstr(info-&gt;title, &quot;generated by GPAC&quot;)) {</span>
<span class="lineNum">    4678 </span><span class="lineCov">         10 :                                 gf_free(info-&gt;title);</span>
<span class="lineNum">    4679 </span>            :                                 char tmp[256];
<span class="lineNum">    4680 </span><span class="lineCov">         10 :                                 char *name = strrchr(ctx-&gt;out_path, '/');</span>
<span class="lineNum">    4681 </span><span class="lineCov">         10 :                                 if (!name) name = strrchr(ctx-&gt;out_path, '\\');</span>
<span class="lineNum">    4682 </span><span class="lineCov">         10 :                                 if (!name) name = ctx-&gt;out_path;</span>
<span class="lineNum">    4683 </span><span class="lineCov">         10 :                                 else name++;</span>
<span class="lineNum">    4684 </span>            :                                 sprintf(tmp, &quot;%s generated by GPAC&quot;, name);
<span class="lineNum">    4685 </span><span class="lineCov">         10 :                                 info-&gt;title = gf_strdup(tmp);</span>
<span class="lineNum">    4686 </span>            :                         }
<span class="lineNum">    4687 </span>            :                 }
<span class="lineNum">    4688 </span>            :         }
<span class="lineNum">    4689 </span>            : 
<span class="lineNum">    4690 </span><span class="lineCov">         10 :         if (!ctx-&gt;mpd-&gt;xml_namespace)</span>
<span class="lineNum">    4691 </span><span class="lineCov">         10 :                 ctx-&gt;mpd-&gt;xml_namespace = &quot;urn:mpeg:dash:schema:mpd:2011&quot;;</span>
<span class="lineNum">    4692 </span>            : 
<span class="lineNum">    4693 </span><span class="lineCov">         10 :         if (e != GF_OK) {</span>
<span class="lineNum">    4694 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Cannot reload MPD state %s: %s\n&quot;, ctx-&gt;state, gf_error_to_string(e) ));</span>
<span class="lineNum">    4695 </span><span class="lineNoCov">          0 :                 gf_mpd_del(ctx-&gt;mpd);</span>
<span class="lineNum">    4696 </span><span class="lineNoCov">          0 :                 ctx-&gt;mpd = NULL;</span>
<span class="lineNum">    4697 </span><span class="lineNoCov">          0 :                 return GF_URL_ERROR;</span>
<span class="lineNum">    4698 </span>            :         }
<span class="lineNum">    4699 </span>            : 
<span class="lineNum">    4700 </span>            :         //do a first pass to detect any potential changes in input config, if so consider the period over.
<span class="lineNum">    4701 </span><span class="lineCov">         10 :         nb_p = gf_list_count(ctx-&gt;mpd-&gt;periods);</span>
<span class="lineNum">    4702 </span><span class="lineCov">         20 :         for (i=0; i&lt;nb_p; i++) {</span>
<span class="lineNum">    4703 </span>            :                 u32 nb_done_in_period = 0;
<span class="lineNum">    4704 </span>            :                 u32 nb_remain_in_period = 0;
<span class="lineNum">    4705 </span><span class="lineCov">         10 :                 GF_MPD_Period *p = gf_list_get(ctx-&gt;mpd-&gt;periods, i);</span>
<span class="lineNum">    4706 </span><span class="lineCov">         10 :                 nb_as = gf_list_count(p-&gt;adaptation_sets);</span>
<span class="lineNum">    4707 </span><span class="lineCov">         25 :                 for (j=0; j&lt;nb_as; j++) {</span>
<span class="lineNum">    4708 </span><span class="lineCov">         15 :                         GF_MPD_AdaptationSet *set = gf_list_get(p-&gt;adaptation_sets, j);</span>
<span class="lineNum">    4709 </span><span class="lineCov">         15 :                         nb_rep = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    4710 </span><span class="lineCov">         30 :                         for (k=0; k&lt;nb_rep; k++) {</span>
<span class="lineNum">    4711 </span>            :                                 GF_DashStream *ds;
<span class="lineNum">    4712 </span>            :                                 char *p_id;
<span class="lineNum">    4713 </span><span class="lineCov">         15 :                                 GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, k);</span>
<span class="lineNum">    4714 </span><span class="lineCov">         15 :                                 if (! rep-&gt;dasher_ctx) continue;</span>
<span class="lineNum">    4715 </span>            : 
<span class="lineNum">    4716 </span>            :                                 //ensure we have the same settings - if not consider the dash stream has been resetup for a new period
<span class="lineNum">    4717 </span><span class="lineCov">         15 :                                 ds = dasher_get_stream(ctx, rep-&gt;dasher_ctx-&gt;src_url, rep-&gt;dasher_ctx-&gt;source_pid, 0);</span>
<span class="lineNum">    4718 </span><span class="lineCov">         15 :                                 if (!ds) {</span>
<span class="lineNum">    4719 </span><span class="lineNoCov">          0 :                                         rep-&gt;dasher_ctx-&gt;done = 1;</span>
<span class="lineNum">    4720 </span><span class="lineNoCov">          0 :                                         nb_done_in_period++;</span>
<span class="lineNum">    4721 </span><span class="lineNoCov">          0 :                                         if (rep-&gt;dasher_ctx-&gt;last_dyn_period_id &gt;= ctx-&gt;last_dyn_period_id)</span>
<span class="lineNum">    4722 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;last_dyn_period_id = 1 + rep-&gt;dasher_ctx-&gt;last_dyn_period_id;</span>
<span class="lineNum">    4723 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    4724 </span>            :                                 }
<span class="lineNum">    4725 </span>            : 
<span class="lineNum">    4726 </span><span class="lineCov">         15 :                                 if (rep-&gt;dasher_ctx-&gt;done) {</span>
<span class="lineNum">    4727 </span><span class="lineNoCov">          0 :                                         nb_done_in_period++;</span>
<span class="lineNum">    4728 </span><span class="lineNoCov">          0 :                                         ds-&gt;nb_repeat = rep-&gt;dasher_ctx-&gt;nb_repeat + 1;</span>
<span class="lineNum">    4729 </span><span class="lineNoCov">          0 :                                         if (rep-&gt;dasher_ctx-&gt;last_dyn_period_id &gt; ctx-&gt;last_dyn_period_id)</span>
<span class="lineNum">    4730 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;last_dyn_period_id = rep-&gt;dasher_ctx-&gt;last_dyn_period_id;</span>
<span class="lineNum">    4731 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    4732 </span>            :                                 }
<span class="lineNum">    4733 </span>            : 
<span class="lineNum">    4734 </span>            :                                 p_id = DEFAULT_PERIOD_ID;
<span class="lineNum">    4735 </span><span class="lineCov">         15 :                                 if (rep-&gt;dasher_ctx-&gt;period_id) p_id = rep-&gt;dasher_ctx-&gt;period_id;</span>
<span class="lineNum">    4736 </span>            : 
<span class="lineNum">    4737 </span><span class="lineCov">         15 :                                 if (ds-&gt;period_id &amp;&amp; p_id &amp;&amp; !strcmp(ds-&gt;period_id, p_id)) {</span>
<span class="lineNum">    4738 </span><span class="lineNoCov">          0 :                                 } else if (!ds-&gt;period_id &amp;&amp; !rep-&gt;dasher_ctx-&gt;period_id) {</span>
<span class="lineNum">    4739 </span>            :                                 } else {
<span class="lineNum">    4740 </span><span class="lineNoCov">          0 :                                         rep-&gt;dasher_ctx-&gt;done = 1;</span>
<span class="lineNum">    4741 </span><span class="lineNoCov">          0 :                                         nb_done_in_period++;</span>
<span class="lineNum">    4742 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    4743 </span>            :                                 }
<span class="lineNum">    4744 </span><span class="lineCov">         15 :                                 if (ds-&gt;period_start.num * rep-&gt;dasher_ctx-&gt;period_start.den != rep-&gt;dasher_ctx-&gt;period_start.num * ds-&gt;period_start.den) {</span>
<span class="lineNum">    4745 </span><span class="lineNoCov">          0 :                                         rep-&gt;dasher_ctx-&gt;done = 1;</span>
<span class="lineNum">    4746 </span><span class="lineNoCov">          0 :                                         nb_done_in_period++;</span>
<span class="lineNum">    4747 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    4748 </span>            :                                 }
<span class="lineNum">    4749 </span><span class="lineCov">         15 :                                 if (ds-&gt;period_dur.num * rep-&gt;dasher_ctx-&gt;period_duration.den != rep-&gt;dasher_ctx-&gt;period_duration.num * ds-&gt;period_dur.den) {</span>
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :                                         rep-&gt;dasher_ctx-&gt;done = 1;</span>
<span class="lineNum">    4751 </span><span class="lineNoCov">          0 :                                         nb_done_in_period++;</span>
<span class="lineNum">    4752 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    4753 </span>            :                                 }
<span class="lineNum">    4754 </span>            :                                 //check we can reload muxed components - if not consider this source as removed
<span class="lineNum">    4755 </span><span class="lineCov">         15 :                                 if (rep-&gt;dasher_ctx-&gt;mux_pids) {</span>
<span class="lineNum">    4756 </span><span class="lineCov">          2 :                                         e = dasher_reload_muxed_comp(ctx, ds, rep-&gt;dasher_ctx-&gt;mux_pids, GF_TRUE);</span>
<span class="lineNum">    4757 </span><span class="lineCov">          2 :                                         if (e) {</span>
<span class="lineNum">    4758 </span><span class="lineNoCov">          0 :                                                 rep-&gt;dasher_ctx-&gt;done = 1;</span>
<span class="lineNum">    4759 </span><span class="lineNoCov">          0 :                                                 nb_done_in_period++;</span>
<span class="lineNum">    4760 </span><span class="lineNoCov">          0 :                                                 continue;</span>
<span class="lineNum">    4761 </span>            :                                         }
<span class="lineNum">    4762 </span>            :                                 }
<span class="lineNum">    4763 </span><span class="lineCov">         15 :                                 nb_remain_in_period++;</span>
<span class="lineNum">    4764 </span>            :                         }
<span class="lineNum">    4765 </span>            :                 }
<span class="lineNum">    4766 </span><span class="lineCov">         10 :                 if (nb_remain_in_period) {</span>
<span class="lineNum">    4767 </span>            :                         assert(i+1==nb_p);
<span class="lineNum">    4768 </span>            :                         last_period_active = GF_TRUE;
<span class="lineNum">    4769 </span>            :                 }
<span class="lineNum">    4770 </span><span class="lineNoCov">          0 :                 else if (nb_done_in_period &amp;&amp; ctx-&gt;subdur  ) {</span>
<span class="lineNum">    4771 </span>            :                         //we are done but we loop the entire streams
<span class="lineNum">    4772 </span><span class="lineNoCov">          0 :                         for (j=0; j&lt;gf_list_count(ctx-&gt;pids); j++) {</span>
<span class="lineNum">    4773 </span><span class="lineNoCov">          0 :                                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, j);</span>
<span class="lineNum">    4774 </span><span class="lineNoCov">          0 :                                 ds-&gt;done = 0;</span>
<span class="lineNum">    4775 </span><span class="lineNoCov">          0 :                                 ds-&gt;segment_started = GF_FALSE;</span>
<span class="lineNum">    4776 </span><span class="lineNoCov">          0 :                                 ds-&gt;seg_done = GF_FALSE;</span>
<span class="lineNum">    4777 </span><span class="lineNoCov">          0 :                                 ds-&gt;cumulated_dur = 0;</span>
<span class="lineNum">    4778 </span><span class="lineNoCov">          0 :                                 ds-&gt;cumulated_subdur = 0;</span>
<span class="lineNum">    4779 </span>            :                         }
<span class="lineNum">    4780 </span>            :                 }
<span class="lineNum">    4781 </span>            :         }
<span class="lineNum">    4782 </span>            : 
<span class="lineNum">    4783 </span><span class="lineCov">         10 :         if (!last_period_active) return GF_OK;</span>
<span class="lineNum">    4784 </span><span class="lineCov">         10 :         ctx-&gt;current_period-&gt;period = gf_list_last(ctx-&gt;mpd-&gt;periods);</span>
<span class="lineNum">    4785 </span><span class="lineCov">         10 :         gf_list_reset(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    4786 </span><span class="lineCov">         10 :         gf_list_del(ctx-&gt;next_period-&gt;streams);</span>
<span class="lineNum">    4787 </span><span class="lineCov">         10 :         ctx-&gt;next_period-&gt;streams = gf_list_clone(ctx-&gt;pids);</span>
<span class="lineNum">    4788 </span>            : 
<span class="lineNum">    4789 </span><span class="lineCov">         10 :         if (ctx-&gt;current_period-&gt;period-&gt;duration) {</span>
<span class="lineNum">    4790 </span>            :                 //reset last period duration and cumulated dur of MPD
<span class="lineNum">    4791 </span><span class="lineCov">          1 :                 if (ctx-&gt;mpd-&gt;media_presentation_duration&gt;ctx-&gt;current_period-&gt;period-&gt;duration)</span>
<span class="lineNum">    4792 </span><span class="lineNoCov">          0 :                         ctx-&gt;mpd-&gt;media_presentation_duration -= ctx-&gt;current_period-&gt;period-&gt;duration;</span>
<span class="lineNum">    4793 </span>            :                 else
<span class="lineNum">    4794 </span><span class="lineCov">          1 :                         ctx-&gt;mpd-&gt;media_presentation_duration = 0;</span>
<span class="lineNum">    4795 </span><span class="lineCov">          1 :                 ctx-&gt;current_period-&gt;period-&gt;duration = 0;</span>
<span class="lineNum">    4796 </span>            :         }
<span class="lineNum">    4797 </span>            : 
<span class="lineNum">    4798 </span><span class="lineCov">         10 :         nb_as = gf_list_count(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets);</span>
<span class="lineNum">    4799 </span><span class="lineCov">         25 :         for (j=0; j&lt;nb_as; j++) {</span>
<span class="lineNum">    4800 </span>            :                 GF_DashStream *set_ds = NULL;
<span class="lineNum">    4801 </span>            :                 GF_List *multi_pids = NULL;
<span class="lineNum">    4802 </span>            :                 Bool use_multi_pid_init = GF_FALSE;
<span class="lineNum">    4803 </span><span class="lineCov">         15 :                 GF_MPD_AdaptationSet *set = gf_list_get(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets, j);</span>
<span class="lineNum">    4804 </span><span class="lineCov">         15 :                 nb_rep = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    4805 </span><span class="lineCov">         30 :                 for (k=0; k&lt;nb_rep; k++) {</span>
<span class="lineNum">    4806 </span>            :                         GF_DashStream *ds;
<span class="lineNum">    4807 </span><span class="lineCov">         15 :                         GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, k);</span>
<span class="lineNum">    4808 </span><span class="lineCov">         15 :                         if (! rep-&gt;dasher_ctx) continue;</span>
<span class="lineNum">    4809 </span>            : 
<span class="lineNum">    4810 </span><span class="lineCov">         15 :                         ds = dasher_get_stream(ctx, rep-&gt;dasher_ctx-&gt;src_url, rep-&gt;dasher_ctx-&gt;source_pid, 0);</span>
<span class="lineNum">    4811 </span><span class="lineCov">         15 :                         if (!ds) continue;</span>
<span class="lineNum">    4812 </span>            : 
<span class="lineNum">    4813 </span>            :                         //restore everything
<span class="lineNum">    4814 </span><span class="lineCov">         15 :                         ds-&gt;done = rep-&gt;dasher_ctx-&gt;done;</span>
<span class="lineNum">    4815 </span><span class="lineCov">         15 :                         ds-&gt;seg_number = rep-&gt;dasher_ctx-&gt;seg_number;</span>
<span class="lineNum">    4816 </span>            : 
<span class="lineNum">    4817 </span><span class="lineCov">         15 :                         if (ds-&gt;init_seg) gf_free(ds-&gt;init_seg);</span>
<span class="lineNum">    4818 </span><span class="lineCov">         15 :                         ds-&gt;init_seg = gf_strdup(rep-&gt;dasher_ctx-&gt;init_seg);</span>
<span class="lineNum">    4819 </span>            : 
<span class="lineNum">    4820 </span><span class="lineCov">         15 :                         if (ds-&gt;seg_template) gf_free(ds-&gt;seg_template);</span>
<span class="lineNum">    4821 </span><span class="lineCov">         15 :                         ds-&gt;seg_template = gf_strdup(rep-&gt;dasher_ctx-&gt;template_seg);</span>
<span class="lineNum">    4822 </span>            : 
<span class="lineNum">    4823 </span><span class="lineCov">         15 :                         if (ds-&gt;idx_template) gf_free(ds-&gt;idx_template);</span>
<span class="lineNum">    4824 </span><span class="lineCov">         15 :                         ds-&gt;idx_template = rep-&gt;dasher_ctx-&gt;template_idx ? gf_strdup(rep-&gt;dasher_ctx-&gt;template_idx) : NULL;</span>
<span class="lineNum">    4825 </span>            : 
<span class="lineNum">    4826 </span><span class="lineCov">         15 :                         if (rep-&gt;dasher_ctx-&gt;period_id) {</span>
<span class="lineNum">    4827 </span><span class="lineNoCov">          0 :                                 if (ds-&gt;period_id) gf_free(ds-&gt;period_id);</span>
<span class="lineNum">    4828 </span><span class="lineNoCov">          0 :                                 ds-&gt;period_id = gf_strdup(rep-&gt;dasher_ctx-&gt;period_id);</span>
<span class="lineNum">    4829 </span>            :                         }
<span class="lineNum">    4830 </span>            : 
<span class="lineNum">    4831 </span><span class="lineCov">         15 :                         ds-&gt;period_start = rep-&gt;dasher_ctx-&gt;period_start;</span>
<span class="lineNum">    4832 </span><span class="lineCov">         15 :                         if (!ds-&gt;period_start.den) {</span>
<span class="lineNum">    4833 </span><span class="lineCov">         15 :                                 ds-&gt;period_start.num = 0;</span>
<span class="lineNum">    4834 </span><span class="lineCov">         15 :                                 ds-&gt;period_start.den = 1;</span>
<span class="lineNum">    4835 </span>            :                         }
<span class="lineNum">    4836 </span><span class="lineCov">         15 :                         ds-&gt;period_dur = rep-&gt;dasher_ctx-&gt;period_duration;</span>
<span class="lineNum">    4837 </span><span class="lineCov">         15 :                         if (!ds-&gt;period_dur.den) {</span>
<span class="lineNum">    4838 </span><span class="lineCov">         15 :                                 ds-&gt;period_dur.num = 0;</span>
<span class="lineNum">    4839 </span><span class="lineCov">         15 :                                 ds-&gt;period_dur.den = 1;</span>
<span class="lineNum">    4840 </span>            :                         }
<span class="lineNum">    4841 </span><span class="lineCov">         15 :                         ds-&gt;pid_id = rep-&gt;dasher_ctx-&gt;pid_id;</span>
<span class="lineNum">    4842 </span><span class="lineCov">         15 :                         ds-&gt;dep_pid_id = rep-&gt;dasher_ctx-&gt;dep_pid_id;</span>
<span class="lineNum">    4843 </span><span class="lineCov">         15 :                         ds-&gt;seek_to_pck = rep-&gt;dasher_ctx-&gt;last_pck_idx;</span>
<span class="lineNum">    4844 </span><span class="lineCov">         15 :                         ds-&gt;dash_dur = rep-&gt;dasher_ctx-&gt;dash_dur;</span>
<span class="lineNum">    4845 </span><span class="lineCov">         15 :                         if (!ds-&gt;dash_dur.den) {</span>
<span class="lineNum">    4846 </span><span class="lineNoCov">          0 :                                 ds-&gt;dash_dur.num = 0;</span>
<span class="lineNum">    4847 </span><span class="lineNoCov">          0 :                                 ds-&gt;dash_dur.den = 1;</span>
<span class="lineNum">    4848 </span>            :                         }
<span class="lineNum">    4849 </span><span class="lineCov">         15 :                         ds-&gt;next_seg_start = rep-&gt;dasher_ctx-&gt;next_seg_start;</span>
<span class="lineNum">    4850 </span><span class="lineCov">         15 :                         ds-&gt;adjusted_next_seg_start = ds-&gt;next_seg_start;</span>
<span class="lineNum">    4851 </span><span class="lineCov">         15 :                         ds-&gt;first_cts = rep-&gt;dasher_ctx-&gt;first_cts;</span>
<span class="lineNum">    4852 </span><span class="lineCov">         15 :                         ds-&gt;first_dts = rep-&gt;dasher_ctx-&gt;first_dts;</span>
<span class="lineNum">    4853 </span><span class="lineCov">         15 :                         ds-&gt;ts_offset = rep-&gt;dasher_ctx-&gt;ts_offset;</span>
<span class="lineNum">    4854 </span><span class="lineCov">         15 :                         ds-&gt;est_next_dts = rep-&gt;dasher_ctx-&gt;est_next_dts;</span>
<span class="lineNum">    4855 </span><span class="lineCov">         15 :                         ds-&gt;mpd_timescale = rep-&gt;dasher_ctx-&gt;mpd_timescale;</span>
<span class="lineNum">    4856 </span><span class="lineCov">         15 :                         ds-&gt;cumulated_dur = (u64) (rep-&gt;dasher_ctx-&gt;cumulated_dur * ds-&gt;timescale);</span>
<span class="lineNum">    4857 </span><span class="lineCov">         15 :                         ds-&gt;cumulated_subdur = rep-&gt;dasher_ctx-&gt;cumulated_subdur;</span>
<span class="lineNum">    4858 </span><span class="lineCov">         15 :                         ds-&gt;rep_init = GF_TRUE;</span>
<span class="lineNum">    4859 </span><span class="lineCov">         15 :                         ds-&gt;subdur_done = rep-&gt;dasher_ctx-&gt;subdur_forced ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    4860 </span><span class="lineCov">         15 :                         ds-&gt;subdur_forced_use_period_dur = 0;</span>
<span class="lineNum">    4861 </span><span class="lineCov">         15 :                         ds-&gt;nb_pck = 0;</span>
<span class="lineNum">    4862 </span><span class="lineCov">         15 :                         if (!ctx-&gt;subdur) {</span>
<span class="lineNum">    4863 </span><span class="lineNoCov">          0 :                                 ds-&gt;nb_pck = ds-&gt;seek_to_pck;</span>
<span class="lineNum">    4864 </span><span class="lineNoCov">          0 :                                 ds-&gt;seek_to_pck = 0;</span>
<span class="lineNum">    4865 </span>            :                         }
<span class="lineNum">    4866 </span><span class="lineCov">         15 :                         ds-&gt;nb_segments_purged = rep-&gt;dasher_ctx-&gt;segs_purged;</span>
<span class="lineNum">    4867 </span><span class="lineCov">         15 :                         ds-&gt;dur_purged = rep-&gt;dasher_ctx-&gt;dur_purged;</span>
<span class="lineNum">    4868 </span><span class="lineCov">         15 :                         ds-&gt;moof_sn = rep-&gt;dasher_ctx-&gt;moof_sn;</span>
<span class="lineNum">    4869 </span><span class="lineCov">         15 :                         ds-&gt;moof_sn_inc = rep-&gt;dasher_ctx-&gt;moof_sn_inc;</span>
<span class="lineNum">    4870 </span><span class="lineCov">         15 :                         ctx-&gt;last_dyn_period_id = rep-&gt;dasher_ctx-&gt;last_dyn_period_id;</span>
<span class="lineNum">    4871 </span>            : 
<span class="lineNum">    4872 </span><span class="lineCov">         15 :                         if (ctx-&gt;store_seg_states &amp;&amp; !ds-&gt;pending_segment_states)</span>
<span class="lineNum">    4873 </span><span class="lineCov">          3 :                                 ds-&gt;pending_segment_states = gf_list_new();</span>
<span class="lineNum">    4874 </span>            : 
<span class="lineNum">    4875 </span><span class="lineCov">         15 :                         if (rep-&gt;segment_list &amp;&amp; !ds-&gt;pending_segment_urls)</span>
<span class="lineNum">    4876 </span><span class="lineNoCov">          0 :                                 ds-&gt;pending_segment_urls = gf_list_new();</span>
<span class="lineNum">    4877 </span>            : 
<span class="lineNum">    4878 </span><span class="lineCov">         15 :                         ds-&gt;owns_set = rep-&gt;dasher_ctx-&gt;owns_set;</span>
<span class="lineNum">    4879 </span><span class="lineCov">         15 :                         if (ds-&gt;owns_set) set_ds = ds;</span>
<span class="lineNum">    4880 </span>            : 
<span class="lineNum">    4881 </span><span class="lineCov">         15 :                         if (rep-&gt;dasher_ctx-&gt;done) {</span>
<span class="lineNum">    4882 </span><span class="lineNoCov">          0 :                                 ds-&gt;done = 1;</span>
<span class="lineNum">    4883 </span><span class="lineNoCov">          0 :                                 if (ds-&gt;rep) gf_mpd_representation_free(ds-&gt;rep);</span>
<span class="lineNum">    4884 </span><span class="lineNoCov">          0 :                                 ds-&gt;rep = NULL;</span>
<span class="lineNum">    4885 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    4886 </span>            :                         }
<span class="lineNum">    4887 </span>            : 
<span class="lineNum">    4888 </span><span class="lineCov">         15 :                         ds-&gt;nb_comp = 1;</span>
<span class="lineNum">    4889 </span>            : 
<span class="lineNum">    4890 </span><span class="lineCov">         15 :                         if (ds-&gt;rep) gf_mpd_representation_free(ds-&gt;rep);</span>
<span class="lineNum">    4891 </span><span class="lineCov">         15 :                         ds-&gt;rep = rep;</span>
<span class="lineNum">    4892 </span><span class="lineCov">         15 :                         ds-&gt;set = set;</span>
<span class="lineNum">    4893 </span><span class="lineCov">         15 :                         rep-&gt;playback.udta = ds;</span>
<span class="lineNum">    4894 </span><span class="lineCov">         15 :                         if (ds-&gt;owns_set)</span>
<span class="lineNum">    4895 </span><span class="lineCov">         15 :                                 set-&gt;udta = ds;</span>
<span class="lineNum">    4896 </span><span class="lineCov">         15 :                         if (rep-&gt;dasher_ctx-&gt;multi_pids)</span>
<span class="lineNum">    4897 </span>            :                                 use_multi_pid_init = GF_TRUE;
<span class="lineNum">    4898 </span>            : 
<span class="lineNum">    4899 </span><span class="lineCov">         15 :                         ds-&gt;period = ctx-&gt;current_period;</span>
<span class="lineNum">    4900 </span><span class="lineCov">         15 :                         if ((ds-&gt;codec_id==GF_CODECID_MHAS) || (ds-&gt;codec_id==GF_CODECID_MPHA)) {</span>
<span class="lineNum">    4901 </span><span class="lineNoCov">          0 :                                 const GF_PropertyValue *prop = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);</span>
<span class="lineNum">    4902 </span><span class="lineNoCov">          0 :                                 if (prop) {</span>
<span class="lineNum">    4903 </span><span class="lineNoCov">          0 :                                         ds-&gt;set-&gt;nb_alt_mha_profiles = prop-&gt;value.uint_list.nb_items;</span>
<span class="lineNum">    4904 </span><span class="lineNoCov">          0 :                                         ds-&gt;set-&gt;alt_mha_profiles = prop-&gt;value.uint_list.vals;</span>
<span class="lineNum">    4905 </span>            :                                 }
<span class="lineNum">    4906 </span>            :                         }
<span class="lineNum">    4907 </span>            : 
<span class="lineNum">    4908 </span>            : 
<span class="lineNum">    4909 </span><span class="lineCov">         15 :                         gf_list_del_item(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">    4910 </span>            : 
<span class="lineNum">    4911 </span>            :                         //non-muxed component or main comp of muxed goes first in the list
<span class="lineNum">    4912 </span><span class="lineCov">         15 :                         if (ds-&gt;nb_comp&gt;1) {</span>
<span class="lineNum">    4913 </span><span class="lineNoCov">          0 :                                 gf_list_insert(ctx-&gt;current_period-&gt;streams, ds, 0);</span>
<span class="lineNum">    4914 </span>            :                         } else {
<span class="lineNum">    4915 </span><span class="lineCov">         15 :                                 gf_list_add(ctx-&gt;current_period-&gt;streams, ds);</span>
<span class="lineNum">    4916 </span>            :                         }
<span class="lineNum">    4917 </span>            : 
<span class="lineNum">    4918 </span><span class="lineCov">         15 :                         if (rep-&gt;dasher_ctx-&gt;mux_pids) {</span>
<span class="lineNum">    4919 </span><span class="lineCov">          2 :                                 e = dasher_reload_muxed_comp(ctx, ds, rep-&gt;dasher_ctx-&gt;mux_pids, GF_FALSE);</span>
<span class="lineNum">    4920 </span><span class="lineCov">          2 :                                 if (e) return e;</span>
<span class="lineNum">    4921 </span>            :                         }
<span class="lineNum">    4922 </span>            :                 }
<span class="lineNum">    4923 </span>            :                 assert(set_ds);
<span class="lineNum">    4924 </span><span class="lineCov">         15 :                 set_ds-&gt;nb_rep = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    4925 </span>            : 
<span class="lineNum">    4926 </span>            :                 //if multi PID init, gather pids
<span class="lineNum">    4927 </span><span class="lineCov">         15 :                 if (use_multi_pid_init) {</span>
<span class="lineNum">    4928 </span><span class="lineNoCov">          0 :                         multi_pids = gf_list_new();</span>
<span class="lineNum">    4929 </span><span class="lineNoCov">          0 :                         for (i=0; i&lt;nb_rep; i++) {</span>
<span class="lineNum">    4930 </span><span class="lineNoCov">          0 :                                 GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    4931 </span><span class="lineNoCov">          0 :                                 GF_DashStream *ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    4932 </span><span class="lineNoCov">          0 :                                 if (ds-&gt;owns_set) ds-&gt;multi_pids = multi_pids;</span>
<span class="lineNum">    4933 </span><span class="lineNoCov">          0 :                                 gf_list_add(multi_pids, ds-&gt;ipid);</span>
<span class="lineNum">    4934 </span>            :                         }
<span class="lineNum">    4935 </span>            :                 }
<span class="lineNum">    4936 </span><span class="lineCov">         15 :                 count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    4937 </span><span class="lineCov">         30 :                 for (i=0; i&lt;nb_rep; i++) {</span>
<span class="lineNum">    4938 </span><span class="lineCov">         15 :                         GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    4939 </span><span class="lineCov">         15 :                         GF_DashStream *ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    4940 </span><span class="lineCov">         15 :                         if (!ds || ds-&gt;done) continue;</span>
<span class="lineNum">    4941 </span>            :                         //happens when reloading context without closing the filter
<span class="lineNum">    4942 </span><span class="lineCov">         15 :                         if (ds-&gt;dst_filter || ds-&gt;opid) continue;</span>
<span class="lineNum">    4943 </span>            : 
<span class="lineNum">    4944 </span>            :                         //open destination, trashing init
<span class="lineNum">    4945 </span>            :                         assert(!ds-&gt;muxed_base);
<span class="lineNum">    4946 </span><span class="lineCov">          3 :                         dasher_open_destination(filter, ctx, rep, ds-&gt;init_seg, GF_TRUE);</span>
<span class="lineNum">    4947 </span>            : 
<span class="lineNum">    4948 </span><span class="lineCov">          3 :                         dasher_open_pid(filter, ctx, ds, multi_pids, GF_TRUE);</span>
<span class="lineNum">    4949 </span>            : 
<span class="lineNum">    4950 </span><span class="lineCov">          8 :                         for (j=0; j&lt;count; j++) {</span>
<span class="lineNum">    4951 </span><span class="lineCov">          5 :                                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    4952 </span><span class="lineCov">          5 :                                 if (a_ds-&gt;muxed_base != ds) continue;</span>
<span class="lineNum">    4953 </span>            : 
<span class="lineNum">    4954 </span><span class="lineCov">          2 :                                 dasher_open_pid(filter, ctx, a_ds, multi_pids, GF_TRUE);</span>
<span class="lineNum">    4955 </span>            :                         }
<span class="lineNum">    4956 </span>            :                 }
<span class="lineNum">    4957 </span>            :         }
<span class="lineNum">    4958 </span>            : 
<span class="lineNum">    4959 </span>            :         return GF_OK;
<a name="4960"><span class="lineNum">    4960 </span>            : }</a>
<span class="lineNum">    4961 </span>            : 
<span class="lineNum">    4962 </span><span class="lineCov">        261 : static void dasher_udpate_periods_and_manifest(GF_Filter *filter, GF_DasherCtx *ctx)</span>
<span class="lineNum">    4963 </span>            : {
<span class="lineNum">    4964 </span><span class="lineCov">        261 :         if (!ctx-&gt;subdur_done) {</span>
<span class="lineNum">    4965 </span><span class="lineCov">        241 :                 ctx-&gt;last_dyn_period_id++;</span>
<span class="lineNum">    4966 </span><span class="lineCov">        241 :                 ctx-&gt;next_pid_id_in_period = 0;</span>
<span class="lineNum">    4967 </span>            :         }
<span class="lineNum">    4968 </span>            :         //update duration
<span class="lineNum">    4969 </span><span class="lineCov">        261 :         dasher_update_period_duration(ctx, GF_TRUE);</span>
<span class="lineNum">    4970 </span>            : 
<span class="lineNum">    4971 </span><span class="lineCov">        261 :         if (ctx-&gt;state)</span>
<span class="lineNum">    4972 </span><span class="lineCov">         32 :                 dasher_context_update_period_end(ctx);</span>
<span class="lineNum">    4973 </span>            : 
<span class="lineNum">    4974 </span>            :         //we have a MPD ready, flush it
<span class="lineNum">    4975 </span><span class="lineCov">        261 :         if (ctx-&gt;mpd)</span>
<span class="lineNum">    4976 </span><span class="lineCov">        261 :                 dasher_send_manifest(filter, ctx, GF_FALSE);</span>
<span class="lineNum">    4977 </span><span class="lineCov">        261 : }</span>
<span class="lineNum">    4978 </span>            : 
<span class="lineNum">    4979 </span>            : typedef struct
<span class="lineNum">    4980 </span>            : {
<span class="lineNum">    4981 </span>            :         GF_Fraction64 period_start;
<span class="lineNum">    4982 </span>            :         const char *period_id;
<a name="4983"><span class="lineNum">    4983 </span>            : } PeriodInfo;</a>
<span class="lineNum">    4984 </span>            : 
<span class="lineNum">    4985 </span><span class="lineNoCov">          0 : static u32 dasher_period_count(GF_List *streams_in /*GF_DashStream*/)</span>
<span class="lineNum">    4986 </span>            : {
<span class="lineNum">    4987 </span>            :         u32 nb_periods, i, j;
<span class="lineNum">    4988 </span>            :         PeriodInfo *info;
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :         GF_List *pinfos = gf_list_new();</span>
<span class="lineNum">    4990 </span>            : 
<span class="lineNum">    4991 </span><span class="lineNoCov">          0 :         for (i=0; i &lt; gf_list_count(streams_in); i++) {</span>
<span class="lineNum">    4992 </span>            :                 Bool same_period = GF_FALSE;
<span class="lineNum">    4993 </span><span class="lineNoCov">          0 :                 GF_DashStream *ds = gf_list_get(streams_in, i);</span>
<span class="lineNum">    4994 </span>            :                 //check if we already have a period info with same ID or same start time
<span class="lineNum">    4995 </span><span class="lineNoCov">          0 :                 nb_periods = gf_list_count(pinfos);</span>
<span class="lineNum">    4996 </span><span class="lineNoCov">          0 :                 for (j=0; j &lt; nb_periods; j++) {</span>
<span class="lineNum">    4997 </span><span class="lineNoCov">          0 :                         info = gf_list_get(pinfos, j);</span>
<span class="lineNum">    4998 </span><span class="lineNoCov">          0 :                         if (info-&gt;period_start.num * ds-&gt;period_start.den == ds-&gt;period_start.num * info-&gt;period_start.den) {</span>
<span class="lineNum">    4999 </span>            :                                 same_period = GF_TRUE;
<span class="lineNum">    5000 </span>            :                                 break;
<span class="lineNum">    5001 </span>            :                         }
<span class="lineNum">    5002 </span><span class="lineNoCov">          0 :                         if (info-&gt;period_id &amp;&amp; ds-&gt;period_id &amp;&amp; !strcmp(info-&gt;period_id, ds-&gt;period_id)) {</span>
<span class="lineNum">    5003 </span>            :                                 same_period = GF_TRUE;
<span class="lineNum">    5004 </span>            :                                 break;
<span class="lineNum">    5005 </span>            :                         }
<span class="lineNum">    5006 </span>            :                 }
<span class="lineNum">    5007 </span>            :                 //nope, register it
<span class="lineNum">    5008 </span><span class="lineNoCov">          0 :                 if (!same_period) {</span>
<span class="lineNum">    5009 </span><span class="lineNoCov">          0 :                         GF_SAFEALLOC(info, PeriodInfo);</span>
<span class="lineNum">    5010 </span><span class="lineNoCov">          0 :                         if (info) {</span>
<span class="lineNum">    5011 </span><span class="lineNoCov">          0 :                                 info-&gt;period_start = ds-&gt;period_start;</span>
<span class="lineNum">    5012 </span><span class="lineNoCov">          0 :                                 info-&gt;period_id = ds-&gt;period_id;</span>
<span class="lineNum">    5013 </span><span class="lineNoCov">          0 :                                 gf_list_add(pinfos, info);</span>
<span class="lineNum">    5014 </span>            :                         }
<span class="lineNum">    5015 </span>            :                 }
<span class="lineNum">    5016 </span>            :         }
<span class="lineNum">    5017 </span><span class="lineNoCov">          0 :         nb_periods = gf_list_count(pinfos);</span>
<span class="lineNum">    5018 </span>            :         while (1) {
<span class="lineNum">    5019 </span><span class="lineNoCov">          0 :                 info = gf_list_pop_back(pinfos);</span>
<span class="lineNum">    5020 </span><span class="lineNoCov">          0 :                 if (!info) break;</span>
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 :                 gf_free(info);</span>
<span class="lineNum">    5022 </span>            :         }
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :         gf_list_del(pinfos);</span>
<span class="lineNum">    5024 </span>            : 
<span class="lineNum">    5025 </span><span class="lineNoCov">          0 :         return nb_periods;</span>
<a name="5026"><span class="lineNum">    5026 </span>            : }</a>
<span class="lineNum">    5027 </span>            : 
<span class="lineNum">    5028 </span><span class="lineCov">         25 : static void dasher_init_utc(GF_Filter *filter, GF_DasherCtx *ctx)</span>
<span class="lineNum">    5029 </span>            : {
<span class="lineNum">    5030 </span>            :         const char *cache_name;
<span class="lineNum">    5031 </span>            :         u32 size;
<span class="lineNum">    5032 </span>            :         u8 *data;
<span class="lineNum">    5033 </span>            :         u64 remote_utc;
<span class="lineNum">    5034 </span>            :         GF_Err e;
<span class="lineNum">    5035 </span>            :         GF_DownloadSession *sess;
<span class="lineNum">    5036 </span>            :         GF_DownloadManager *dm;
<span class="lineNum">    5037 </span>            :         char *url;
<span class="lineNum">    5038 </span>            :         DasherUTCTimingType def_type = DASHER_UTCREF_NONE;
<span class="lineNum">    5039 </span>            : 
<span class="lineNum">    5040 </span><span class="lineCov">         25 :         ctx-&gt;utc_initialized = GF_TRUE;</span>
<span class="lineNum">    5041 </span><span class="lineCov">         25 :         ctx-&gt;utc_timing_type = DASHER_UTCREF_NONE;</span>
<span class="lineNum">    5042 </span><span class="lineCov">         25 :         if (!ctx-&gt;utcs) {</span>
<span class="lineNum">    5043 </span><span class="lineCov">         25 :                 return;</span>
<span class="lineNum">    5044 </span>            :         }
<span class="lineNum">    5045 </span>            :         url = ctx-&gt;utcs;
<span class="lineNum">    5046 </span><span class="lineNoCov">          0 :         if (!strncmp(url, &quot;xsd@&quot;, 4)) {</span>
<span class="lineNum">    5047 </span>            :                 def_type = DASHER_UTCREF_XSDATE;
<span class="lineNum">    5048 </span><span class="lineNoCov">          0 :                 url += 4;</span>
<span class="lineNum">    5049 </span>            :         }
<span class="lineNum">    5050 </span>            : 
<span class="lineNum">    5051 </span><span class="lineNoCov">          0 :         dm  = gf_filter_get_download_manager(filter);</span>
<span class="lineNum">    5052 </span><span class="lineNoCov">          0 :         if (!dm) {</span>
<span class="lineNum">    5053 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Failed to get download manager, cannot sync to remote UTC clock\n&quot;));</span>
<span class="lineNum">    5054 </span>            :                 return;
<span class="lineNum">    5055 </span>            :         }
<span class="lineNum">    5056 </span><span class="lineNoCov">          0 :         if (!strcmp(ctx-&gt;utcs, &quot;inband&quot;)) {</span>
<span class="lineNum">    5057 </span><span class="lineNoCov">          0 :                 ctx-&gt;utc_timing_type = DASHER_UTCREF_INBAND;</span>
<span class="lineNum">    5058 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    5059 </span>            :         }
<span class="lineNum">    5060 </span>            : 
<span class="lineNum">    5061 </span><span class="lineNoCov">          0 :         sess = gf_dm_sess_new(dm, url, GF_NETIO_SESSION_MEMORY_CACHE|GF_NETIO_SESSION_NOT_THREADED, NULL, NULL, &amp;e);</span>
<span class="lineNum">    5062 </span><span class="lineNoCov">          0 :         if (e) {</span>
<span class="lineNum">    5063 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Failed to create session for remote UTC source %s: %s - local clock will be used instead\n&quot;, url, gf_error_to_string(e) ));</span>
<span class="lineNum">    5064 </span>            :                 return;
<span class="lineNum">    5065 </span>            :         }
<span class="lineNum">    5066 </span><span class="lineNoCov">          0 :         while (1) {</span>
<span class="lineNum">    5067 </span>            :                 GF_NetIOStatus status;
<span class="lineNum">    5068 </span><span class="lineNoCov">          0 :                 e = gf_dm_sess_process(sess);</span>
<span class="lineNum">    5069 </span><span class="lineNoCov">          0 :                 if (e) break;</span>
<span class="lineNum">    5070 </span><span class="lineNoCov">          0 :                 gf_dm_sess_get_stats(sess, NULL, NULL, NULL, NULL, NULL, &amp;status);</span>
<span class="lineNum">    5071 </span><span class="lineNoCov">          0 :                 if (status&gt;=GF_NETIO_DATA_TRANSFERED) break;</span>
<span class="lineNum">    5072 </span>            :         }
<span class="lineNum">    5073 </span><span class="lineNoCov">          0 :         if (e&lt;0) {</span>
<span class="lineNum">    5074 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Failed to fetch remote UTC source %s: %s\n&quot;, url, gf_error_to_string(e) ));</span>
<span class="lineNum">    5075 </span><span class="lineNoCov">          0 :                 gf_dm_sess_del(sess);</span>
<span class="lineNum">    5076 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    5077 </span>            :         }
<span class="lineNum">    5078 </span><span class="lineNoCov">          0 :         cache_name = gf_dm_sess_get_cache_name(sess);</span>
<span class="lineNum">    5079 </span><span class="lineNoCov">          0 :         gf_blob_get(cache_name, &amp;data, &amp;size, NULL);</span>
<span class="lineNum">    5080 </span><span class="lineNoCov">          0 :         if (data) {</span>
<span class="lineNum">    5081 </span>            :                 //xsDate or isoDate - we always signal using iso
<span class="lineNum">    5082 </span><span class="lineNoCov">          0 :                 if (strchr(data, 'T')) {</span>
<span class="lineNum">    5083 </span><span class="lineNoCov">          0 :                         remote_utc = gf_net_parse_date(data);</span>
<span class="lineNum">    5084 </span><span class="lineNoCov">          0 :                         if (remote_utc)</span>
<span class="lineNum">    5085 </span><span class="lineNoCov">          0 :                                 ctx-&gt;utc_timing_type = def_type ? def_type : DASHER_UTCREF_ISO;</span>
<span class="lineNum">    5086 </span>            :                 }
<span class="lineNum">    5087 </span>            :                 //ntp
<span class="lineNum">    5088 </span><span class="lineNoCov">          0 :                 else if (sscanf(data, LLU, &amp;remote_utc) == 1) {</span>
<span class="lineNum">    5089 </span>            :                         //ntp value not counted since 1900, assume format is seconds till 1 jan 1970
<span class="lineNum">    5090 </span><span class="lineNoCov">          0 :                         if (remote_utc&lt;=GF_NTP_SEC_1900_TO_1970) {</span>
<span class="lineNum">    5091 </span><span class="lineNoCov">          0 :                                 remote_utc = remote_utc*1000;</span>
<span class="lineNum">    5092 </span>            :                         } else {
<span class="lineNum">    5093 </span><span class="lineNoCov">          0 :                                 remote_utc = gf_net_ntp_to_utc(remote_utc);</span>
<span class="lineNum">    5094 </span>            :                         }
<span class="lineNum">    5095 </span><span class="lineNoCov">          0 :                         if (remote_utc)</span>
<span class="lineNum">    5096 </span><span class="lineNoCov">          0 :                                 ctx-&gt;utc_timing_type = DASHER_UTCREF_NTP;</span>
<span class="lineNum">    5097 </span>            :                 }
<span class="lineNum">    5098 </span>            :         }
<span class="lineNum">    5099 </span><span class="lineNoCov">          0 :         gf_blob_release(cache_name);</span>
<span class="lineNum">    5100 </span>            : 
<span class="lineNum">    5101 </span>            :         //not match, try http date
<span class="lineNum">    5102 </span><span class="lineNoCov">          0 :         if (!ctx-&gt;utc_timing_type) {</span>
<span class="lineNum">    5103 </span><span class="lineNoCov">          0 :                 const char *hdr = gf_dm_sess_get_header(sess, &quot;Date&quot;);</span>
<span class="lineNum">    5104 </span><span class="lineNoCov">          0 :                 if (hdr) {</span>
<span class="lineNum">    5105 </span>            :                         //http-head
<span class="lineNum">    5106 </span><span class="lineNoCov">          0 :                         remote_utc = gf_net_parse_date(hdr);</span>
<span class="lineNum">    5107 </span><span class="lineNoCov">          0 :                         if (remote_utc)</span>
<span class="lineNum">    5108 </span><span class="lineNoCov">          0 :                                 ctx-&gt;utc_timing_type = DASHER_UTCREF_HTTP_HEAD;</span>
<span class="lineNum">    5109 </span>            :                 }
<span class="lineNum">    5110 </span>            :         }
<span class="lineNum">    5111 </span>            : 
<span class="lineNum">    5112 </span><span class="lineNoCov">          0 :         if (!ctx-&gt;utc_timing_type) {</span>
<span class="lineNum">    5113 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Failed to parse response %s from remote UTC source %s\n&quot;, data, url ));</span>
<span class="lineNum">    5114 </span>            :         } else {
<span class="lineNum">    5115 </span><span class="lineNoCov">          0 :                 ctx-&gt;utc_diff = (s32) ( (s64) gf_net_get_utc() - (s64) remote_utc );</span>
<span class="lineNum">    5116 </span><span class="lineNoCov">          0 :                 if (ABS(ctx-&gt;utc_diff) &gt; 3600000) {</span>
<span class="lineNum">    5117 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Diff between local clock and remote %s is %d, way too large! Assuming 0 ms UTC diff\n&quot;, url, ctx-&gt;utc_diff));</span>
<span class="lineNum">    5118 </span><span class="lineNoCov">          0 :                         ctx-&gt;utc_diff = 0;</span>
<span class="lineNum">    5119 </span>            :                 } else {
<span class="lineNum">    5120 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] Synchronized clock to remote %s - UTC diff (local - remote) %d ms\n&quot;, url, ctx-&gt;utc_diff));</span>
<span class="lineNum">    5121 </span>            :                 }
<span class="lineNum">    5122 </span>            : 
<span class="lineNum">    5123 </span><span class="lineNoCov">          0 :                 if (!gf_list_count(ctx-&gt;mpd-&gt;utc_timings) ) {</span>
<span class="lineNum">    5124 </span>            :                         Bool dashif_ok = GF_FALSE;
<span class="lineNum">    5125 </span>            :                         GF_MPD_Descriptor *utc_t;
<span class="lineNum">    5126 </span><span class="lineNoCov">          0 :                         GF_SAFEALLOC(utc_t, GF_MPD_Descriptor);</span>
<span class="lineNum">    5127 </span><span class="lineNoCov">          0 :                         utc_t-&gt;value = gf_strdup(url);</span>
<span class="lineNum">    5128 </span><span class="lineNoCov">          0 :                         switch (ctx-&gt;utc_timing_type) {</span>
<span class="lineNum">    5129 </span><span class="lineNoCov">          0 :                         case DASHER_UTCREF_HTTP_HEAD:</span>
<span class="lineNum">    5130 </span><span class="lineNoCov">          0 :                                 utc_t-&gt;scheme_id_uri = gf_strdup(&quot;urn:mpeg:dash:utc:http-head:2014&quot;);</span>
<span class="lineNum">    5131 </span>            :                                 break;
<span class="lineNum">    5132 </span><span class="lineNoCov">          0 :                         case DASHER_UTCREF_XSDATE:</span>
<span class="lineNum">    5133 </span><span class="lineNoCov">          0 :                                 utc_t-&gt;scheme_id_uri = gf_strdup(&quot;urn:mpeg:dash:utc:http-xsdate:2014&quot;);</span>
<span class="lineNum">    5134 </span>            :                                 dashif_ok = GF_TRUE;
<span class="lineNum">    5135 </span>            :                                 break;
<span class="lineNum">    5136 </span><span class="lineNoCov">          0 :                         case DASHER_UTCREF_ISO:</span>
<span class="lineNum">    5137 </span><span class="lineNoCov">          0 :                                 utc_t-&gt;scheme_id_uri = gf_strdup(&quot;urn:mpeg:dash:utc:http-iso:2014&quot;);</span>
<span class="lineNum">    5138 </span>            :                                 dashif_ok = GF_TRUE;
<span class="lineNum">    5139 </span>            :                                 break;
<span class="lineNum">    5140 </span><span class="lineNoCov">          0 :                         case DASHER_UTCREF_NTP:</span>
<span class="lineNum">    5141 </span><span class="lineNoCov">          0 :                                 utc_t-&gt;scheme_id_uri = gf_strdup(&quot;urn:mpeg:dash:utc:http-ntp:2014&quot;);</span>
<span class="lineNum">    5142 </span>            :                                 dashif_ok = GF_TRUE;
<span class="lineNum">    5143 </span>            :                                 break;
<span class="lineNum">    5144 </span><span class="lineNoCov">          0 :                         case DASHER_UTCREF_INBAND:</span>
<span class="lineNum">    5145 </span><span class="lineNoCov">          0 :                                 utc_t-&gt;scheme_id_uri = gf_strdup(&quot;urn:mpeg:dash:utc:direct:2014&quot;);</span>
<span class="lineNum">    5146 </span>            :                                 break;
<span class="lineNum">    5147 </span>            :                         default:
<span class="lineNum">    5148 </span>            :                                 break;
<span class="lineNum">    5149 </span>            :                         }
<span class="lineNum">    5150 </span><span class="lineNoCov">          0 :                         if (!dashif_ok &amp;&amp; (ctx-&gt;profile==GF_DASH_PROFILE_DASHIF_LL)) {</span>
<span class="lineNum">    5151 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] UTC reference %s allowed in DASH-IF Low Latency profile\n\tswitching to regular live profile\n&quot;, utc_t-&gt;scheme_id_uri));</span>
<span class="lineNum">    5152 </span><span class="lineNoCov">          0 :                                 ctx-&gt;profile = GF_DASH_PROFILE_LIVE;</span>
<span class="lineNum">    5153 </span>            :                         }
<span class="lineNum">    5154 </span><span class="lineNoCov">          0 :                         if (!ctx-&gt;mpd-&gt;utc_timings)</span>
<span class="lineNum">    5155 </span><span class="lineNoCov">          0 :                                 ctx-&gt;mpd-&gt;utc_timings = gf_list_new();</span>
<span class="lineNum">    5156 </span><span class="lineNoCov">          0 :                         gf_list_add(ctx-&gt;mpd-&gt;utc_timings, utc_t);</span>
<span class="lineNum">    5157 </span>            :                 }
<span class="lineNum">    5158 </span>            :         }
<span class="lineNum">    5159 </span><span class="lineNoCov">          0 :         gf_dm_sess_del(sess);</span>
<span class="lineNum">    5160 </span>            : }
<a name="5161"><span class="lineNum">    5161 </span>            : </a>
<span class="lineNum">    5162 </span>            : 
<span class="lineNum">    5163 </span><span class="lineCov">        511 : static GF_Err dasher_switch_period(GF_Filter *filter, GF_DasherCtx *ctx)</span>
<span class="lineNum">    5164 </span>            : {
<span class="lineNum">    5165 </span>            :         u32 i, count, nb_done;
<span class="lineNum">    5166 </span>            :         char *period_id;
<span class="lineNum">    5167 </span>            :         const char *remote_xlink = NULL;
<span class="lineNum">    5168 </span>            :         const char *period_xlink = NULL;
<span class="lineNum">    5169 </span>            :         u64 remote_dur = 0;
<span class="lineNum">    5170 </span>            :         GF_DasherPeriod *p;
<span class="lineNum">    5171 </span>            :         GF_Fraction64 period_start, next_period_start;
<span class="lineNum">    5172 </span>            :         GF_DashStream *first_in_period=NULL;
<span class="lineNum">    5173 </span><span class="lineCov">        511 :         p = ctx-&gt;current_period;</span>
<span class="lineNum">    5174 </span>            : 
<span class="lineNum">    5175 </span><span class="lineCov">        511 :         if (!ctx-&gt;out_path) {</span>
<span class="lineNum">    5176 </span><span class="lineCov">          4 :                 dasher_check_outpath(ctx);</span>
<span class="lineNum">    5177 </span>            :         }
<span class="lineNum">    5178 </span><span class="lineCov">        511 :         if (ctx-&gt;current_period-&gt;period) {</span>
<span class="lineNum">    5179 </span><span class="lineCov">        260 :                 if (ctx-&gt;dyn_rate)</span>
<span class="lineNum">    5180 </span><span class="lineCov">         44 :                         dasher_update_dyn_bitrates(ctx);</span>
<span class="lineNum">    5181 </span>            : 
<span class="lineNum">    5182 </span><span class="lineCov">        260 :                 dasher_udpate_periods_and_manifest(filter, ctx);</span>
<span class="lineNum">    5183 </span>            :         }
<span class="lineNum">    5184 </span>            : 
<span class="lineNum">    5185 </span><span class="lineCov">        511 :         if (ctx-&gt;subdur_done || (ctx-&gt;current_period-&gt;period &amp;&amp; (ctx-&gt;dmode == GF_MPD_TYPE_DYNAMIC_LAST)) )</span>
<span class="lineNum">    5186 </span>            :                 return GF_EOS;
<span class="lineNum">    5187 </span>            : 
<span class="lineNum">    5188 </span><span class="lineCov">        484 :         if (ctx-&gt;current_period-&gt;period) {</span>
<span class="lineNum">    5189 </span><span class="lineCov">        233 :                 GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] End of Period %s\n&quot;, ctx-&gt;current_period-&gt;period-&gt;ID ? ctx-&gt;current_period-&gt;period-&gt;ID : &quot;&quot;));</span>
<span class="lineNum">    5190 </span>            :         }
<span class="lineNum">    5191 </span><span class="lineCov">        484 :         ctx-&gt;is_period_restore = GF_FALSE;</span>
<span class="lineNum">    5192 </span><span class="lineCov">        484 :         ctx-&gt;is_empty_period = GF_FALSE;</span>
<span class="lineNum">    5193 </span>            : 
<span class="lineNum">    5194 </span>            :         //safety check at period switch, probe each first packet in case we have a reconfigure pending
<span class="lineNum">    5195 </span><span class="lineCov">        484 :         count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    5196 </span><span class="lineCov">       1200 :         for (i=0; i&lt;count;i++) {</span>
<span class="lineNum">    5197 </span><span class="lineCov">        716 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    5198 </span><span class="lineCov">        716 :                 gf_filter_pid_get_packet(ds-&gt;ipid);</span>
<span class="lineNum">    5199 </span>            :         }
<span class="lineNum">    5200 </span>            : 
<span class="lineNum">    5201 </span>            :         //reset - don't destroy, it is in the MPD
<span class="lineNum">    5202 </span><span class="lineCov">        484 :         ctx-&gt;current_period-&gt;period = NULL;</span>
<span class="lineNum">    5203 </span>            :         //switch
<span class="lineNum">    5204 </span><span class="lineCov">        484 :         ctx-&gt;current_period = ctx-&gt;next_period;</span>
<span class="lineNum">    5205 </span><span class="lineCov">        484 :         ctx-&gt;next_period = p;</span>
<span class="lineNum">    5206 </span><span class="lineCov">        484 :         ctx-&gt;on_demand_done = GF_FALSE;</span>
<span class="lineNum">    5207 </span>            : 
<span class="lineNum">    5208 </span>            :         //reset input pids and detach output pids
<span class="lineNum">    5209 </span><span class="lineCov">        484 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5210 </span><span class="lineCov">        858 :         for (i=0; i&lt;count;i++) {</span>
<span class="lineNum">    5211 </span><span class="lineCov">        374 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5212 </span><span class="lineCov">        374 :                 if (ds-&gt;opid) {</span>
<span class="lineNum">    5213 </span><span class="lineCov">          9 :                         gf_filter_pid_remove(ds-&gt;opid);</span>
<span class="lineNum">    5214 </span><span class="lineCov">          9 :                         ds-&gt;opid = NULL;</span>
<span class="lineNum">    5215 </span>            :                 }
<span class="lineNum">    5216 </span><span class="lineCov">        374 :                 dasher_reset_stream(filter, ds, GF_FALSE);</span>
<span class="lineNum">    5217 </span><span class="lineCov">        374 :                 if (ds-&gt;reschedule) {</span>
<span class="lineNum">    5218 </span><span class="lineCov">          6 :                         ds-&gt;reschedule = GF_FALSE;</span>
<span class="lineNum">    5219 </span><span class="lineCov">          6 :                         ds-&gt;done = 0;</span>
<span class="lineNum">    5220 </span>            :                 }
<span class="lineNum">    5221 </span>            :         }
<span class="lineNum">    5222 </span>            : 
<span class="lineNum">    5223 </span>            :         //figure out next period
<span class="lineNum">    5224 </span><span class="lineCov">        484 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5225 </span><span class="lineCov">        484 :         ctx-&gt;period_idx = 0;</span>
<span class="lineNum">    5226 </span>            :         period_start.num = -1;
<span class="lineNum">    5227 </span>            :         period_start.den = 1;
<span class="lineNum">    5228 </span><span class="lineCov">        858 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5229 </span><span class="lineCov">        374 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5230 </span>            : 
<span class="lineNum">    5231 </span><span class="lineCov">        374 :                 if (ds-&gt;done) continue;</span>
<span class="lineNum">    5232 </span><span class="lineCov">        368 :                 if (ds-&gt;period_start.num &lt; 0) {</span>
<span class="lineNum">    5233 </span><span class="lineCov">          6 :                         s32 pstart = (s32) -ds-&gt;period_start.num;</span>
<span class="lineNum">    5234 </span><span class="lineCov">          6 :                         if (!ctx-&gt;period_idx || (pstart &lt; ctx-&gt;period_idx)) ctx-&gt;period_idx = pstart;</span>
<span class="lineNum">    5235 </span>            :                 } else {
<span class="lineNum">    5236 </span><span class="lineCov">        362 :                         if ((period_start.num&lt;0) || (ds-&gt;period_start.num * period_start.den &lt; period_start.num * ds-&gt;period_start.den)) {</span>
<span class="lineNum">    5237 </span><span class="lineCov">        247 :                                 period_start = ds-&gt;period_start;</span>
<span class="lineNum">    5238 </span>            :                                 assert(ds-&gt;period_start.den);
<span class="lineNum">    5239 </span>            :                         }
<span class="lineNum">    5240 </span>            :                 }
<span class="lineNum">    5241 </span>            :         }
<span class="lineNum">    5242 </span>            : 
<span class="lineNum">    5243 </span><span class="lineCov">        484 :         if (period_start.num &gt;= 0)</span>
<span class="lineNum">    5244 </span><span class="lineCov">        247 :                 ctx-&gt;period_idx = 0;</span>
<span class="lineNum">    5245 </span>            : 
<span class="lineNum">    5246 </span><span class="lineCov">        484 :         if (ctx-&gt;first_context_load) {</span>
<span class="lineNum">    5247 </span><span class="lineCov">         21 :                 GF_Err e = dasher_reload_context(filter, ctx);</span>
<span class="lineNum">    5248 </span><span class="lineCov">         21 :                 if (e) {</span>
<span class="lineNum">    5249 </span><span class="lineNoCov">          0 :                         ctx-&gt;setup_failure = e;</span>
<span class="lineNum">    5250 </span><span class="lineNoCov">          0 :                         return e;</span>
<span class="lineNum">    5251 </span>            :                 }
<span class="lineNum">    5252 </span><span class="lineCov">         21 :                 if (ctx-&gt;current_period-&gt;period) ctx-&gt;is_period_restore = GF_TRUE;</span>
<span class="lineNum">    5253 </span>            : 
<span class="lineNum">    5254 </span><span class="lineCov">         21 :                 if (ctx-&gt;dmode==GF_DASH_DYNAMIC_LAST) {</span>
<span class="lineNum">    5255 </span><span class="lineCov">          1 :                         dasher_udpate_periods_and_manifest(filter, ctx);</span>
<span class="lineNum">    5256 </span><span class="lineCov">          1 :                         count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    5257 </span><span class="lineCov">          3 :                         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5258 </span><span class="lineCov">          2 :                                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    5259 </span><span class="lineCov">          2 :                                 gf_filter_pid_set_discard(ds-&gt;ipid, GF_TRUE);</span>
<span class="lineNum">    5260 </span>            :                         }
<span class="lineNum">    5261 </span>            :                         return GF_EOS;
<span class="lineNum">    5262 </span>            :                 }
<span class="lineNum">    5263 </span>            :         }
<span class="lineNum">    5264 </span>            : 
<span class="lineNum">    5265 </span>            :         //filter out PIDs not for this period
<span class="lineNum">    5266 </span><span class="lineCov">        483 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5267 </span>            :         period_id = NULL;
<span class="lineNum">    5268 </span><span class="lineCov">        867 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5269 </span>            :                 Bool in_period=GF_TRUE;
<span class="lineNum">    5270 </span><span class="lineCov">        384 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5271 </span>            : 
<span class="lineNum">    5272 </span><span class="lineCov">        384 :                 if (ds-&gt;done) {</span>
<span class="lineNum">    5273 </span>            :                         in_period=GF_FALSE;
<span class="lineNum">    5274 </span><span class="lineCov">        378 :                 } else if (!period_id) {</span>
<span class="lineNum">    5275 </span><span class="lineCov">        257 :                         period_id = ds-&gt;period_id;</span>
<span class="lineNum">    5276 </span>            :                         first_in_period = ds;
<span class="lineNum">    5277 </span><span class="lineCov">        121 :                 } else if (strcmp(period_id, ds-&gt;period_id)) {</span>
<span class="lineNum">    5278 </span>            :                         in_period = GF_FALSE;
<span class="lineNum">    5279 </span>            :                 }
<span class="lineNum">    5280 </span><span class="lineCov">        384 :                 if (in_period) {</span>
<span class="lineNum">    5281 </span><span class="lineCov">        374 :                         if ((period_start.num&gt;=0) &amp;&amp; (ds-&gt;period_start.num * period_start.den != period_start.num * ds-&gt;period_start.den))</span>
<span class="lineNum">    5282 </span>            :                                 in_period = GF_FALSE;
<span class="lineNum">    5283 </span><span class="lineCov">        374 :                         else if ((ctx-&gt;period_idx&gt;0) &amp;&amp; ((s32) -ds-&gt;period_start.num != ctx-&gt;period_idx))</span>
<span class="lineNum">    5284 </span>            :                                 in_period = GF_FALSE;
<span class="lineNum">    5285 </span>            : 
<span class="lineNum">    5286 </span><span class="lineCov">        374 :                         if (!in_period &amp;&amp; (first_in_period == ds))</span>
<span class="lineNum">    5287 </span>            :                                 period_id = NULL;
<span class="lineNum">    5288 </span>            :                 }
<span class="lineNum">    5289 </span>            : 
<span class="lineNum">    5290 </span>            :                 //if not in period, move to next period
<span class="lineNum">    5291 </span><span class="lineCov">        384 :                 if (!in_period) {</span>
<span class="lineNum">    5292 </span><span class="lineCov">         11 :                         gf_list_rem(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5293 </span><span class="lineCov">         11 :                         i--;</span>
<span class="lineNum">    5294 </span><span class="lineCov">         11 :                         count--;</span>
<span class="lineNum">    5295 </span><span class="lineCov">         11 :                         ds-&gt;period = NULL;</span>
<span class="lineNum">    5296 </span><span class="lineCov">         11 :                         gf_list_add(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">    5297 </span><span class="lineCov">         11 :                         continue;</span>
<span class="lineNum">    5298 </span>            :                 }
<span class="lineNum">    5299 </span><span class="lineCov">        373 :                 if (ds-&gt;stream_type == GF_STREAM_FILE) {</span>
<span class="lineNum">    5300 </span><span class="lineCov">          1 :                         if (ds-&gt;xlink) remote_xlink = ds-&gt;xlink;</span>
<span class="lineNum">    5301 </span><span class="lineNoCov">          0 :                         else ctx-&gt;is_empty_period = GF_TRUE;</span>
<span class="lineNum">    5302 </span>            :                         remote_dur = 0;
<span class="lineNum">    5303 </span><span class="lineCov">          1 :                         if (ds-&gt;period_dur.den)</span>
<span class="lineNum">    5304 </span><span class="lineCov">          1 :                                 remote_dur = (u64) (ds-&gt;period_dur.num * 1000) / ds-&gt;period_dur.den;</span>
<span class="lineNum">    5305 </span><span class="lineCov">        372 :                 } else if (!ctx-&gt;is_period_restore) {</span>
<span class="lineNum">    5306 </span><span class="lineCov">        357 :                         if (ds-&gt;xlink)</span>
<span class="lineNum">    5307 </span>            :                                 period_xlink = ds-&gt;xlink;
<span class="lineNum">    5308 </span>            : 
<span class="lineNum">    5309 </span><span class="lineCov">        357 :                         if (ctx-&gt;post_play_events) {</span>
<span class="lineNum">    5310 </span>            :                                 GF_FilterEvent evt;
<span class="lineNum">    5311 </span>            : 
<span class="lineNum">    5312 </span><span class="lineCov">          6 :                                 GF_FEVT_INIT(evt, GF_FEVT_STOP, ds-&gt;ipid);</span>
<span class="lineNum">    5313 </span><span class="lineCov">          6 :                                 gf_filter_pid_send_event(ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">    5314 </span>            : 
<span class="lineNum">    5315 </span><span class="lineCov">          6 :                                 gf_filter_pid_set_discard(ds-&gt;ipid, GF_FALSE);</span>
<span class="lineNum">    5316 </span>            : 
<span class="lineNum">    5317 </span><span class="lineCov">          6 :                                 dasher_send_encode_hints(ctx, ds);</span>
<span class="lineNum">    5318 </span>            : 
<span class="lineNum">    5319 </span><span class="lineCov">          6 :                                 GF_FEVT_INIT(evt, GF_FEVT_PLAY, ds-&gt;ipid);</span>
<span class="lineNum">    5320 </span><span class="lineCov">          6 :                                 evt.play.speed = 1.0;</span>
<span class="lineNum">    5321 </span><span class="lineCov">          6 :                                 gf_filter_pid_send_event(ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">    5322 </span>            :                         }
<span class="lineNum">    5323 </span>            :                 }
<span class="lineNum">    5324 </span>            :         }
<span class="lineNum">    5325 </span><span class="lineCov">        483 :         ctx-&gt;post_play_events = GF_FALSE;</span>
<span class="lineNum">    5326 </span>            : 
<span class="lineNum">    5327 </span><span class="lineCov">        483 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5328 </span><span class="lineCov">        483 :         if (!count) {</span>
<span class="lineNum">    5329 </span><span class="lineCov">        227 :                 count = gf_list_count(ctx-&gt;next_period-&gt;streams);</span>
<span class="lineNum">    5330 </span>            :                 nb_done = 0;
<span class="lineNum">    5331 </span><span class="lineCov">        558 :                 for (i=0; i&lt;count; i++)       {</span>
<span class="lineNum">    5332 </span><span class="lineCov">        331 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;next_period-&gt;streams, i);</span>
<span class="lineNum">    5333 </span><span class="lineCov">        331 :                         if (ds-&gt;done) nb_done++;</span>
<span class="lineNum">    5334 </span>            :                 }
<span class="lineNum">    5335 </span><span class="lineCov">        227 :                 if (nb_done == count) {</span>
<span class="lineNum">    5336 </span><span class="lineCov">        227 :                         GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] End of MPD (no more active streams)\n&quot;));</span>
<span class="lineNum">    5337 </span><span class="lineCov">        227 :                         ctx-&gt;on_demand_done = GF_TRUE;</span>
<span class="lineNum">    5338 </span><span class="lineCov">        227 :                         return GF_EOS;</span>
<span class="lineNum">    5339 </span>            :                 }
<span class="lineNum">    5340 </span>            :         }
<span class="lineNum">    5341 </span>            : 
<span class="lineNum">    5342 </span>            :         //we need a new period unless created during reload, create it
<span class="lineNum">    5343 </span><span class="lineCov">        256 :         if (!ctx-&gt;is_period_restore) {</span>
<span class="lineNum">    5344 </span><span class="lineCov">        247 :                 ctx-&gt;current_period-&gt;period = gf_mpd_period_new();</span>
<span class="lineNum">    5345 </span><span class="lineCov">        247 :                 if (!ctx-&gt;mpd) dasher_setup_mpd(ctx);</span>
<span class="lineNum">    5346 </span><span class="lineCov">        247 :                 gf_list_add(ctx-&gt;mpd-&gt;periods, ctx-&gt;current_period-&gt;period);</span>
<span class="lineNum">    5347 </span>            :         }
<span class="lineNum">    5348 </span>            : 
<span class="lineNum">    5349 </span>            : 
<span class="lineNum">    5350 </span><span class="lineCov">        256 :         if (remote_xlink) {</span>
<span class="lineNum">    5351 </span><span class="lineCov">          1 :                 ctx-&gt;current_period-&gt;period-&gt;xlink_href = gf_strdup(remote_xlink);</span>
<span class="lineNum">    5352 </span><span class="lineCov">          1 :                 ctx-&gt;current_period-&gt;period-&gt;duration = remote_dur;</span>
<span class="lineNum">    5353 </span>            :         }
<span class="lineNum">    5354 </span><span class="lineCov">        255 :         else if (period_xlink) {</span>
<span class="lineNum">    5355 </span><span class="lineNoCov">          0 :                 ctx-&gt;current_period-&gt;period-&gt;xlink_href = gf_strdup(period_xlink);</span>
<span class="lineNum">    5356 </span>            :         }
<span class="lineNum">    5357 </span>            : 
<span class="lineNum">    5358 </span>            : 
<span class="lineNum">    5359 </span>            :         assert(period_id);
<span class="lineNum">    5360 </span>            : 
<span class="lineNum">    5361 </span>            :         next_period_start.num = -1;
<span class="lineNum">    5362 </span>            :         next_period_start.den = 1;
<span class="lineNum">    5363 </span><span class="lineCov">        256 :         if (period_start.num &gt;= 0) {</span>
<span class="lineNum">    5364 </span><span class="lineCov">        246 :                 ctx-&gt;current_period-&gt;period-&gt;start = (u64)(period_start.num*1000 / period_start.den);</span>
<span class="lineNum">    5365 </span>            :                 //check next period start
<span class="lineNum">    5366 </span><span class="lineCov">        246 :                 count = gf_list_count(ctx-&gt;next_period-&gt;streams);</span>
<span class="lineNum">    5367 </span><span class="lineCov">        256 :                 for (i=0; i&lt;count; i++)       {</span>
<span class="lineNum">    5368 </span><span class="lineCov">         10 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;next_period-&gt;streams, i);</span>
<span class="lineNum">    5369 </span><span class="lineCov">         10 :                         if (ds-&gt;done) continue;</span>
<span class="lineNum">    5370 </span><span class="lineCov">          8 :                         if (ds-&gt;period_start.num * period_start.den &lt; period_start.num * ds-&gt;period_start.den) continue;</span>
<span class="lineNum">    5371 </span><span class="lineCov">          8 :                         if ((next_period_start.num&lt;0) || (next_period_start.num * ds-&gt;period_start.den &gt; ds-&gt;period_start.num * next_period_start.den)) {</span>
<span class="lineNum">    5372 </span>            :                                 next_period_start = ds-&gt;period_start;
<span class="lineNum">    5373 </span>            :                         }
<span class="lineNum">    5374 </span>            :                 }
<span class="lineNum">    5375 </span>            :                 //check current period dur
<span class="lineNum">    5376 </span><span class="lineCov">        246 :                 count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5377 </span><span class="lineCov">        604 :                 for (i=0; i&lt;count; i++)       {</span>
<span class="lineNum">    5378 </span>            :                         GF_Fraction64 dur;
<span class="lineNum">    5379 </span><span class="lineCov">        358 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5380 </span><span class="lineCov">        358 :                         if (!ds-&gt;period_dur.den) continue;</span>
<span class="lineNum">    5381 </span>            :                         dur = period_start;
<span class="lineNum">    5382 </span>            :                         if (ds-&gt;period_dur.den) {
<span class="lineNum">    5383 </span><span class="lineCov">        358 :                                 if (dur.den != ds-&gt;period_dur.den)</span>
<span class="lineNum">    5384 </span><span class="lineNoCov">          0 :                                         dur.num += ds-&gt;period_dur.num * dur.den / ds-&gt;period_dur.den;</span>
<span class="lineNum">    5385 </span>            :                                 else
<span class="lineNum">    5386 </span><span class="lineCov">        358 :                                         dur.num += ds-&gt;period_dur.num;</span>
<span class="lineNum">    5387 </span>            :                         }
<span class="lineNum">    5388 </span>            :                         
<span class="lineNum">    5389 </span><span class="lineCov">        358 :                         if ((next_period_start.num &lt; 0) || (next_period_start.num * dur.den &gt; dur.num * next_period_start.den))</span>
<span class="lineNum">    5390 </span>            :                                 next_period_start = dur;
<span class="lineNum">    5391 </span>            :                 }
<span class="lineNum">    5392 </span><span class="lineCov">        246 :                 if (next_period_start.num &gt; 0) {</span>
<span class="lineNum">    5393 </span><span class="lineNoCov">          0 :                         u64 next = next_period_start.num;</span>
<span class="lineNum">    5394 </span><span class="lineNoCov">          0 :                         if (next_period_start.den != period_start.den) {</span>
<span class="lineNum">    5395 </span><span class="lineNoCov">          0 :                                 next *= period_start.den;</span>
<span class="lineNum">    5396 </span><span class="lineNoCov">          0 :                                 next /= next_period_start.den;</span>
<span class="lineNum">    5397 </span>            :                         }
<span class="lineNum">    5398 </span><span class="lineNoCov">          0 :                         ctx-&gt;current_period-&gt;period-&gt;duration = (u32) ( (next - period_start.num) * 1000 / period_start.den);</span>
<span class="lineNum">    5399 </span>            :                 }
<span class="lineNum">    5400 </span>            :         }
<span class="lineNum">    5401 </span>            : 
<span class="lineNum">    5402 </span>            :         //assign period ID if none specified
<span class="lineNum">    5403 </span><span class="lineCov">        256 :         if (strcmp(period_id, DEFAULT_PERIOD_ID))</span>
<span class="lineNum">    5404 </span><span class="lineCov">          5 :                 ctx-&gt;current_period-&gt;period-&gt;ID = gf_strdup(period_id);</span>
<span class="lineNum">    5405 </span>            :         //assign ID if dynamic - if dash_ctx also assign ID since we could have moved from dynamic to static
<span class="lineNum">    5406 </span><span class="lineCov">        251 :         else if (!ctx-&gt;current_period-&gt;period-&gt;ID &amp;&amp; ((ctx-&gt;dmode != GF_MPD_TYPE_STATIC) || ctx-&gt;state) ) {</span>
<span class="lineNum">    5407 </span>            :                 char szPName[50];
<span class="lineNum">    5408 </span><span class="lineCov">         30 :                 sprintf(szPName, &quot;DID%d&quot;, ctx-&gt;last_dyn_period_id + 1);</span>
<span class="lineNum">    5409 </span><span class="lineCov">         30 :                 ctx-&gt;current_period-&gt;period-&gt;ID = gf_strdup(szPName);</span>
<span class="lineNum">    5410 </span>            :         }
<span class="lineNum">    5411 </span>            : 
<span class="lineNum">    5412 </span>            :         //check all streams are ready
<span class="lineNum">    5413 </span><span class="lineCov">        256 :         ctx-&gt;period_not_ready = GF_FALSE;</span>
<span class="lineNum">    5414 </span><span class="lineCov">        256 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5415 </span><span class="lineCov">        629 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5416 </span><span class="lineCov">        373 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5417 </span>            :                 //assign force_rep_end
<span class="lineNum">    5418 </span><span class="lineCov">        373 :                 if (next_period_start.num &gt; 0) {</span>
<span class="lineNum">    5419 </span><span class="lineNoCov">          0 :                         u64 next = next_period_start.num;</span>
<span class="lineNum">    5420 </span><span class="lineNoCov">          0 :                         if (next_period_start.den != period_start.den) {</span>
<span class="lineNum">    5421 </span><span class="lineNoCov">          0 :                                 next *= period_start.den;</span>
<span class="lineNum">    5422 </span><span class="lineNoCov">          0 :                                 next /= next_period_start.den;</span>
<span class="lineNum">    5423 </span>            :                         }
<span class="lineNum">    5424 </span>            : 
<span class="lineNum">    5425 </span><span class="lineNoCov">          0 :                         ds-&gt;force_rep_end = (u64) ((next - period_start.num) * ds-&gt;timescale / period_start.den);</span>
<span class="lineNum">    5426 </span>            :                 }
<span class="lineNum">    5427 </span><span class="lineCov">        373 :                 if (ds-&gt;dcd_not_ready) {</span>
<span class="lineNum">    5428 </span><span class="lineCov">          9 :                         ctx-&gt;period_not_ready = GF_TRUE;</span>
<span class="lineNum">    5429 </span>            :                 }
<span class="lineNum">    5430 </span>            :         }
<span class="lineNum">    5431 </span>            :         //not all streams are ready, cannot setup period yet
<span class="lineNum">    5432 </span><span class="lineCov">        256 :         if (ctx-&gt;period_not_ready)</span>
<span class="lineNum">    5433 </span>            :                 return GF_OK;
<span class="lineNum">    5434 </span>            : 
<span class="lineNum">    5435 </span><span class="lineCov">        251 :         return dasher_setup_period(filter, ctx, NULL);</span>
<a name="5436"><span class="lineNum">    5436 </span>            : }</a>
<span class="lineNum">    5437 </span>            : 
<span class="lineNum">    5438 </span><span class="lineCov">        256 : static GF_Err dasher_setup_period(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *inject_ds)</span>
<span class="lineNum">    5439 </span>            : {
<span class="lineNum">    5440 </span>            :         u32 i, count, j, nb_sets;
<span class="lineNum">    5441 </span>            :         Bool has_muxed_bases=GF_FALSE;
<span class="lineNum">    5442 </span>            :         const char *remote_xlink = NULL;
<span class="lineNum">    5443 </span>            :         Bool has_as_id = GF_FALSE;
<span class="lineNum">    5444 </span>            :         Bool has_deps = GF_FALSE;
<span class="lineNum">    5445 </span>            :         const GF_PropertyValue *prop;
<span class="lineNum">    5446 </span>            :         GF_Fraction64 min_dur, min_adur, max_adur;
<span class="lineNum">    5447 </span>            :         u32 srd_rep_idx;
<span class="lineNum">    5448 </span>            : 
<span class="lineNum">    5449 </span><span class="lineCov">        256 :         ctx-&gt;dyn_rate = GF_FALSE;</span>
<span class="lineNum">    5450 </span><span class="lineCov">        256 :         ctx-&gt;use_cues = GF_FALSE;</span>
<span class="lineNum">    5451 </span>            :         min_dur.num = min_adur.num = max_adur.num = 0;
<span class="lineNum">    5452 </span>            :         min_dur.den = min_adur.den = max_adur.den = 1;
<span class="lineNum">    5453 </span><span class="lineCov">        256 :         srd_rep_idx = 2; //2 for compat with old arch</span>
<span class="lineNum">    5454 </span>            : 
<span class="lineNum">    5455 </span><span class="lineCov">        256 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5456 </span>            :         //setup representations
<span class="lineNum">    5457 </span><span class="lineCov">        629 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5458 </span><span class="lineCov">        373 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5459 </span><span class="lineCov">        373 :                 if (inject_ds &amp;&amp; (ds != inject_ds))</span>
<span class="lineNum">    5460 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5461 </span>            : 
<span class="lineNum">    5462 </span><span class="lineCov">        373 :                 if (ds-&gt;stream_type == GF_STREAM_FILE) {</span>
<span class="lineNum">    5463 </span><span class="lineCov">          1 :                         if (ds-&gt;xlink) remote_xlink = ds-&gt;xlink;</span>
<span class="lineNum">    5464 </span><span class="lineCov">        372 :                 } else if (!ctx-&gt;is_period_restore) {</span>
<span class="lineNum">    5465 </span>            :                         //setup representation - the representation is created independently from the period
<span class="lineNum">    5466 </span><span class="lineCov">        357 :                         dasher_setup_rep(ctx, ds, &amp;srd_rep_idx);</span>
<span class="lineNum">    5467 </span>            :                 }
<span class="lineNum">    5468 </span>            :         }
<span class="lineNum">    5469 </span>            : 
<span class="lineNum">    5470 </span>            :         //setup representation dependency / components (muxed)
<span class="lineNum">    5471 </span><span class="lineCov">        373 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5472 </span>            :                 Bool remove = GF_FALSE;
<span class="lineNum">    5473 </span>            :                 GF_DashStream *ds_video=NULL;
<span class="lineNum">    5474 </span><span class="lineCov">        373 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5475 </span><span class="lineCov">        373 :                 if (inject_ds &amp;&amp; (ds != inject_ds))</span>
<span class="lineNum">    5476 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5477 </span>            : 
<span class="lineNum">    5478 </span><span class="lineCov">        373 :                 ds-&gt;period = ctx-&gt;current_period;</span>
<span class="lineNum">    5479 </span><span class="lineCov">        373 :                 ds-&gt;last_period = ds-&gt;period-&gt;period;</span>
<span class="lineNum">    5480 </span>            : 
<span class="lineNum">    5481 </span><span class="lineCov">        373 :                 if (ds-&gt;dyn_bitrate) ctx-&gt;dyn_rate = GF_TRUE;</span>
<span class="lineNum">    5482 </span><span class="lineCov">        373 :                 if (ds-&gt;inband_cues || ds-&gt;cues)</span>
<span class="lineNum">    5483 </span><span class="lineCov">         37 :                         ctx-&gt;use_cues = GF_TRUE;</span>
<span class="lineNum">    5484 </span>            : 
<span class="lineNum">    5485 </span><span class="lineCov">        373 :                 if (ctx-&gt;loop) {</span>
<span class="lineNum">    5486 </span><span class="lineCov">         28 :                         prop = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_DURATION);</span>
<span class="lineNum">    5487 </span><span class="lineCov">         28 :                         if (prop &amp;&amp; prop-&gt;value.lfrac.den) {</span>
<span class="lineNum">    5488 </span>            :                                 GF_Fraction64 d;
<span class="lineNum">    5489 </span><span class="lineCov">         28 :                                 d.num = prop-&gt;value.lfrac.num;</span>
<span class="lineNum">    5490 </span>            :                                 d.den = prop-&gt;value.lfrac.den;
<span class="lineNum">    5491 </span><span class="lineCov">         28 :                                 if (ds-&gt;clamped_dur.num &amp;&amp; (ds-&gt;clamped_dur.num * d.den &lt; d.num * ds-&gt;clamped_dur.den)) {</span>
<span class="lineNum">    5492 </span>            :                                         d = ds-&gt;clamped_dur;
<span class="lineNum">    5493 </span>            :                                 }
<span class="lineNum">    5494 </span>            : 
<span class="lineNum">    5495 </span><span class="lineCov">         28 :                                 if (ds-&gt;stream_type == GF_STREAM_AUDIO) {</span>
<span class="lineNum">    5496 </span><span class="lineCov">         14 :                                         if (d.num * max_adur.den &gt; max_adur.num * d.den) max_adur = d;</span>
<span class="lineNum">    5497 </span><span class="lineCov">         14 :                                         if (!min_adur.num || (d.num * min_adur.den &lt; min_adur.num * d.den)) min_adur = d;</span>
<span class="lineNum">    5498 </span>            :                                 } else {
<span class="lineNum">    5499 </span><span class="lineCov">         14 :                                         if (!min_dur.num || (d.num * min_dur.den &lt; min_dur.num * d.den)) min_dur = d;</span>
<span class="lineNum">    5500 </span>            :                                 }
<span class="lineNum">    5501 </span>            :                         }
<span class="lineNum">    5502 </span>            :                 }
<span class="lineNum">    5503 </span>            : 
<span class="lineNum">    5504 </span><span class="lineCov">        373 :                 if (ds-&gt;stream_type == GF_STREAM_FILE) {</span>
<span class="lineNum">    5505 </span>            :                         remove = GF_TRUE;
<span class="lineNum">    5506 </span><span class="lineCov">        372 :                 } else if (remote_xlink) {</span>
<span class="lineNum">    5507 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] period uses xlink but other media source %s, ignoring source\n&quot;, ds-&gt;src_url));</span>
<span class="lineNum">    5508 </span>            :                         remove = GF_TRUE;
<span class="lineNum">    5509 </span><span class="lineCov">        372 :                 } else if (ctx-&gt;is_empty_period) {</span>
<span class="lineNum">    5510 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] empty period defined but other media source %s, ignoring source\n&quot;, ds-&gt;src_url));</span>
<span class="lineNum">    5511 </span>            :                         remove = GF_TRUE;
<span class="lineNum">    5512 </span>            :                 }
<span class="lineNum">    5513 </span>            : 
<span class="lineNum">    5514 </span>            :                 if (remove) {
<span class="lineNum">    5515 </span><span class="lineCov">          1 :                         ds-&gt;done = 1;</span>
<span class="lineNum">    5516 </span><span class="lineCov">          1 :                         ds-&gt;period = NULL;</span>
<span class="lineNum">    5517 </span><span class="lineCov">          1 :                         gf_list_rem(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5518 </span><span class="lineCov">          1 :                         gf_list_add(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">    5519 </span><span class="lineCov">          1 :                         i--;</span>
<span class="lineNum">    5520 </span><span class="lineCov">          1 :                         count--;</span>
<span class="lineNum">    5521 </span><span class="lineCov">          1 :                         continue;</span>
<span class="lineNum">    5522 </span>            :                 }
<span class="lineNum">    5523 </span>            : 
<span class="lineNum">    5524 </span><span class="lineCov">        387 :                 if (ctx-&gt;is_period_restore) continue;</span>
<span class="lineNum">    5525 </span>            : 
<span class="lineNum">    5526 </span>            :                 //add period descriptors
<span class="lineNum">    5527 </span><span class="lineCov">        357 :                 dasher_add_descriptors(&amp;ctx-&gt;current_period-&gt;period-&gt;x_children, ds-&gt;p_period_desc);</span>
<span class="lineNum">    5528 </span>            :                 //add representation descriptors
<span class="lineNum">    5529 </span><span class="lineCov">        357 :                 dasher_add_descriptors(&amp;ds-&gt;rep-&gt;x_children, ds-&gt;p_rep_desc);</span>
<span class="lineNum">    5530 </span>            : 
<span class="lineNum">    5531 </span><span class="lineCov">        357 :                 if (ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    5532 </span>            : 
<span class="lineNum">    5533 </span><span class="lineCov">        347 :                 if (ds-&gt;stream_type==GF_STREAM_VISUAL)</span>
<span class="lineNum">    5534 </span>            :                         ds_video = ds;
<span class="lineNum">    5535 </span>            : 
<span class="lineNum">    5536 </span><span class="lineCov">        347 :                 ds-&gt;skip_tpl_reuse = GF_FALSE;</span>
<span class="lineNum">    5537 </span>            :                 // period resume (end of content replacement/splice/...): if using templates, check if period ID is used, if not force startNumber to resume
<span class="lineNum">    5538 </span><span class="lineCov">        347 :                 prop = gf_filter_pid_get_property_str(ds-&gt;ipid, &quot;period_resume&quot;);</span>
<span class="lineNum">    5539 </span><span class="lineCov">        347 :                 if (prop &amp;&amp; prop-&gt;value.string &amp;&amp; ctx-&gt;tpl &amp;&amp; ds-&gt;mpd_timescale) {</span>
<span class="lineNum">    5540 </span><span class="lineNoCov">          0 :                         char *template = ds-&gt;template;</span>
<span class="lineNum">    5541 </span><span class="lineNoCov">          0 :                         if (!template) template = ctx-&gt;template;</span>
<span class="lineNum">    5542 </span><span class="lineNoCov">          0 :                         if (</span>
<span class="lineNum">    5543 </span>            :                                 //undefined period name
<span class="lineNum">    5544 </span><span class="lineNoCov">          0 :                                 !prop-&gt;value.string[0]</span>
<span class="lineNum">    5545 </span>            :                                 //template dor not resolve against period name
<span class="lineNum">    5546 </span><span class="lineNoCov">          0 :                                 || (template &amp;&amp; !strstr(template, &quot;$Period$&quot;))</span>
<span class="lineNum">    5547 </span>            :                         ) {
<span class="lineNum">    5548 </span><span class="lineNoCov">          0 :                                 u64 seg_duration = (u64)(ds-&gt;dash_dur.num) * ds-&gt;mpd_timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    5549 </span><span class="lineNoCov">          0 :                                 u64 period_start = ds-&gt;mpd_timescale * ctx-&gt;mpd-&gt;media_presentation_duration / 1000;</span>
<span class="lineNum">    5550 </span><span class="lineNoCov">          0 :                                 u64 num = period_start / seg_duration;</span>
<span class="lineNum">    5551 </span><span class="lineNoCov">          0 :                                 if (num * seg_duration &lt; period_start)</span>
<span class="lineNum">    5552 </span><span class="lineNoCov">          0 :                                         num++;</span>
<span class="lineNum">    5553 </span><span class="lineNoCov">          0 :                                 ds-&gt;startNumber = (u32) (num+1);</span>
<span class="lineNum">    5554 </span><span class="lineNoCov">          0 :                                 ds-&gt;skip_tpl_reuse = GF_TRUE;</span>
<span class="lineNum">    5555 </span>            :                         }
<span class="lineNum">    5556 </span>            :                 }
<span class="lineNum">    5557 </span>            : 
<span class="lineNum">    5558 </span><span class="lineCov">        347 :                 ds-&gt;nb_comp = 1;</span>
<span class="lineNum">    5559 </span>            : 
<span class="lineNum">    5560 </span><span class="lineCov">       1424 :                 for (j=0; j&lt;count; j++) {</span>
<span class="lineNum">    5561 </span>            :                         GF_DashStream *a_ds;
<span class="lineNum">    5562 </span><span class="lineCov">       1077 :                         if (i==j) continue;</span>
<span class="lineNum">    5563 </span><span class="lineCov">        730 :                         a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    5564 </span><span class="lineCov">        730 :                         if (a_ds-&gt;dep_id &amp;&amp; (a_ds-&gt;src_id==ds-&gt;src_id) &amp;&amp; (a_ds-&gt;dep_id==ds-&gt;id) ) {</span>
<span class="lineNum">    5565 </span><span class="lineCov">         39 :                                 gf_list_add(ds-&gt;complementary_streams, a_ds);</span>
<span class="lineNum">    5566 </span>            :                                 has_deps = GF_TRUE;
<span class="lineNum">    5567 </span><span class="lineCov">         39 :                                 if (!a_ds-&gt;rep-&gt;dependency_id) {</span>
<span class="lineNum">    5568 </span><span class="lineCov">         39 :                                         a_ds-&gt;rep-&gt;dependency_id = gf_strdup(ds-&gt;rep-&gt;id);</span>
<span class="lineNum">    5569 </span>            :                                 }
<span class="lineNum">    5570 </span>            :                         }
<span class="lineNum">    5571 </span>            :                         //check if this rep should be muxed: same rep ID, not raw format, not CMAF
<span class="lineNum">    5572 </span><span class="lineCov">        730 :                         if (a_ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    5573 </span><span class="lineCov">        730 :                         if (ctx-&gt;muxtype==DASHER_MUX_RAW) continue;</span>
<span class="lineNum">    5574 </span><span class="lineCov">        728 :                         if (ctx-&gt;cmaf) continue;</span>
<span class="lineNum">    5575 </span><span class="lineCov">        728 :                         if (strcmp(a_ds-&gt;rep_id, ds-&gt;rep_id)) continue;</span>
<span class="lineNum">    5576 </span>            : 
<span class="lineNum">    5577 </span>            : 
<span class="lineNum">    5578 </span><span class="lineCov">         10 :                         a_ds-&gt;muxed_base = ds;</span>
<span class="lineNum">    5579 </span><span class="lineCov">         10 :                         a_ds-&gt;dash_dur = ds-&gt;dash_dur;</span>
<span class="lineNum">    5580 </span>            :                         has_muxed_bases = GF_TRUE;
<span class="lineNum">    5581 </span><span class="lineCov">         10 :                         ds-&gt;nb_comp++;</span>
<span class="lineNum">    5582 </span>            : 
<span class="lineNum">    5583 </span><span class="lineCov">         10 :                         if (ctx-&gt;bs_switch==DASHER_BS_SWITCH_MULTI) {</span>
<span class="lineNum">    5584 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Bitstream Swicthing mode \&quot;multi\&quot; is not supported with multiplexed representations, disabling bitstream switching\n&quot;));</span>
<span class="lineNum">    5585 </span><span class="lineNoCov">          0 :                                 ctx-&gt;bs_switch = DASHER_BS_SWITCH_OFF;</span>
<span class="lineNum">    5586 </span>            :                         }
<span class="lineNum">    5587 </span><span class="lineCov">         10 :                         if (!ds-&gt;rep-&gt;codecs || !strstr(ds-&gt;rep-&gt;codecs, a_ds-&gt;rep-&gt;codecs)) {</span>
<span class="lineNum">    5588 </span><span class="lineCov">         10 :                                 gf_dynstrcat(&amp;ds-&gt;rep-&gt;codecs, a_ds-&gt;rep-&gt;codecs, &quot;,&quot;);</span>
<span class="lineNum">    5589 </span>            :                         }
<span class="lineNum">    5590 </span>            : 
<span class="lineNum">    5591 </span><span class="lineCov">         10 :                         if (ctx-&gt;profile == GF_DASH_PROFILE_AVC264_LIVE) {</span>
<span class="lineNum">    5592 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Muxed representations not allowed in DASH-IF AVC264 live profile\n\tswitching to regular live profile\n&quot;));</span>
<span class="lineNum">    5593 </span><span class="lineNoCov">          0 :                                 ctx-&gt;profile = GF_DASH_PROFILE_LIVE;</span>
<span class="lineNum">    5594 </span><span class="lineCov">         10 :                         } else if (ctx-&gt;profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {</span>
<span class="lineNum">    5595 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Muxed representations not allowed in HbbTV 1.5 ISOBMF live profile\n\tswitching to regular live profile\n&quot;));</span>
<span class="lineNum">    5596 </span><span class="lineNoCov">          0 :                                 ctx-&gt;profile = GF_DASH_PROFILE_LIVE;</span>
<span class="lineNum">    5597 </span><span class="lineCov">         10 :                         } else if (ctx-&gt;profile == GF_DASH_PROFILE_AVC264_ONDEMAND) {</span>
<span class="lineNum">    5598 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Muxed representations not allowed in DASH-IF AVC264 onDemand profile\n\tswitching to regular onDemand profile\n&quot;));</span>
<span class="lineNum">    5599 </span><span class="lineNoCov">          0 :                                 ctx-&gt;profile = GF_DASH_PROFILE_ONDEMAND;</span>
<span class="lineNum">    5600 </span><span class="lineCov">         10 :                         } else if (ctx-&gt;profile == GF_DASH_PROFILE_DASHIF_LL) {</span>
<span class="lineNum">    5601 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Muxed representations not allowed in DASH-IF Low Latency profile\n\tswitching to regular live profile\n&quot;));</span>
<span class="lineNum">    5602 </span><span class="lineNoCov">          0 :                                 ctx-&gt;profile = GF_DASH_PROFILE_LIVE;</span>
<span class="lineNum">    5603 </span>            :                         }
<span class="lineNum">    5604 </span>            :                 }
<span class="lineNum">    5605 </span>            :                 //use video as main stream for segmentation of muxed sources
<span class="lineNum">    5606 </span><span class="lineCov">        347 :                 if (ds_video != ds) {</span>
<span class="lineNum">    5607 </span><span class="lineCov">        137 :                         for (j=0; j&lt;count; j++) {</span>
<span class="lineNum">    5608 </span><span class="lineCov">        137 :                                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    5609 </span><span class="lineCov">        137 :                                 if ((a_ds-&gt;muxed_base==ds) || (a_ds==ds)) {</span>
<span class="lineNum">    5610 </span><span class="lineCov">         79 :                                         if (a_ds == ds_video)</span>
<span class="lineNum">    5611 </span><span class="lineNoCov">          0 :                                                 a_ds-&gt;muxed_base = NULL;</span>
<span class="lineNum">    5612 </span>            :                                         else
<span class="lineNum">    5613 </span><span class="lineCov">         79 :                                                 a_ds-&gt;muxed_base = ds_video;</span>
<span class="lineNum">    5614 </span>            :                                 }
<span class="lineNum">    5615 </span>            :                         }
<span class="lineNum">    5616 </span>            :                 }
<span class="lineNum">    5617 </span>            :         }
<span class="lineNum">    5618 </span>            : 
<span class="lineNum">    5619 </span>            : 
<span class="lineNum">    5620 </span><span class="lineCov">        256 :         if (ctx-&gt;loop &amp;&amp; max_adur.num) {</span>
<span class="lineNum">    5621 </span><span class="lineCov">         14 :                 if (max_adur.num * min_adur.den != min_adur.num * max_adur.den) {</span>
<span class="lineNum">    5622 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Audio streams in the period have different durations (min &quot;LLU&quot;/&quot;LLD&quot;, max &quot;LLU&quot;/&quot;LLD&quot;), may result in bad synchronization while looping\n&quot;, min_adur.num, min_adur.den, max_adur.num, max_adur.den));</span>
<span class="lineNum">    5623 </span>            :                 }
<span class="lineNum">    5624 </span><span class="lineCov">         25 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5625 </span><span class="lineCov">         25 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5626 </span><span class="lineCov">         25 :                         if (ds-&gt;duration.num * max_adur.den &gt; max_adur.num * ds-&gt;duration.den) {</span>
<span class="lineNum">    5627 </span><span class="lineCov">         15 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Input %s: max audio duration &quot;LLU&quot;/&quot;LLD&quot; in the period is less than duration &quot;LLU&quot;/&quot;LLD&quot;, clamping will happen\n&quot;, ds-&gt;src_url, max_adur.num, max_adur.den, ds-&gt;duration.num, ds-&gt;duration.den ));</span>
<span class="lineNum">    5628 </span>            :                         }
<span class="lineNum">    5629 </span><span class="lineCov">         25 :                         ds-&gt;clamped_dur = max_adur;</span>
<span class="lineNum">    5630 </span>            :                 }
<span class="lineNum">    5631 </span>            :         }
<span class="lineNum">    5632 </span>            : 
<span class="lineNum">    5633 </span>            : 
<span class="lineNum">    5634 </span><span class="lineCov">        256 :         if (ctx-&gt;is_period_restore) return GF_OK;</span>
<span class="lineNum">    5635 </span>            : 
<span class="lineNum">    5636 </span><span class="lineCov">        247 :         if (has_deps) {</span>
<span class="lineNum">    5637 </span><span class="lineCov">         45 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5638 </span><span class="lineCov">         45 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5639 </span>            :                         //assign rep bitrates
<span class="lineNum">    5640 </span><span class="lineCov">         45 :                         if (ds-&gt;dep_id)</span>
<span class="lineNum">    5641 </span><span class="lineCov">         39 :                                 ds-&gt;rep-&gt;bandwidth = dasher_get_dep_bitrate(ctx, ds);</span>
<span class="lineNum">    5642 </span>            : 
<span class="lineNum">    5643 </span><span class="lineCov">         45 :                         if (gf_list_count(ds-&gt;complementary_streams)) {</span>
<span class="lineNum">    5644 </span><span class="lineCov">          6 :                                 u32 nb_str = gf_list_count(ds-&gt;complementary_streams);</span>
<span class="lineNum">    5645 </span><span class="lineCov">          6 :                                 ds-&gt;moof_sn_inc = 1+nb_str;</span>
<span class="lineNum">    5646 </span><span class="lineCov">          6 :                                 ds-&gt;moof_sn = 1;</span>
<span class="lineNum">    5647 </span><span class="lineCov">         45 :                                 for (j=0; j&lt;nb_str; j++) {</span>
<span class="lineNum">    5648 </span><span class="lineCov">         39 :                                         GF_DashStream *a_ds = gf_list_get(ds-&gt;complementary_streams, j);</span>
<span class="lineNum">    5649 </span><span class="lineCov">         39 :                                         a_ds-&gt;moof_sn_inc = ds-&gt;moof_sn_inc;</span>
<span class="lineNum">    5650 </span><span class="lineCov">         39 :                                         a_ds-&gt;moof_sn = ds-&gt;moof_sn + 1 + j;</span>
<span class="lineNum">    5651 </span>            :                                 }
<span class="lineNum">    5652 </span>            :                         }
<span class="lineNum">    5653 </span>            :                 }
<span class="lineNum">    5654 </span>            :         }
<span class="lineNum">    5655 </span>            : 
<span class="lineNum">    5656 </span>            :         //moved all mux components after the base one, so that we do the segmentation on the main component
<span class="lineNum">    5657 </span><span class="lineCov">        247 :         if (has_muxed_bases) {</span>
<span class="lineNum">    5658 </span>            :                 //setup reps in adaptation sets
<span class="lineNum">    5659 </span><span class="lineCov">         19 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5660 </span><span class="lineCov">         19 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5661 </span><span class="lineCov">         19 :                         if (!ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    5662 </span><span class="lineCov">         10 :                         gf_list_rem(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5663 </span><span class="lineCov">         10 :                         gf_list_add(ctx-&gt;current_period-&gt;streams, ds);</span>
<span class="lineNum">    5664 </span>            :                 }
<span class="lineNum">    5665 </span>            :         }
<span class="lineNum">    5666 </span>            : 
<span class="lineNum">    5667 </span>            :         //setup reps in adaptation sets
<span class="lineNum">    5668 </span><span class="lineCov">        357 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5669 </span><span class="lineCov">        357 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5670 </span><span class="lineCov">        357 :                 if (ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    5671 </span>            :                 //already setup
<span class="lineNum">    5672 </span><span class="lineCov">        347 :                 if (ds-&gt;set) continue;</span>
<span class="lineNum">    5673 </span>            : 
<span class="lineNum">    5674 </span>            :                 //not setup, create new AS
<span class="lineNum">    5675 </span><span class="lineCov">        317 :                 ds-&gt;set = gf_mpd_adaptation_set_new();</span>
<span class="lineNum">    5676 </span><span class="lineCov">        317 :                 ds-&gt;owns_set = GF_TRUE;</span>
<span class="lineNum">    5677 </span>            :                 //only set hls intra for visual stream if we have know for sure
<span class="lineNum">    5678 </span><span class="lineCov">        317 :                 if ((ds-&gt;stream_type==GF_STREAM_VISUAL) &amp;&amp; (ds-&gt;sync_points_type==DASHER_SYNC_NONE)) {</span>
<span class="lineNum">    5679 </span><span class="lineCov">          1 :                         ds-&gt;set-&gt;intra_only = GF_TRUE;</span>
<span class="lineNum">    5680 </span>            :                 }
<span class="lineNum">    5681 </span><span class="lineCov">        317 :                 if (ctx-&gt;llhls) {</span>
<span class="lineNum">    5682 </span><span class="lineCov">          9 :                         ds-&gt;set-&gt;use_hls_ll = GF_TRUE;</span>
<span class="lineNum">    5683 </span><span class="lineCov">          9 :                         if (ctx-&gt;cdur.den)</span>
<span class="lineNum">    5684 </span><span class="lineCov">          9 :                                 ds-&gt;set-&gt;hls_ll_frag_dur = ((Double)ctx-&gt;cdur.num) / ctx-&gt;cdur.den;</span>
<span class="lineNum">    5685 </span>            :                 }
<span class="lineNum">    5686 </span><span class="lineCov">        317 :                 ds-&gt;set-&gt;udta = ds;</span>
<span class="lineNum">    5687 </span><span class="lineCov">        317 :                 if (ds-&gt;period_continuity_id) {</span>
<span class="lineNum">    5688 </span><span class="lineNoCov">          0 :                         GF_FilterPacket *pck = gf_filter_pid_get_packet(ds-&gt;ipid);</span>
<span class="lineNum">    5689 </span><span class="lineNoCov">          0 :                         if (pck &amp;&amp; (gf_filter_pck_get_cts(pck) != ds-&gt;period_continuity_next_cts)) {</span>
<span class="lineNum">    5690 </span><span class="lineNoCov">          0 :                                 gf_free(ds-&gt;period_continuity_id);</span>
<span class="lineNum">    5691 </span><span class="lineNoCov">          0 :                                 ds-&gt;period_continuity_id = NULL;</span>
<span class="lineNum">    5692 </span>            :                         } else {
<span class="lineNum">    5693 </span><span class="lineNoCov">          0 :                                 GF_MPD_Descriptor *desc = gf_mpd_descriptor_new(NULL, &quot;urn:mpeg:dash:period-continuity:2015&quot;, ds-&gt;period_continuity_id);</span>
<span class="lineNum">    5694 </span><span class="lineNoCov">          0 :                                 gf_list_add(ds-&gt;set-&gt;supplemental_properties, desc);</span>
<span class="lineNum">    5695 </span>            :                         }
<span class="lineNum">    5696 </span>            :                 }
<span class="lineNum">    5697 </span><span class="lineCov">        317 :                 ds-&gt;period_continuity_next_cts = 0;</span>
<span class="lineNum">    5698 </span>            : 
<span class="lineNum">    5699 </span>            : 
<span class="lineNum">    5700 </span><span class="lineCov">        317 :                 if (ctx-&gt;mha_compat &amp;&amp; ((ds-&gt;codec_id==GF_CODECID_MHAS) || (ds-&gt;codec_id==GF_CODECID_MPHA))) {</span>
<span class="lineNum">    5701 </span><span class="lineNoCov">          0 :                         const GF_PropertyValue *prop = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);</span>
<span class="lineNum">    5702 </span><span class="lineNoCov">          0 :                         if (prop) {</span>
<span class="lineNum">    5703 </span><span class="lineNoCov">          0 :                                 ds-&gt;set-&gt;nb_alt_mha_profiles = prop-&gt;value.uint_list.nb_items;</span>
<span class="lineNum">    5704 </span><span class="lineNoCov">          0 :                                 ds-&gt;set-&gt;alt_mha_profiles = prop-&gt;value.uint_list.vals;</span>
<span class="lineNum">    5705 </span><span class="lineNoCov">          0 :                                 ds-&gt;set-&gt;alt_mha_profiles_only = (ctx-&gt;mha_compat==DASHER_MPHA_COMP_ONLY) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    5706 </span>            :                         }
<span class="lineNum">    5707 </span>            :                 }
<span class="lineNum">    5708 </span>            : 
<span class="lineNum">    5709 </span><span class="lineCov">        317 :                 if (!ds-&gt;set-&gt;representations)</span>
<span class="lineNum">    5710 </span><span class="lineNoCov">          0 :                         ds-&gt;set-&gt;representations = gf_list_new();</span>
<span class="lineNum">    5711 </span><span class="lineCov">        317 :                 if (!ds-&gt;period-&gt;period-&gt;adaptation_sets)</span>
<span class="lineNum">    5712 </span><span class="lineNoCov">          0 :                         ds-&gt;period-&gt;period-&gt;adaptation_sets = gf_list_new();</span>
<span class="lineNum">    5713 </span><span class="lineCov">        317 :                 gf_list_add(ds-&gt;period-&gt;period-&gt;adaptation_sets, ds-&gt;set);</span>
<span class="lineNum">    5714 </span>            : 
<span class="lineNum">    5715 </span><span class="lineCov">        317 :                 gf_list_add(ds-&gt;set-&gt;representations, ds-&gt;rep);</span>
<span class="lineNum">    5716 </span><span class="lineCov">        317 :                 ds-&gt;nb_rep = 1;</span>
<span class="lineNum">    5717 </span>            : 
<span class="lineNum">    5718 </span>            :                 //add non-conditional adaptation set descriptors
<span class="lineNum">    5719 </span><span class="lineCov">        317 :                 dasher_add_descriptors(&amp;ds-&gt;set-&gt;x_children, ds-&gt;p_as_any_desc);</span>
<span class="lineNum">    5720 </span>            :                 //new AS, add conditional adaptation set descriptors
<span class="lineNum">    5721 </span><span class="lineCov">        317 :                 dasher_add_descriptors(&amp;ds-&gt;set-&gt;x_children, ds-&gt;p_as_desc);</span>
<span class="lineNum">    5722 </span>            : 
<span class="lineNum">    5723 </span><span class="lineCov">        317 :                 if (ds-&gt;as_id) has_as_id = GF_TRUE;</span>
<span class="lineNum">    5724 </span>            :                 //for each following, check if same AS is possible
<span class="lineNum">    5725 </span><span class="lineCov">        633 :                 for (j=i+1; j&lt;count; j++) {</span>
<span class="lineNum">    5726 </span>            :                         GF_DashStream *a_ds;
<span class="lineNum">    5727 </span><span class="lineCov">        316 :                         a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    5728 </span>            :                         //we add to the adaptation set even if shared rep, we will remove it when assigning templates and pids
<span class="lineNum">    5729 </span><span class="lineCov">        316 :                         if (dasher_same_adaptation_set(ctx, ds, a_ds)) {</span>
<span class="lineNum">    5730 </span><span class="lineCov">         40 :                                 a_ds-&gt;set = ds-&gt;set;</span>
<span class="lineNum">    5731 </span>            : 
<span class="lineNum">    5732 </span><span class="lineCov">         40 :                                 gf_list_add(ds-&gt;set-&gt;representations, a_ds-&gt;rep);</span>
<span class="lineNum">    5733 </span><span class="lineCov">         40 :                                 ds-&gt;nb_rep++;</span>
<span class="lineNum">    5734 </span>            :                                 //add non-conditional adaptation set descriptors
<span class="lineNum">    5735 </span><span class="lineCov">         40 :                                 dasher_add_descriptors(&amp;ds-&gt;set-&gt;x_children, a_ds-&gt;p_as_any_desc);</span>
<span class="lineNum">    5736 </span>            :                         }
<span class="lineNum">    5737 </span>            :                 }
<span class="lineNum">    5738 </span>            :         }
<span class="lineNum">    5739 </span><span class="lineCov">        247 :         if (has_as_id) {</span>
<span class="lineNum">    5740 </span><span class="lineNoCov">          0 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5741 </span><span class="lineNoCov">          0 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5742 </span><span class="lineNoCov">          0 :                         if (!ds-&gt;owns_set) continue;</span>
<span class="lineNum">    5743 </span><span class="lineNoCov">          0 :                         for (j=i+1; j&lt;count; j++) {</span>
<span class="lineNum">    5744 </span><span class="lineNoCov">          0 :                                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    5745 </span>            :                                 //avoid as id duplicates
<span class="lineNum">    5746 </span><span class="lineNoCov">          0 :                                 if (ds-&gt;owns_set &amp;&amp; a_ds-&gt;owns_set &amp;&amp; (a_ds-&gt;as_id == ds-&gt;as_id)) {</span>
<span class="lineNum">    5747 </span><span class="lineNoCov">          0 :                                         a_ds-&gt;as_id = 0;</span>
<span class="lineNum">    5748 </span>            :                                 }
<span class="lineNum">    5749 </span>            :                         }
<span class="lineNum">    5750 </span>            :                 }
<span class="lineNum">    5751 </span>            :         }
<span class="lineNum">    5752 </span>            : 
<span class="lineNum">    5753 </span>            :         //we need a pass on adaptation sets to figure out if they share the same source URL
<span class="lineNum">    5754 </span>            :         //in case we use file name in templates
<span class="lineNum">    5755 </span><span class="lineCov">        247 :         nb_sets = gf_list_count(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets);</span>
<span class="lineNum">    5756 </span><span class="lineCov">        558 :         for (i=0; i&lt;nb_sets; i++) {</span>
<span class="lineNum">    5757 </span>            :                 GF_DashStream *ds;
<span class="lineNum">    5758 </span>            :                 GF_MPD_Representation *rep;
<span class="lineNum">    5759 </span>            :                 GF_MPD_AdaptationSet *set;
<span class="lineNum">    5760 </span>            : 
<span class="lineNum">    5761 </span><span class="lineCov">        317 :                 if (ctx-&gt;sigfrag)</span>
<span class="lineNum">    5762 </span>            :                         break;
<span class="lineNum">    5763 </span>            : 
<span class="lineNum">    5764 </span><span class="lineCov">        311 :                 set = gf_list_get(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets, i);</span>
<span class="lineNum">    5765 </span>            :                 assert(set);
<span class="lineNum">    5766 </span><span class="lineCov">        311 :                 rep = gf_list_get(set-&gt;representations, 0);</span>
<span class="lineNum">    5767 </span>            :                 assert(rep);
<span class="lineNum">    5768 </span><span class="lineCov">        311 :                 ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    5769 </span>            : 
<span class="lineNum">    5770 </span><span class="lineCov">        311 :                 if (inject_ds &amp;&amp; (ds != inject_ds))</span>
<span class="lineNum">    5771 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5772 </span>            : 
<span class="lineNum">    5773 </span><span class="lineCov">        311 :                 if (!dasher_template_use_source_url(ds-&gt;template ? ds-&gt;template : ctx-&gt;template))</span>
<span class="lineNum">    5774 </span><span class="lineCov">         36 :                         continue;</span>
<span class="lineNum">    5775 </span>            : 
<span class="lineNum">    5776 </span><span class="lineCov">        441 :                 for (j=i+1; j&lt;nb_sets; j++) {</span>
<span class="lineNum">    5777 </span>            :                         Bool split_init = GF_FALSE;
<span class="lineNum">    5778 </span>            :                         const GF_PropertyValue *p1, *p2;
<span class="lineNum">    5779 </span>            :                         GF_DashStream *a_ds;
<span class="lineNum">    5780 </span>            : 
<span class="lineNum">    5781 </span><span class="lineCov">        166 :                         set = gf_list_get(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets, j);</span>
<span class="lineNum">    5782 </span><span class="lineCov">        166 :                         rep = gf_list_get(set-&gt;representations, 0);</span>
<span class="lineNum">    5783 </span>            :                         assert(rep);
<span class="lineNum">    5784 </span><span class="lineCov">        166 :                         a_ds = rep-&gt;playback.udta;</span>
<span class="lineNum">    5785 </span>            : 
<span class="lineNum">    5786 </span><span class="lineCov">        166 :                         if (!dasher_template_use_source_url(a_ds-&gt;template ? a_ds-&gt;template : ctx-&gt;template))</span>
<span class="lineNum">    5787 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    5788 </span>            : 
<span class="lineNum">    5789 </span><span class="lineCov">        166 :                         p1 = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_URL);</span>
<span class="lineNum">    5790 </span><span class="lineCov">        166 :                         p2 = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_URL);</span>
<span class="lineNum">    5791 </span><span class="lineCov">        166 :                         if (p1 &amp;&amp; p2) {</span>
<span class="lineNum">    5792 </span><span class="lineCov">        166 :                                 if (gf_props_equal(p1, p2)) split_init = GF_TRUE;</span>
<span class="lineNum">    5793 </span>            :                         } else {
<span class="lineNum">    5794 </span><span class="lineNoCov">          0 :                                 p1 = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">    5795 </span><span class="lineNoCov">          0 :                                 p2 = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_FILEPATH);</span>
<span class="lineNum">    5796 </span><span class="lineNoCov">          0 :                                 if (p1 &amp;&amp; p2 &amp;&amp; gf_props_equal(p1, p2)) split_init = GF_TRUE;</span>
<span class="lineNum">    5797 </span>            :                         }
<span class="lineNum">    5798 </span>            :                         
<span class="lineNum">    5799 </span>            :                         if (split_init) {
<span class="lineNum">    5800 </span><span class="lineCov">        156 :                                 ds-&gt;split_set_names = GF_TRUE;</span>
<span class="lineNum">    5801 </span><span class="lineCov">        156 :                                 a_ds-&gt;split_set_names = GF_TRUE;</span>
<span class="lineNum">    5802 </span>            :                         }
<span class="lineNum">    5803 </span>            :                 }
<span class="lineNum">    5804 </span>            :         }
<span class="lineNum">    5805 </span>            : 
<span class="lineNum">    5806 </span>            :         /*HbbTV 1.5 ISO live specific checks*/
<span class="lineNum">    5807 </span><span class="lineCov">        247 :         if (ctx-&gt;profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {</span>
<span class="lineNum">    5808 </span><span class="lineNoCov">          0 :                 u32 nb_periods = dasher_period_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    5809 </span><span class="lineNoCov">          0 :                 if (nb_sets &gt; 16) {</span>
<span class="lineNum">    5810 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Max 16 adaptation sets in HbbTV 1.5 ISO live profile\n\tswitching to DASH AVC/264 live profile\n&quot;));</span>
<span class="lineNum">    5811 </span><span class="lineNoCov">          0 :                         ctx-&gt;profile = GF_DASH_PROFILE_AVC264_LIVE;</span>
<span class="lineNum">    5812 </span>            :                 }
<span class="lineNum">    5813 </span><span class="lineNoCov">          0 :                 if (nb_periods &gt; 32) {</span>
<span class="lineNum">    5814 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Max 32 periods in HbbTV 1.5 ISO live profile\n\tswitching to regular DASH AVC/264 live profile\n&quot;));</span>
<span class="lineNum">    5815 </span><span class="lineNoCov">          0 :                         ctx-&gt;profile = GF_DASH_PROFILE_AVC264_LIVE;</span>
<span class="lineNum">    5816 </span>            :                 }
<span class="lineNum">    5817 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;segdur.num &lt; (s32) ctx-&gt;segdur.den) {</span>
<span class="lineNum">    5818 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Min segment duration 1s in HbbTV 1.5 ISO live profile\n\tcapping to 1s\n&quot;));</span>
<span class="lineNum">    5819 </span><span class="lineNoCov">          0 :                         ctx-&gt;segdur.num = 1;</span>
<span class="lineNum">    5820 </span><span class="lineNoCov">          0 :                         ctx-&gt;segdur.den = 1;</span>
<span class="lineNum">    5821 </span>            :                 }
<span class="lineNum">    5822 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;segdur.num &gt; 15 * (s32) ctx-&gt;segdur.den) {</span>
<span class="lineNum">    5823 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[DASH] Max segment duration 15s in HbbTV 1.5 ISO live profile\n\tcapping to 15s\n&quot;));</span>
<span class="lineNum">    5824 </span><span class="lineNoCov">          0 :                         ctx-&gt;segdur.num = 15;</span>
<span class="lineNum">    5825 </span><span class="lineNoCov">          0 :                         ctx-&gt;segdur.den = 1;</span>
<span class="lineNum">    5826 </span>            :                 }
<span class="lineNum">    5827 </span>            :         }
<span class="lineNum">    5828 </span>            : 
<span class="lineNum">    5829 </span>            :         //init UTC reference time for dynamic
<span class="lineNum">    5830 </span><span class="lineCov">        247 :         if (!ctx-&gt;mpd-&gt;availabilityStartTime &amp;&amp; (ctx-&gt;dmode!=GF_MPD_TYPE_STATIC) &amp;&amp; !inject_ds) {</span>
<span class="lineNum">    5831 </span><span class="lineCov">         25 :                 u64 dash_start_date = ctx-&gt;ast ? gf_net_parse_date(ctx-&gt;ast) : 0;</span>
<span class="lineNum">    5832 </span>            : 
<span class="lineNum">    5833 </span><span class="lineCov">         25 :                 if (!ctx-&gt;utc_initialized) {</span>
<span class="lineNum">    5834 </span><span class="lineCov">         25 :                         dasher_init_utc(filter, ctx);</span>
<span class="lineNum">    5835 </span>            : 
<span class="lineNum">    5836 </span>            :                         //setup service description
<span class="lineNum">    5837 </span><span class="lineCov">         25 :                         if (ctx-&gt;profile == GF_DASH_PROFILE_DASHIF_LL) {</span>
<span class="lineNum">    5838 </span><span class="lineNoCov">          0 :                                 ctx-&gt;mpd-&gt;inject_service_desc = GF_TRUE;</span>
<span class="lineNum">    5839 </span>            :                         }
<span class="lineNum">    5840 </span>            :                 }
<span class="lineNum">    5841 </span>            : 
<span class="lineNum">    5842 </span><span class="lineCov">         25 :                 ctx-&gt;mpd-&gt;gpac_init_ntp_ms = gf_net_get_ntp_ms();</span>
<span class="lineNum">    5843 </span><span class="lineCov">         50 :                 ctx-&gt;mpd-&gt;availabilityStartTime = dasher_get_utc(ctx);</span>
<span class="lineNum">    5844 </span><span class="lineCov">         25 :                 GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] MPD Availability start time initialized to &quot;LLU&quot; ms\n&quot;, ctx-&gt;mpd-&gt;availabilityStartTime));</span>
<span class="lineNum">    5845 </span>            : 
<span class="lineNum">    5846 </span><span class="lineCov">         25 :                 if (dash_start_date &amp;&amp; (dash_start_date &lt; ctx-&gt;mpd-&gt;availabilityStartTime)) {</span>
<span class="lineNum">    5847 </span>            :                         u64 start_date_sec_ntp, secs;
<span class="lineNum">    5848 </span>            :                         Double ms;
<span class="lineNum">    5849 </span>            :                         //recompute NTP init time matching the required ast
<span class="lineNum">    5850 </span><span class="lineNoCov">          0 :                         secs = dash_start_date/1000;</span>
<span class="lineNum">    5851 </span>            :                         start_date_sec_ntp = (u32) secs;
<span class="lineNum">    5852 </span><span class="lineNoCov">          0 :                         start_date_sec_ntp += GF_NTP_SEC_1900_TO_1970;</span>
<span class="lineNum">    5853 </span><span class="lineNoCov">          0 :                         ms = (Double) (dash_start_date - secs*1000);</span>
<span class="lineNum">    5854 </span><span class="lineNoCov">          0 :                         ms /= 1000.0;</span>
<span class="lineNum">    5855 </span><span class="lineNoCov">          0 :                         ctx-&gt;mpd-&gt;gpac_init_ntp_ms = (u64) (start_date_sec_ntp * 1000 + ms);</span>
<span class="lineNum">    5856 </span>            :                         //compute number of seconds to discard
<span class="lineNum">    5857 </span><span class="lineNoCov">          0 :                         ctx-&gt;nb_secs_to_discard = (Double) (ctx-&gt;mpd-&gt;availabilityStartTime - dash_start_date);</span>
<span class="lineNum">    5858 </span><span class="lineNoCov">          0 :                         ctx-&gt;nb_secs_to_discard /= 1000;</span>
<span class="lineNum">    5859 </span>            :                         //don't discard TSB, this will be done automatically
<span class="lineNum">    5860 </span>            : 
<span class="lineNum">    5861 </span><span class="lineNoCov">          0 :                         ctx-&gt;mpd-&gt;availabilityStartTime = dash_start_date;</span>
<span class="lineNum">    5862 </span>            : 
<span class="lineNum">    5863 </span><span class="lineCov">         25 :                 } else if (dash_start_date) {</span>
<span class="lineNum">    5864 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] specified AST %s seems in the future, ignoring it\n&quot;, ctx-&gt;ast));</span>
<span class="lineNum">    5865 </span>            :                 }
<span class="lineNum">    5866 </span>            :         }
<span class="lineNum">    5867 </span>            : 
<span class="lineNum">    5868 </span>            :         //setup adaptation sets bitstream switching
<span class="lineNum">    5869 </span><span class="lineCov">        357 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5870 </span><span class="lineCov">        357 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5871 </span><span class="lineCov">        357 :                 if (!ds-&gt;owns_set) continue;</span>
<span class="lineNum">    5872 </span><span class="lineCov">        317 :                 if (inject_ds &amp;&amp; (ds != inject_ds))</span>
<span class="lineNum">    5873 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5874 </span>            :                 //check bitstream switching
<span class="lineNum">    5875 </span><span class="lineCov">        317 :                 dasher_check_bitstream_swicthing(ctx, ds-&gt;set);</span>
<span class="lineNum">    5876 </span>            :                 //setup AS defaults, roles and co
<span class="lineNum">    5877 </span><span class="lineCov">        317 :                 dasher_setup_set_defaults(ctx, ds-&gt;set);</span>
<span class="lineNum">    5878 </span>            :                 //setup sources, templates &amp; co
<span class="lineNum">    5879 </span><span class="lineCov">        317 :                 dasher_setup_sources(filter, ctx, ds-&gt;set);</span>
<span class="lineNum">    5880 </span>            :         }
<span class="lineNum">    5881 </span>            : 
<span class="lineNum">    5882 </span><span class="lineCov">        250 :         while (gf_list_count(ctx-&gt;postponed_pids)) {</span>
<span class="lineNum">    5883 </span><span class="lineCov">          3 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;postponed_pids, 0);</span>
<span class="lineNum">    5884 </span><span class="lineCov">          3 :                 dasher_open_pid(filter, ctx, ds, ds-&gt;multi_pids, GF_FALSE);</span>
<span class="lineNum">    5885 </span>            :         }
<span class="lineNum">    5886 </span>            : 
<span class="lineNum">    5887 </span>            :         //good to go !
<span class="lineNum">    5888 </span><span class="lineCov">        357 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    5889 </span><span class="lineCov">        357 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    5890 </span><span class="lineCov">        357 :                 if (inject_ds &amp;&amp; (ds != inject_ds))</span>
<span class="lineNum">    5891 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5892 </span>            :                 //setup segmentation
<span class="lineNum">    5893 </span><span class="lineCov">        357 :                 ds-&gt;rep_init = GF_FALSE;</span>
<span class="lineNum">    5894 </span><span class="lineCov">        357 :                 ds-&gt;seg_done = GF_FALSE;</span>
<span class="lineNum">    5895 </span><span class="lineCov">        357 :                 ds-&gt;next_seg_start = (u32) ( ((u64) ds-&gt;dash_dur.num * ds-&gt;timescale) / ds-&gt;dash_dur.den);</span>
<span class="lineNum">    5896 </span><span class="lineCov">        357 :                 ds-&gt;adjusted_next_seg_start = ds-&gt;next_seg_start;</span>
<span class="lineNum">    5897 </span><span class="lineCov">        357 :                 ds-&gt;segment_started = GF_FALSE;</span>
<span class="lineNum">    5898 </span><span class="lineCov">        357 :                 ds-&gt;seg_number = ds-&gt;startNumber;</span>
<span class="lineNum">    5899 </span><span class="lineCov">        357 :                 ds-&gt;first_cts = ds-&gt;first_dts = ds-&gt;max_period_dur = 0;</span>
<span class="lineNum">    5900 </span>            : 
<span class="lineNum">    5901 </span>            :                 //simulate N loops of the source
<span class="lineNum">    5902 </span><span class="lineCov">        357 :                 if (ctx-&gt;nb_secs_to_discard) {</span>
<span class="lineNum">    5903 </span>            :                         u64 period_dur, seg_dur;
<span class="lineNum">    5904 </span>            :                         u32 nb_skip=0;
<span class="lineNum">    5905 </span>            : 
<span class="lineNum">    5906 </span><span class="lineNoCov">          0 :                         period_dur = (u64) (ctx-&gt;nb_secs_to_discard * ds-&gt;timescale);</span>
<span class="lineNum">    5907 </span>            :                         seg_dur = (u64) (ds-&gt;dash_dur.num) * ds-&gt;timescale / ds-&gt;dash_dur.den;
<span class="lineNum">    5908 </span>            : 
<span class="lineNum">    5909 </span><span class="lineNoCov">          0 :                         nb_skip = (u32) (period_dur / seg_dur);</span>
<span class="lineNum">    5910 </span><span class="lineNoCov">          0 :                         ds-&gt;ts_offset += nb_skip*seg_dur;</span>
<span class="lineNum">    5911 </span><span class="lineNoCov">          0 :                         ds-&gt;seg_number += nb_skip;</span>
<span class="lineNum">    5912 </span>            : 
<span class="lineNum">    5913 </span><span class="lineNoCov">          0 :                         ds-&gt;max_period_dur = ds-&gt;cumulated_dur;</span>
<span class="lineNum">    5914 </span><span class="lineNoCov">          0 :                         ds-&gt;adjusted_next_seg_start += ds-&gt;ts_offset;</span>
<span class="lineNum">    5915 </span><span class="lineNoCov">          0 :                         ds-&gt;next_seg_start += ds-&gt;ts_offset;</span>
<span class="lineNum">    5916 </span>            :                 }
<span class="lineNum">    5917 </span>            :         }
<span class="lineNum">    5918 </span>            : 
<span class="lineNum">    5919 </span><span class="lineCov">        247 :         ctx-&gt;nb_secs_to_discard = 0;</span>
<span class="lineNum">    5920 </span>            : 
<span class="lineNum">    5921 </span><span class="lineCov">        247 :         if (ctx-&gt;state)</span>
<span class="lineNum">    5922 </span><span class="lineCov">         14 :                 dasher_context_update_period_start(ctx);</span>
<span class="lineNum">    5923 </span>            : 
<span class="lineNum">    5924 </span>            :         return GF_OK;
<a name="5925"><span class="lineNum">    5925 </span>            : }</a>
<span class="lineNum">    5926 </span>            : 
<span class="lineNum">    5927 </span><span class="lineCov">       3333 : static void dasher_insert_timeline_entry(GF_DasherCtx *ctx, GF_DashStream *ds)</span>
<span class="lineNum">    5928 </span>            : {
<span class="lineNum">    5929 </span>            :         GF_MPD_SegmentTimelineEntry *s;
<span class="lineNum">    5930 </span>            :         u64 duration;
<span class="lineNum">    5931 </span>            :         Bool is_first = GF_FALSE;
<span class="lineNum">    5932 </span>            :         Bool seg_align = GF_FALSE;
<span class="lineNum">    5933 </span>            :         GF_MPD_SegmentTimeline *tl=NULL;
<span class="lineNum">    5934 </span>            : 
<span class="lineNum">    5935 </span>            :         //we only store segment timeline for the main component in the representation
<span class="lineNum">    5936 </span><span class="lineCov">       3333 :         if (ds-&gt;muxed_base) return;</span>
<span class="lineNum">    5937 </span>            : 
<span class="lineNum">    5938 </span><span class="lineCov">       3333 :         if (ds-&gt;rep &amp;&amp; ds-&gt;rep-&gt;state_seg_list) {</span>
<span class="lineNum">    5939 </span><span class="lineCov">        528 :                 GF_DASH_SegmentContext *sctx = gf_list_last(ds-&gt;rep-&gt;state_seg_list);</span>
<span class="lineNum">    5940 </span><span class="lineCov">        528 :                 if (sctx)</span>
<span class="lineNum">    5941 </span><span class="lineCov">        528 :                         sctx-&gt;dur = ds-&gt;first_cts_in_next_seg - ds-&gt;first_cts_in_seg;</span>
<span class="lineNum">    5942 </span>            :         }
<span class="lineNum">    5943 </span>            : 
<span class="lineNum">    5944 </span>            :         //we only use segment timeline with templates
<span class="lineNum">    5945 </span><span class="lineCov">       3333 :         if (!ctx-&gt;stl) return;</span>
<span class="lineNum">    5946 </span>            : 
<span class="lineNum">    5947 </span><span class="lineCov">          4 :         if (gf_list_find(ds-&gt;set-&gt;representations, ds-&gt;rep)==0) is_first = GF_TRUE;</span>
<span class="lineNum">    5948 </span>            :         assert(ds-&gt;first_cts_in_next_seg &gt; ds-&gt;first_cts_in_seg);
<span class="lineNum">    5949 </span><span class="lineCov">          4 :         duration = ds-&gt;first_cts_in_next_seg - ds-&gt;first_cts_in_seg;</span>
<span class="lineNum">    5950 </span><span class="lineCov">          4 :         if (ds-&gt;timescale != ds-&gt;mpd_timescale) {</span>
<span class="lineNum">    5951 </span><span class="lineNoCov">          0 :                 duration *= ds-&gt;mpd_timescale;</span>
<span class="lineNum">    5952 </span><span class="lineNoCov">          0 :                 duration /= ds-&gt;timescale;</span>
<span class="lineNum">    5953 </span>            :         }
<span class="lineNum">    5954 </span><span class="lineCov">          4 :         seg_align = (ds-&gt;set-&gt;segment_alignment || ds-&gt;set-&gt;subsegment_alignment) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    5955 </span>            :         //not first and segment alignment, ignore
<span class="lineNum">    5956 </span><span class="lineCov">          4 :         if (!is_first &amp;&amp; seg_align) {</span>
<span class="lineNum">    5957 </span>            :                 return;
<span class="lineNum">    5958 </span>            :         }
<span class="lineNum">    5959 </span>            : 
<span class="lineNum">    5960 </span>            :         //no segment alignment store in each rep
<span class="lineNum">    5961 </span><span class="lineCov">          4 :         if (!seg_align) {</span>
<span class="lineNum">    5962 </span>            :                 GF_MPD_SegmentTimeline **p_tl=NULL;
<span class="lineNum">    5963 </span><span class="lineNoCov">          0 :                 if (!ds-&gt;rep) {</span>
<span class="lineNum">    5964 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] failed to store timeline entru, no representation assigned !\n&quot;));</span>
<span class="lineNum">    5965 </span>            :                         return;
<span class="lineNum">    5966 </span>            :                 }
<span class="lineNum">    5967 </span>            : 
<span class="lineNum">    5968 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;tpl) {</span>
<span class="lineNum">    5969 </span><span class="lineNoCov">          0 :                         p_tl = &amp;ds-&gt;rep-&gt;segment_template-&gt;segment_timeline;</span>
<span class="lineNum">    5970 </span><span class="lineNoCov">          0 :                         ds-&gt;rep-&gt;segment_template-&gt;duration = 0;</span>
<span class="lineNum">    5971 </span>            :                 } else {
<span class="lineNum">    5972 </span><span class="lineNoCov">          0 :                         p_tl = &amp;ds-&gt;rep-&gt;segment_list-&gt;segment_timeline;</span>
<span class="lineNum">    5973 </span><span class="lineNoCov">          0 :                         ds-&gt;rep-&gt;segment_list-&gt;duration = 0;</span>
<span class="lineNum">    5974 </span>            :                 }
<span class="lineNum">    5975 </span><span class="lineNoCov">          0 :                 if (! (*p_tl)) {</span>
<span class="lineNum">    5976 </span><span class="lineNoCov">          0 :                         (*p_tl) = gf_mpd_segmentimeline_new();</span>
<span class="lineNum">    5977 </span>            :                 }
<span class="lineNum">    5978 </span><span class="lineNoCov">          0 :                 tl = (*p_tl);</span>
<span class="lineNum">    5979 </span>            :         } else {
<span class="lineNum">    5980 </span>            :                 Bool new_tl = GF_FALSE;
<span class="lineNum">    5981 </span>            :                 GF_MPD_SegmentTimeline **p_tl=NULL;
<span class="lineNum">    5982 </span>            : 
<span class="lineNum">    5983 </span>            :                 if (!ds-&gt;set) {
<span class="lineNum">    5984 </span>            :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] failed to store timeline entru, no AdpatationSet assigned !\n&quot;));
<span class="lineNum">    5985 </span>            :                         return;
<span class="lineNum">    5986 </span>            :                 }
<span class="lineNum">    5987 </span>            :                 assert(ds-&gt;set);
<span class="lineNum">    5988 </span><span class="lineCov">          4 :                 if (ctx-&gt;tpl) {</span>
<span class="lineNum">    5989 </span>            :                         //in case we had no template at set level
<span class="lineNum">    5990 </span><span class="lineCov">          4 :                         if (!ds-&gt;set-&gt;segment_template) {</span>
<span class="lineNum">    5991 </span><span class="lineCov">          1 :                                 GF_SAFEALLOC(ds-&gt;set-&gt;segment_template, GF_MPD_SegmentTemplate);</span>
<span class="lineNum">    5992 </span><span class="lineCov">          1 :                                 if (ds-&gt;set-&gt;segment_template) {</span>
<span class="lineNum">    5993 </span><span class="lineCov">          1 :                                         ds-&gt;set-&gt;segment_template-&gt;start_number = (u32) -1;</span>
<span class="lineNum">    5994 </span><span class="lineCov">          1 :                                         ds-&gt;set-&gt;segment_template-&gt;timescale = ds-&gt;timescale;</span>
<span class="lineNum">    5995 </span>            :                                 }
<span class="lineNum">    5996 </span>            :                                 new_tl = GF_TRUE;
<span class="lineNum">    5997 </span>            :                         }
<span class="lineNum">    5998 </span><span class="lineCov">          4 :                         p_tl = &amp;ds-&gt;set-&gt;segment_template-&gt;segment_timeline;</span>
<span class="lineNum">    5999 </span><span class="lineCov">          4 :                         ds-&gt;set-&gt;segment_template-&gt;duration = 0;</span>
<span class="lineNum">    6000 </span>            :                 } else {
<span class="lineNum">    6001 </span>            :                         //in case we had no template at set level
<span class="lineNum">    6002 </span><span class="lineNoCov">          0 :                         if (!ds-&gt;set-&gt;segment_list) {</span>
<span class="lineNum">    6003 </span><span class="lineNoCov">          0 :                                 GF_SAFEALLOC(ds-&gt;set-&gt;segment_list, GF_MPD_SegmentList);</span>
<span class="lineNum">    6004 </span><span class="lineNoCov">          0 :                                 if (ds-&gt;set-&gt;segment_list) {</span>
<span class="lineNum">    6005 </span><span class="lineNoCov">          0 :                                         ds-&gt;set-&gt;segment_list-&gt;start_number = (u32) -1;</span>
<span class="lineNum">    6006 </span><span class="lineNoCov">          0 :                                         ds-&gt;set-&gt;segment_list-&gt;timescale = ds-&gt;timescale;</span>
<span class="lineNum">    6007 </span>            :                                 }
<span class="lineNum">    6008 </span>            :                                 new_tl = GF_TRUE;
<span class="lineNum">    6009 </span>            :                         }
<span class="lineNum">    6010 </span><span class="lineNoCov">          0 :                         p_tl = &amp;ds-&gt;set-&gt;segment_list-&gt;segment_timeline;</span>
<span class="lineNum">    6011 </span><span class="lineNoCov">          0 :                         ds-&gt;set-&gt;segment_list-&gt;duration = 0;</span>
<span class="lineNum">    6012 </span>            :                 }
<span class="lineNum">    6013 </span>            : 
<span class="lineNum">    6014 </span><span class="lineCov">          4 :                 if (! (*p_tl) ) {</span>
<span class="lineNum">    6015 </span><span class="lineCov">          2 :                         (*p_tl)  = gf_mpd_segmentimeline_new();</span>
<span class="lineNum">    6016 </span>            :                 }
<span class="lineNum">    6017 </span><span class="lineCov">          4 :                 tl = (*p_tl);</span>
<span class="lineNum">    6018 </span><span class="lineCov">          4 :                 if (new_tl) {</span>
<span class="lineNum">    6019 </span><span class="lineCov">          1 :                         u32 i, count = gf_list_count(ds-&gt;set-&gt;representations);</span>
<span class="lineNum">    6020 </span><span class="lineCov">          1 :                         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6021 </span><span class="lineCov">          1 :                                 GF_MPD_Representation *arep = gf_list_get(ds-&gt;set-&gt;representations, i);</span>
<span class="lineNum">    6022 </span><span class="lineCov">          1 :                                 if (arep &amp;&amp; arep-&gt;segment_template) arep-&gt;segment_template-&gt;duration = 0;</span>
<span class="lineNum">    6023 </span><span class="lineCov">          1 :                                 if (arep &amp;&amp; arep-&gt;segment_list) arep-&gt;segment_list-&gt;duration = 0;</span>
<span class="lineNum">    6024 </span>            :                         }
<span class="lineNum">    6025 </span>            :                 }
<span class="lineNum">    6026 </span>            :         }
<span class="lineNum">    6027 </span>            : 
<span class="lineNum">    6028 </span>            :         //append to previous entry if possible
<span class="lineNum">    6029 </span><span class="lineCov">          4 :         s = gf_list_last(tl-&gt;entries);</span>
<span class="lineNum">    6030 </span><span class="lineCov">          4 :         if (s &amp;&amp; (s-&gt;duration == duration) &amp;&amp; (s-&gt;start_time + (s-&gt;repeat_count+1) * s-&gt;duration == ds-&gt;seg_start_time)) {</span>
<span class="lineNum">    6031 </span><span class="lineCov">          2 :                 s-&gt;repeat_count++;</span>
<span class="lineNum">    6032 </span>            :                 return;
<span class="lineNum">    6033 </span>            :         }
<span class="lineNum">    6034 </span>            :         //nope, allocate
<span class="lineNum">    6035 </span><span class="lineCov">          2 :         GF_SAFEALLOC(s, GF_MPD_SegmentTimelineEntry);</span>
<span class="lineNum">    6036 </span><span class="lineCov">          2 :         if (!s) return;</span>
<span class="lineNum">    6037 </span><span class="lineCov">          2 :         s-&gt;start_time = ds-&gt;seg_start_time;</span>
<span class="lineNum">    6038 </span><span class="lineCov">          2 :         s-&gt;duration = (u32) duration;</span>
<span class="lineNum">    6039 </span><span class="lineCov">          2 :         gf_list_add(tl-&gt;entries, s);</span>
<a name="6040"><span class="lineNum">    6040 </span>            : }</a>
<span class="lineNum">    6041 </span>            : 
<span class="lineNum">    6042 </span><span class="lineNoCov">          0 : static void dasher_copy_segment_timelines(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)</span>
<span class="lineNum">    6043 </span>            : {
<span class="lineNum">    6044 </span>            :         GF_MPD_SegmentTimeline *src_tl = NULL;
<span class="lineNum">    6045 </span>            :         u32 i, j, count, nb_s;
<span class="lineNum">    6046 </span><span class="lineNoCov">          0 :         if (!ctx-&gt;stl) return;</span>
<span class="lineNum">    6047 </span>            :         //get as level segment timeline, set it to NULL, reassign it to first rep and clone for other reps
<span class="lineNum">    6048 </span><span class="lineNoCov">          0 :         if (ctx-&gt;tpl) {</span>
<span class="lineNum">    6049 </span>            :                 assert(set-&gt;segment_template-&gt;segment_timeline);
<span class="lineNum">    6050 </span><span class="lineNoCov">          0 :                 src_tl = set-&gt;segment_template-&gt;segment_timeline;</span>
<span class="lineNum">    6051 </span><span class="lineNoCov">          0 :                 set-&gt;segment_template-&gt;segment_timeline = NULL;</span>
<span class="lineNum">    6052 </span>            :         } else {
<span class="lineNum">    6053 </span>            :                 assert(set-&gt;segment_list-&gt;segment_timeline);
<span class="lineNum">    6054 </span><span class="lineNoCov">          0 :                 src_tl = set-&gt;segment_list-&gt;segment_timeline;</span>
<span class="lineNum">    6055 </span><span class="lineNoCov">          0 :                 set-&gt;segment_list-&gt;segment_timeline = NULL;</span>
<span class="lineNum">    6056 </span>            :         }
<span class="lineNum">    6057 </span><span class="lineNoCov">          0 :         nb_s = gf_list_count(src_tl-&gt;entries);</span>
<span class="lineNum">    6058 </span>            : 
<span class="lineNum">    6059 </span><span class="lineNoCov">          0 :         count = gf_list_count(set-&gt;representations);</span>
<span class="lineNum">    6060 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6061 </span>            :                 GF_MPD_SegmentTimeline *tl = NULL;
<span class="lineNum">    6062 </span><span class="lineNoCov">          0 :                 GF_MPD_Representation *rep = gf_list_get(set-&gt;representations, i);</span>
<span class="lineNum">    6063 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;tpl) {</span>
<span class="lineNum">    6064 </span><span class="lineNoCov">          0 :                         if (!rep-&gt;segment_template) {</span>
<span class="lineNum">    6065 </span><span class="lineNoCov">          0 :                                 GF_SAFEALLOC(rep-&gt;segment_template, GF_MPD_SegmentTemplate);</span>
<span class="lineNum">    6066 </span><span class="lineNoCov">          0 :                                 if (!rep-&gt;segment_template) continue;</span>
<span class="lineNum">    6067 </span>            :                         }
<span class="lineNum">    6068 </span><span class="lineNoCov">          0 :                         if (!i) {</span>
<span class="lineNum">    6069 </span><span class="lineNoCov">          0 :                                 rep-&gt;segment_template-&gt;segment_timeline = src_tl;</span>
<span class="lineNum">    6070 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    6071 </span>            :                         }
<span class="lineNum">    6072 </span><span class="lineNoCov">          0 :                         if (!rep-&gt;segment_template-&gt;segment_timeline) {</span>
<span class="lineNum">    6073 </span><span class="lineNoCov">          0 :                                 rep-&gt;segment_template-&gt;segment_timeline = gf_mpd_segmentimeline_new();</span>
<span class="lineNum">    6074 </span>            :                         }
<span class="lineNum">    6075 </span><span class="lineNoCov">          0 :                         tl = rep-&gt;segment_template-&gt;segment_timeline;</span>
<span class="lineNum">    6076 </span>            :                 } else {
<span class="lineNum">    6077 </span><span class="lineNoCov">          0 :                         if (!rep-&gt;segment_list) {</span>
<span class="lineNum">    6078 </span><span class="lineNoCov">          0 :                                 GF_SAFEALLOC(rep-&gt;segment_list, GF_MPD_SegmentList);</span>
<span class="lineNum">    6079 </span><span class="lineNoCov">          0 :                                 if (!rep-&gt;segment_list) continue;</span>
<span class="lineNum">    6080 </span><span class="lineNoCov">          0 :                                 rep-&gt;segment_list-&gt;start_number = (u32) -1;</span>
<span class="lineNum">    6081 </span>            :                         }
<span class="lineNum">    6082 </span><span class="lineNoCov">          0 :                         if (!i) {</span>
<span class="lineNum">    6083 </span><span class="lineNoCov">          0 :                                 rep-&gt;segment_list-&gt;segment_timeline = src_tl;</span>
<span class="lineNum">    6084 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    6085 </span>            :                         }
<span class="lineNum">    6086 </span><span class="lineNoCov">          0 :                         if (!rep-&gt;segment_list-&gt;segment_timeline) {</span>
<span class="lineNum">    6087 </span><span class="lineNoCov">          0 :                                 rep-&gt;segment_list-&gt;segment_timeline = gf_mpd_segmentimeline_new();</span>
<span class="lineNum">    6088 </span>            :                         }
<span class="lineNum">    6089 </span><span class="lineNoCov">          0 :                         tl = rep-&gt;segment_list-&gt;segment_timeline;</span>
<span class="lineNum">    6090 </span>            :                 }
<span class="lineNum">    6091 </span>            :                 assert(tl);
<span class="lineNum">    6092 </span><span class="lineNoCov">          0 :                 for (j=0; j&lt;nb_s; j++) {</span>
<span class="lineNum">    6093 </span>            :                         GF_MPD_SegmentTimelineEntry *s;
<span class="lineNum">    6094 </span><span class="lineNoCov">          0 :                         GF_MPD_SegmentTimelineEntry *src_s = gf_list_get(src_tl-&gt;entries, j);</span>
<span class="lineNum">    6095 </span><span class="lineNoCov">          0 :                         GF_SAFEALLOC(s, GF_MPD_SegmentTimelineEntry);</span>
<span class="lineNum">    6096 </span><span class="lineNoCov">          0 :                         if (!s) continue;</span>
<span class="lineNum">    6097 </span>            : 
<span class="lineNum">    6098 </span><span class="lineNoCov">          0 :                         s-&gt;duration = src_s-&gt;duration;</span>
<span class="lineNum">    6099 </span><span class="lineNoCov">          0 :                         s-&gt;repeat_count = src_s-&gt;repeat_count;</span>
<span class="lineNum">    6100 </span><span class="lineNoCov">          0 :                         s-&gt;start_time = src_s-&gt;start_time;</span>
<span class="lineNum">    6101 </span><span class="lineNoCov">          0 :                         gf_list_add(tl-&gt;entries, s);</span>
<span class="lineNum">    6102 </span>            :                 }
<span class="lineNum">    6103 </span>            :         }
<a name="6104"><span class="lineNum">    6104 </span>            : }</a>
<span class="lineNum">    6105 </span>            : 
<span class="lineNum">    6106 </span><span class="lineCov">       3334 : static void dasher_flush_segment(GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_last_in_period)</span>
<span class="lineNum">    6107 </span>            : {
<span class="lineNum">    6108 </span>            :         u32 i, count;
<span class="lineNum">    6109 </span>            :         GF_DashStream *ds_done = NULL, *ds_not_done = NULL;
<span class="lineNum">    6110 </span><span class="lineCov">       3334 :         GF_DashStream *set_ds = ds-&gt;set-&gt;udta;</span>
<span class="lineNum">    6111 </span><span class="lineCov">       3334 :         GF_DashStream *base_ds = ds-&gt;muxed_base ? ds-&gt;muxed_base : ds;</span>
<span class="lineNum">    6112 </span>            :         Bool has_ds_done = GF_FALSE;
<span class="lineNum">    6113 </span>            :         u32 seg_dur_ms=0;
<span class="lineNum">    6114 </span>            :         GF_DashStream *ds_log = NULL;
<span class="lineNum">    6115 </span>            :         u64 first_cts_in_cur_seg=0;
<span class="lineNum">    6116 </span>            : 
<span class="lineNum">    6117 </span><span class="lineCov">       3334 :         ctx-&gt;update_report = -1;</span>
<span class="lineNum">    6118 </span>            : 
<span class="lineNum">    6119 </span><span class="lineCov">       3334 :         if (ds-&gt;segment_started) {</span>
<span class="lineNum">    6120 </span>            :                 Double seg_duration;
<span class="lineNum">    6121 </span><span class="lineCov">       3333 :                 u64 seg_duration_unscale = base_ds-&gt;first_cts_in_next_seg - ds-&gt;first_cts_in_seg;</span>
<span class="lineNum">    6122 </span>            :                 //seg_duration /= base_ds-&gt;timescale;
<span class="lineNum">    6123 </span><span class="lineCov">       3333 :                 if (!seg_duration_unscale) {</span>
<span class="lineNum">    6124 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Segment %d is empty - pid end of stream %d\n&quot;, ds-&gt;seg_number, gf_filter_pid_is_eos(ds-&gt;ipid) ));</span>
<span class="lineNum">    6125 </span>            :                 }
<span class="lineNum">    6126 </span><span class="lineCov">       3333 :                 seg_dur_ms = (u32) (seg_duration_unscale*1000 / base_ds-&gt;timescale);</span>
<span class="lineNum">    6127 </span><span class="lineCov">       3333 :                 if (seg_dur_ms * base_ds-&gt;timescale &lt; seg_duration_unscale* 1000) seg_dur_ms++;</span>
<span class="lineNum">    6128 </span>            : 
<span class="lineNum">    6129 </span><span class="lineCov">       3333 :                 first_cts_in_cur_seg = ds-&gt;first_cts_in_seg;</span>
<span class="lineNum">    6130 </span><span class="lineCov">       3333 :                 if (ctx-&gt;mpd-&gt;max_segment_duration &lt; seg_dur_ms)</span>
<span class="lineNum">    6131 </span><span class="lineCov">        291 :                         ctx-&gt;mpd-&gt;max_segment_duration = seg_dur_ms;</span>
<span class="lineNum">    6132 </span>            : 
<span class="lineNum">    6133 </span><span class="lineCov">       3333 :                 seg_duration = (Double) base_ds-&gt;first_cts_in_next_seg - ds-&gt;first_cts_in_seg;</span>
<span class="lineNum">    6134 </span><span class="lineCov">       3333 :                 seg_duration /= base_ds-&gt;timescale;</span>
<span class="lineNum">    6135 </span>            : 
<span class="lineNum">    6136 </span><span class="lineCov">       3333 :                 if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    6137 </span><span class="lineCov">         72 :                         if (ds-&gt;no_seg_dur) {</span>
<span class="lineNum">    6138 </span><span class="lineCov">         72 :                                 ds-&gt;gm_duration_total += seg_duration;</span>
<span class="lineNum">    6139 </span><span class="lineCov">         72 :                                 ds-&gt;gm_nb_segments++;</span>
<span class="lineNum">    6140 </span><span class="lineCov">         72 :                                 if (!ds-&gt;gm_duration_min || (ds-&gt;gm_duration_min&gt;seg_duration) )</span>
<span class="lineNum">    6141 </span><span class="lineCov">          6 :                                         ds-&gt;gm_duration_min = seg_duration;</span>
<span class="lineNum">    6142 </span><span class="lineCov">         72 :                                 if (ds-&gt;gm_duration_max&lt;seg_duration)</span>
<span class="lineNum">    6143 </span><span class="lineCov">          6 :                                         ds-&gt;gm_duration_max = seg_duration;</span>
<span class="lineNum">    6144 </span><span class="lineCov">         72 :                                 ds-&gt;dash_dur.num = (s32) (1000.0 * ds-&gt;gm_duration_total / ds-&gt;gm_nb_segments);</span>
<span class="lineNum">    6145 </span><span class="lineCov">         72 :                                 ds-&gt;dash_dur.den = 1000;</span>
<span class="lineNum">    6146 </span><span class="lineCov">         72 :                                 ds-&gt;rep-&gt;dash_dur = ds-&gt;dash_dur;</span>
<span class="lineNum">    6147 </span>            :                         }
<span class="lineNum">    6148 </span>            : 
<span class="lineNum">    6149 </span><span class="lineCov">         72 :                         if (ds-&gt;rep-&gt;segment_list &amp;&amp; (ds-&gt;rep-&gt;segment_list-&gt;duration * ds-&gt;dash_dur.den != ds-&gt;dash_dur.num) ) {</span>
<span class="lineNum">    6150 </span><span class="lineCov">         48 :                                 ds-&gt;rep-&gt;segment_list-&gt;duration = (u64) (ds-&gt;dash_dur.num) * ds-&gt;rep-&gt;segment_list-&gt;timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6151 </span>            :                         }
<span class="lineNum">    6152 </span><span class="lineCov">         72 :                         if (ds-&gt;set-&gt;segment_list &amp;&amp; (ds-&gt;set-&gt;segment_list-&gt;duration * ds-&gt;dash_dur.den != ds-&gt;dash_dur.num) ) {</span>
<span class="lineNum">    6153 </span><span class="lineNoCov">          0 :                                 ds-&gt;set-&gt;segment_list-&gt;duration = (u64) (ds-&gt;dash_dur.num) * ds-&gt;set-&gt;segment_list-&gt;timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6154 </span>            :                         }
<span class="lineNum">    6155 </span><span class="lineCov">         72 :                         if (ds-&gt;rep-&gt;segment_template &amp;&amp; (ds-&gt;rep-&gt;segment_template-&gt;duration * ds-&gt;dash_dur.den != ds-&gt;dash_dur.num) ) {</span>
<span class="lineNum">    6156 </span><span class="lineNoCov">          0 :                                 ds-&gt;rep-&gt;segment_template-&gt;duration = (u64) (ds-&gt;dash_dur.num) * ds-&gt;rep-&gt;segment_template-&gt;timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6157 </span>            :                         }
<span class="lineNum">    6158 </span><span class="lineCov">         72 :                         if (ds-&gt;set &amp;&amp; ds-&gt;set-&gt;segment_template &amp;&amp; (ds-&gt;set-&gt;segment_template-&gt;duration * ds-&gt;dash_dur.den != ds-&gt;dash_dur.num) ) {</span>
<span class="lineNum">    6159 </span><span class="lineCov">          9 :                                 ds-&gt;set-&gt;segment_template-&gt;duration = (u64) (ds-&gt;dash_dur.num) * ds-&gt;set-&gt;segment_template-&gt;timescale / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6160 </span>            :                         }
<span class="lineNum">    6161 </span>            :                 }
<span class="lineNum">    6162 </span><span class="lineCov">       3333 :                 if (!base_ds-&gt;done &amp;&amp; !ctx-&gt;stl &amp;&amp; ctx-&gt;tpl &amp;&amp; !ctx-&gt;cues &amp;&amp; !ctx-&gt;forward_mode &amp;&amp; !is_last_in_period) {</span>
<span class="lineNum">    6163 </span>            : 
<span class="lineNum">    6164 </span><span class="lineCov">       2267 :                         if (2 * seg_duration * ds-&gt;dash_dur.den &lt; ds-&gt;dash_dur.num) {</span>
<span class="lineNum">    6165 </span>            : 
<span class="lineNum">    6166 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Segment %d duration %g less than half DASH duration, consider reencoding or using segment timeline\n&quot;, ds-&gt;seg_number, seg_duration));</span>
<span class="lineNum">    6167 </span><span class="lineCov">       2267 :                         } else if (2 * seg_duration * ds-&gt;dash_dur.den &gt; 3 * ds-&gt;dash_dur.num) {</span>
<span class="lineNum">    6168 </span><span class="lineCov">         24 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Segment %d duration %g more than 3/2 DASH duration, consider reencoding or using segment timeline\n&quot;, ds-&gt;seg_number, seg_duration));</span>
<span class="lineNum">    6169 </span>            :                         }
<span class="lineNum">    6170 </span>            :                 }
<span class="lineNum">    6171 </span><span class="lineCov">       3333 :                 dasher_insert_timeline_entry(ctx, base_ds);</span>
<span class="lineNum">    6172 </span>            : 
<span class="lineNum">    6173 </span><span class="lineCov">       3333 :                 if (ctx-&gt;align) {</span>
<span class="lineNum">    6174 </span><span class="lineCov">       3333 :                         if (!set_ds-&gt;nb_rep_done || !set_ds-&gt;set_seg_duration) {</span>
<span class="lineNum">    6175 </span><span class="lineCov">       2933 :                                 set_ds-&gt;set_seg_duration = seg_duration;</span>
<span class="lineNum">    6176 </span>            :                         } else {
<span class="lineNum">    6177 </span><span class="lineCov">        400 :                                 Double diff = set_ds-&gt;set_seg_duration - seg_duration;</span>
<span class="lineNum">    6178 </span>            : 
<span class="lineNum">    6179 </span><span class="lineCov">        400 :                                 if (ABS(diff) &gt; 0.001) {</span>
<span class="lineNum">    6180 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Segments are not aligned across representations: first rep segment duration %g but new segment duration %g for the same segment %d\n&quot;, set_ds-&gt;set_seg_duration, seg_duration, set_ds-&gt;seg_number));</span>
<span class="lineNum">    6181 </span>            : 
<span class="lineNum">    6182 </span><span class="lineNoCov">          0 :                                         if (ctx-&gt;profile != GF_DASH_PROFILE_FULL) {</span>
<span class="lineNum">    6183 </span><span class="lineNoCov">          0 :                                                 set_ds-&gt;set-&gt;segment_alignment = GF_FALSE;</span>
<span class="lineNum">    6184 </span><span class="lineNoCov">          0 :                                                 set_ds-&gt;set-&gt;subsegment_alignment = GF_FALSE;</span>
<span class="lineNum">    6185 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;profile = GF_DASH_PROFILE_FULL;</span>
<span class="lineNum">    6186 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] No segment alignment, switching to full profile\n&quot;));</span>
<span class="lineNum">    6187 </span><span class="lineNoCov">          0 :                                                 dasher_copy_segment_timelines(ctx, set_ds-&gt;set);</span>
<span class="lineNum">    6188 </span>            :                                         }
<span class="lineNum">    6189 </span>            :                                 }
<span class="lineNum">    6190 </span>            :                         }
<span class="lineNum">    6191 </span><span class="lineCov">       3333 :                         set_ds-&gt;nb_rep_done++;</span>
<span class="lineNum">    6192 </span><span class="lineCov">       3333 :                         if (set_ds-&gt;nb_rep_done &lt; set_ds-&gt;nb_rep) {</span>
<span class="lineNum">    6193 </span><span class="lineCov">        401 :                                 if (ctx-&gt;subdur &amp;&amp; (ds-&gt;cumulated_dur &gt;= 0.8 * (ds-&gt;cumulated_subdur + ctx-&gt;subdur) * ds-&gt;timescale))</span>
<span class="lineNum">    6194 </span><span class="lineNoCov">          0 :                                         ds-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    6195 </span>            :                                 return;
<span class="lineNum">    6196 </span>            :                         }
<span class="lineNum">    6197 </span><span class="lineCov">       2932 :                         set_ds-&gt;set_seg_duration = 0;</span>
<span class="lineNum">    6198 </span><span class="lineCov">       2932 :                         set_ds-&gt;nb_rep_done = 0;</span>
<span class="lineNum">    6199 </span>            :                 }
<span class="lineNum">    6200 </span>            : 
<span class="lineNum">    6201 </span>            :                 ds_log = ds;
<span class="lineNum">    6202 </span>            :         } else {
<span class="lineNum">    6203 </span><span class="lineCov">          1 :                 if (ctx-&gt;align) {</span>
<span class="lineNum">    6204 </span><span class="lineCov">          1 :                         set_ds-&gt;nb_rep_done++;</span>
<span class="lineNum">    6205 </span><span class="lineCov">          1 :                         if (set_ds-&gt;nb_rep_done &lt; set_ds-&gt;nb_rep) return;</span>
<span class="lineNum">    6206 </span>            : 
<span class="lineNum">    6207 </span><span class="lineCov">          1 :                         set_ds-&gt;set_seg_duration = 0;</span>
<span class="lineNum">    6208 </span><span class="lineCov">          1 :                         set_ds-&gt;nb_rep_done = 0;</span>
<span class="lineNum">    6209 </span>            :                 }
<span class="lineNum">    6210 </span>            :         }
<span class="lineNum">    6211 </span>            : 
<span class="lineNum">    6212 </span><span class="lineCov">       2933 :         if (ctx-&gt;subdur &amp;&amp; (ds-&gt;cumulated_dur &gt;= 0.8 * (ds-&gt;cumulated_subdur + ctx-&gt;subdur) * ds-&gt;timescale))</span>
<span class="lineNum">    6213 </span><span class="lineCov">         34 :                 ds-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    6214 </span>            : 
<span class="lineNum">    6215 </span><span class="lineCov">       2933 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    6216 </span>            : 
<span class="lineNum">    6217 </span><span class="lineCov">       2933 :         if (ctx-&gt;subdur) {</span>
<span class="lineNum">    6218 </span>            :                 u32 nb_sub_done=0;
<span class="lineNum">    6219 </span><span class="lineCov">         38 :                 if (ctx-&gt;subdur_done) return;</span>
<span class="lineNum">    6220 </span><span class="lineCov">         70 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6221 </span><span class="lineCov">         70 :                         GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6222 </span><span class="lineCov">         70 :                         if (a_ds-&gt;muxed_base) {</span>
<span class="lineNum">    6223 </span><span class="lineCov">          2 :                                 if (a_ds-&gt;muxed_base-&gt;subdur_done) a_ds-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    6224 </span>            :                         }
<span class="lineNum">    6225 </span>            : 
<span class="lineNum">    6226 </span><span class="lineCov">         70 :                         if (a_ds-&gt;subdur_done) {</span>
<span class="lineNum">    6227 </span><span class="lineCov">         48 :                                 nb_sub_done++;</span>
<span class="lineNum">    6228 </span>            :                         }
<span class="lineNum">    6229 </span>            :                 }
<span class="lineNum">    6230 </span>            :                 // if one of the AS is done and we are at 30% of target subdur, abort
<span class="lineNum">    6231 </span><span class="lineCov">         38 :                 if (nb_sub_done &amp;&amp; !ds-&gt;subdur_done</span>
<span class="lineNum">    6232 </span><span class="lineNoCov">          0 :                         &amp;&amp; (ctx-&gt;subdur &amp;&amp; (ds-&gt;cumulated_dur &gt;= (0.7 * (ds-&gt;cumulated_subdur + ctx-&gt;subdur)) * ds-&gt;timescale))</span>
<span class="lineNum">    6233 </span>            :                 ) {
<span class="lineNum">    6234 </span><span class="lineNoCov">          0 :                         ds-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    6235 </span><span class="lineNoCov">          0 :                         nb_sub_done++;</span>
<span class="lineNum">    6236 </span>            :                 }
<span class="lineNum">    6237 </span><span class="lineCov">         38 :                 if (nb_sub_done==count)</span>
<span class="lineNum">    6238 </span><span class="lineCov">         20 :                         ctx-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    6239 </span>            :         }
<span class="lineNum">    6240 </span>            : 
<span class="lineNum">    6241 </span>            :         //reset all streams from our rep or our set
<span class="lineNum">    6242 </span><span class="lineCov">      15387 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6243 </span><span class="lineCov">      15387 :                 ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6244 </span>            :                 //reset all in set if segment alignment
<span class="lineNum">    6245 </span><span class="lineCov">      15387 :                 if (ctx-&gt;align) {</span>
<span class="lineNum">    6246 </span><span class="lineCov">      15387 :                         if (ds-&gt;set != set_ds-&gt;set) continue;</span>
<span class="lineNum">    6247 </span>            :                 } else {
<span class="lineNum">    6248 </span>            :                         //otherwise reset only media components for this rep
<span class="lineNum">    6249 </span><span class="lineNoCov">          0 :                         if ((ds-&gt;muxed_base != base_ds) &amp;&amp; (ds != base_ds)) continue;</span>
<span class="lineNum">    6250 </span>            :                 }
<span class="lineNum">    6251 </span>            : 
<span class="lineNum">    6252 </span><span class="lineCov">       3520 :                 if (!ds-&gt;done) {</span>
<span class="lineNum">    6253 </span><span class="lineCov">       3151 :                         ds-&gt;first_cts_in_next_seg = ds-&gt;first_cts_in_seg = ds-&gt;est_first_cts_in_next_seg = 0;</span>
<span class="lineNum">    6254 </span>            :                 }
<span class="lineNum">    6255 </span>            : 
<span class="lineNum">    6256 </span><span class="lineCov">       3520 :                 if (ds-&gt;muxed_base) {</span>
<span class="lineNum">    6257 </span><span class="lineCov">        157 :                         if (!ds-&gt;done) {</span>
<span class="lineNum">    6258 </span><span class="lineCov">        148 :                                 ds-&gt;segment_started = GF_FALSE;</span>
<span class="lineNum">    6259 </span><span class="lineCov">        148 :                                 ds-&gt;seg_done = GF_FALSE;</span>
<span class="lineNum">    6260 </span>            :                         } else {
<span class="lineNum">    6261 </span>            :                                 has_ds_done = GF_TRUE;
<span class="lineNum">    6262 </span>            :                         }
<span class="lineNum">    6263 </span><span class="lineCov">        157 :                         continue;</span>
<span class="lineNum">    6264 </span>            :                 }
<span class="lineNum">    6265 </span>            :                 base_ds = ds;
<span class="lineNum">    6266 </span>            : 
<span class="lineNum">    6267 </span><span class="lineCov">       3363 :                 if (base_ds-&gt;done)</span>
<span class="lineNum">    6268 </span>            :                         ds_done = base_ds;
<span class="lineNum">    6269 </span><span class="lineCov">       3003 :                 else if (base_ds-&gt;nb_comp_done==base_ds-&gt;nb_comp) ds_not_done = base_ds;</span>
<span class="lineNum">    6270 </span>            : 
<span class="lineNum">    6271 </span><span class="lineCov">       3363 :                 if (!base_ds-&gt;done &amp;&amp; base_ds-&gt;seg_done) {</span>
<span class="lineNum">    6272 </span><span class="lineCov">       3003 :                         base_ds-&gt;seg_done = GF_FALSE;</span>
<span class="lineNum">    6273 </span><span class="lineCov">       3003 :                         base_ds-&gt;nb_comp_done = 0;</span>
<span class="lineNum">    6274 </span>            : 
<span class="lineNum">    6275 </span>            : #ifndef GPAC_DISABLE_LOG
<span class="lineNum">    6276 </span><span class="lineCov">       3003 :                         if (ctx-&gt;dmode&gt;=GF_DASH_DYNAMIC) {</span>
<span class="lineNum">    6277 </span>            :                                 u32 asid;
<span class="lineNum">    6278 </span>            :                                 s64 ast_diff;
<span class="lineNum">    6279 </span><span class="lineCov">        103 :                                 u64 seg_ast = ctx-&gt;mpd-&gt;availabilityStartTime;</span>
<span class="lineNum">    6280 </span><span class="lineCov">        103 :                                 seg_ast += ctx-&gt;current_period-&gt;period-&gt;start;</span>
<span class="lineNum">    6281 </span><span class="lineCov">        103 :                                 seg_ast += (base_ds-&gt;adjusted_next_seg_start*1000) / base_ds-&gt;timescale;</span>
<span class="lineNum">    6282 </span>            : 
<span class="lineNum">    6283 </span>            :                                 //if theoretical AST of the segment is less than the current UTC, we are producing the segment too late.
<span class="lineNum">    6284 </span>            :                                 ast_diff = (s64) dasher_get_utc(ctx);
<span class="lineNum">    6285 </span><span class="lineCov">        103 :                                 ast_diff -= seg_ast;</span>
<span class="lineNum">    6286 </span>            : 
<span class="lineNum">    6287 </span><span class="lineCov">        103 :                                 asid = base_ds-&gt;set-&gt;id;</span>
<span class="lineNum">    6288 </span><span class="lineCov">        103 :                                 if (!asid)</span>
<span class="lineNum">    6289 </span><span class="lineNoCov">          0 :                                         asid = gf_list_find(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets, base_ds-&gt;set) + 1;</span>
<span class="lineNum">    6290 </span>            : 
<span class="lineNum">    6291 </span><span class="lineCov">        103 :                                 if (ast_diff&gt;10) {</span>
<span class="lineNum">    6292 </span><span class="lineCov">          5 :                                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] AS%d Rep %s segment %d done TOO LATE by %d ms\n&quot;, asid, base_ds-&gt;rep-&gt;id, base_ds-&gt;seg_number, (s32) ast_diff));</span>
<span class="lineNum">    6293 </span>            :                                 } else {
<span class="lineNum">    6294 </span><span class="lineCov">         98 :                                         GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] AS%d Rep %s segment %d done %d ms %s UTC due time\n&quot;, asid, base_ds-&gt;rep-&gt;id, base_ds-&gt;seg_number, ABS(ast_diff), (ast_diff&lt;0) ? &quot;before&quot; : &quot;after&quot;));</span>
<span class="lineNum">    6295 </span>            :                                 }
<span class="lineNum">    6296 </span>            :                         }
<span class="lineNum">    6297 </span>            : #endif
<span class="lineNum">    6298 </span>            : 
<span class="lineNum">    6299 </span>            :                         assert(base_ds-&gt;segment_started);
<span class="lineNum">    6300 </span><span class="lineCov">       3003 :                         base_ds-&gt;segment_started = GF_FALSE;</span>
<span class="lineNum">    6301 </span>            : 
<span class="lineNum">    6302 </span><span class="lineCov">       3003 :                         base_ds-&gt;next_seg_start += (u64) (base_ds-&gt;dash_dur.num) * base_ds-&gt;timescale / base_ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6303 </span><span class="lineCov">       6188 :                         while (base_ds-&gt;next_seg_start &lt;= base_ds-&gt;adjusted_next_seg_start) {</span>
<span class="lineNum">    6304 </span><span class="lineCov">        182 :                                 base_ds-&gt;next_seg_start += (u64) (base_ds-&gt;dash_dur.num) * base_ds-&gt;timescale / base_ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6305 </span><span class="lineCov">        182 :                                 if (ctx-&gt;skip_seg)</span>
<span class="lineNum">    6306 </span><span class="lineNoCov">          0 :                                         base_ds-&gt;seg_number++;</span>
<span class="lineNum">    6307 </span>            :                         }
<span class="lineNum">    6308 </span><span class="lineCov">       3003 :                         base_ds-&gt;adjusted_next_seg_start = base_ds-&gt;next_seg_start;</span>
<span class="lineNum">    6309 </span><span class="lineCov">       3003 :                         base_ds-&gt;seg_number++;</span>
<span class="lineNum">    6310 </span>            :                 }
<span class="lineNum">    6311 </span>            :         }
<span class="lineNum">    6312 </span>            : 
<span class="lineNum">    6313 </span><span class="lineCov">       2933 :         if (ds_log) {</span>
<span class="lineNum">    6314 </span><span class="lineCov">       2932 :                 GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[Dasher] Rep#%s flush seg %d start %g duration %g next seg end time %g\n&quot;, ds_log-&gt;rep-&gt;id, ds_log-&gt;seg_number-1, ((Double)first_cts_in_cur_seg)/ds_log-&gt;timescale, ((Double)seg_dur_ms)/1000, ((Double)ds_log-&gt;adjusted_next_seg_start)/ds_log-&gt;timescale));</span>
<span class="lineNum">    6315 </span>            :         }
<span class="lineNum">    6316 </span>            : 
<span class="lineNum">    6317 </span>            :         //muxed representation with unaligned duration,
<span class="lineNum">    6318 </span><span class="lineCov">       2933 :         if (has_ds_done) {</span>
<span class="lineNum">    6319 </span><span class="lineCov">         17 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6320 </span><span class="lineCov">         17 :                         ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6321 </span>            :                         //otherwise reset only media components for this rep
<span class="lineNum">    6322 </span><span class="lineCov">         17 :                         if ((ds-&gt;muxed_base != base_ds) &amp;&amp; (ds != base_ds)) continue;</span>
<span class="lineNum">    6323 </span>            : 
<span class="lineNum">    6324 </span><span class="lineCov">         17 :                         if (ds-&gt;done &amp;&amp; (base_ds-&gt;nb_comp_done &lt; base_ds-&gt;nb_comp)) {</span>
<span class="lineNum">    6325 </span><span class="lineNoCov">          0 :                                 base_ds-&gt;nb_comp_done++;</span>
<span class="lineNum">    6326 </span>            :                         }
<span class="lineNum">    6327 </span>            :                 }
<span class="lineNum">    6328 </span>            :         }
<span class="lineNum">    6329 </span>            : 
<span class="lineNum">    6330 </span>            :         //some reps are done, other not, force a max time on all AS in the period
<span class="lineNum">    6331 </span><span class="lineCov">       2933 :         if (ds_done &amp;&amp; ds_not_done) {</span>
<span class="lineNum">    6332 </span><span class="lineCov">        580 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6333 </span><span class="lineCov">        580 :                         ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6334 </span>            : 
<span class="lineNum">    6335 </span><span class="lineCov">        580 :                         if (ds-&gt;done) {</span>
<span class="lineNum">    6336 </span><span class="lineCov">        515 :                                 if (ds-&gt;set-&gt;udta == set_ds)</span>
<span class="lineNum">    6337 </span><span class="lineCov">         29 :                                         set_ds-&gt;nb_rep_done++;</span>
<span class="lineNum">    6338 </span><span class="lineCov">         65 :                         } else if (ctx-&gt;check_dur &amp;&amp; !ds-&gt;force_rep_end) {</span>
<span class="lineNum">    6339 </span><span class="lineNoCov">          0 :                                 ds-&gt;force_rep_end = ds_done-&gt;first_cts_in_next_seg * ds-&gt;timescale / ds_done-&gt;timescale;</span>
<span class="lineNum">    6340 </span>            :                         }
<span class="lineNum">    6341 </span>            :                 }
<span class="lineNum">    6342 </span>            :         }
<a name="6343"><span class="lineNum">    6343 </span>            : }</a>
<span class="lineNum">    6344 </span>            : 
<span class="lineNum">    6345 </span><span class="lineCov">         31 : static char *dasher_strip_base(GF_DasherCtx *ctx, char *url)</span>
<span class="lineNum">    6346 </span>            : {
<span class="lineNum">    6347 </span><span class="lineCov">         31 :         char *manifest_path = ctx-&gt;out_path;</span>
<span class="lineNum">    6348 </span>            :         char *file_path = url;
<span class="lineNum">    6349 </span>            :         char *res = url;
<span class="lineNum">    6350 </span>            : 
<span class="lineNum">    6351 </span><span class="lineCov">         31 :         if (!manifest_path || !url) return NULL;</span>
<span class="lineNum">    6352 </span>            :         
<span class="lineNum">    6353 </span><span class="lineCov">         31 :         if (!strncmp(manifest_path, &quot;./&quot;, 2)) manifest_path+=2;</span>
<span class="lineNum">    6354 </span><span class="lineCov">         31 :         if (!strncmp(file_path, &quot;./&quot;, 2)) file_path+=2;</span>
<span class="lineNum">    6355 </span>            : 
<span class="lineNum">    6356 </span><span class="lineCov">         31 :         const char *base_manifest = gf_file_basename(manifest_path);</span>
<span class="lineNum">    6357 </span><span class="lineCov">         31 :         u32 diff = (u32) (base_manifest - manifest_path);</span>
<span class="lineNum">    6358 </span><span class="lineCov">         31 :         if (!strncmp(file_path, manifest_path, diff)) {</span>
<span class="lineNum">    6359 </span><span class="lineCov">         31 :                 res = file_path + diff;</span>
<span class="lineNum">    6360 </span>            :         }
<span class="lineNum">    6361 </span>            :         return res;
<span class="lineNum">    6362 </span>            : }
<span class="lineNum">    6363 </span>            : 
<span class="lineNum">    6364 </span>            : static GFINLINE
<span class="lineNum">    6365 </span>            : u64 dasher_translate_cts(GF_DashStream *ds, u64 cts)
<span class="lineNum">    6366 </span>            : {
<span class="lineNum">    6367 </span><span class="lineCov">     134282 :         if (ds-&gt;cues) {</span>
<span class="lineNum">    6368 </span><span class="lineCov">       6247 :                 cts -= ds-&gt;first_cts;</span>
<span class="lineNum">    6369 </span><span class="lineCov">     128035 :         } else if (cts &lt; ds-&gt;first_dts) {</span>
<span class="lineNum">    6370 </span>            :                 cts = 0;
<span class="lineNum">    6371 </span><span class="lineCov">     128035 :         } else if (ds-&gt;pts_minus_cts&lt;0) {</span>
<span class="lineNum">    6372 </span><span class="lineCov">       9280 :                 if ((s64) (cts - ds-&gt;first_dts) &gt;= -ds-&gt;pts_minus_cts) {</span>
<span class="lineNum">    6373 </span><span class="lineCov">       9278 :                         cts = cts - ds-&gt;first_dts + ds-&gt;pts_minus_cts;</span>
<span class="lineNum">    6374 </span>            :                 } else {
<span class="lineNum">    6375 </span>            :                         cts = 0;
<span class="lineNum">    6376 </span>            :                 }
<span class="lineNum">    6377 </span>            :         } else {
<span class="lineNum">    6378 </span><span class="lineCov">     118755 :                 cts -= ds-&gt;first_cts;</span>
<span class="lineNum">    6379 </span>            :         }
<span class="lineNum">    6380 </span>            :         return cts;
<a name="6381"><span class="lineNum">    6381 </span>            : }</a>
<span class="lineNum">    6382 </span>            : 
<span class="lineNum">    6383 </span><span class="lineCov">       3490 : static void dasher_mark_segment_start(GF_DasherCtx *ctx, GF_DashStream *ds, GF_FilterPacket *pck, GF_FilterPacket *in_pck)</span>
<span class="lineNum">    6384 </span>            : {
<span class="lineNum">    6385 </span>            :         GF_DASH_SegmentContext *seg_state=NULL;
<span class="lineNum">    6386 </span>            :         char szSegmentName[GF_MAX_PATH], szSegmentFullPath[GF_MAX_PATH], szIndexName[GF_MAX_PATH];
<span class="lineNum">    6387 </span><span class="lineCov">       3490 :         GF_DashStream *base_ds = ds-&gt;muxed_base ? ds-&gt;muxed_base : ds;</span>
<span class="lineNum">    6388 </span>            : 
<span class="lineNum">    6389 </span><span class="lineCov">       3490 :         if (ctx-&gt;forward_mode) {</span>
<span class="lineNum">    6390 </span>            :                 const GF_PropertyValue *p_fname, *p_manifest;
<span class="lineNum">    6391 </span>            : 
<span class="lineNum">    6392 </span><span class="lineCov">         54 :                 p_fname = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);</span>
<span class="lineNum">    6393 </span><span class="lineCov">         54 :                 p_manifest = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);</span>
<span class="lineNum">    6394 </span><span class="lineCov">         54 :                 if (!p_fname || !p_fname-&gt;value.string || !p_manifest) {</span>
<span class="lineNum">    6395 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Couldn't fetch source URL / idx of segment in forward mode, cannot forward\n&quot;));</span>
<span class="lineNum">    6396 </span><span class="lineNoCov">          0 :                         ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    6397 </span><span class="lineCov">        830 :                         return;</span>
<span class="lineNum">    6398 </span>            :                 }
<span class="lineNum">    6399 </span>            :                 strcpy(szSegmentName, p_fname-&gt;value.string);
<span class="lineNum">    6400 </span>            :                 //remove filename property
<span class="lineNum">    6401 </span><span class="lineCov">         54 :                 gf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, NULL);</span>
<span class="lineNum">    6402 </span>            : 
<span class="lineNum">    6403 </span>            :                 //check for manifest update
<span class="lineNum">    6404 </span><span class="lineCov">         54 :                 p_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_DASH_MANIFEST);</span>
<span class="lineNum">    6405 </span><span class="lineCov">         54 :                 if (p_manifest) {</span>
<span class="lineNum">    6406 </span><span class="lineCov">          3 :                         if (p_manifest-&gt;value.string) {</span>
<span class="lineNum">    6407 </span><span class="lineCov">          3 :                                 if (strstr(p_manifest-&gt;value.string, &quot;&lt;MPD&quot;)) {</span>
<span class="lineNum">    6408 </span><span class="lineCov">          2 :                                         if (ctx-&gt;do_m3u8) {</span>
<span class="lineNum">    6409 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Manifest forward mode got DASH MPD but output is HLS M3U8, cannot operate - change formats or dasher forward mode\n&quot;));</span>
<span class="lineNum">    6410 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    6411 </span><span class="lineNoCov">          0 :                                                 return;</span>
<span class="lineNum">    6412 </span>            :                                         } else {
<span class="lineNum">    6413 </span><span class="lineCov">          2 :                                                 dasher_forward_mpd(ctx, p_manifest-&gt;value.string);</span>
<span class="lineNum">    6414 </span>            :                                         }
<span class="lineNum">    6415 </span>            :                                 } else {
<span class="lineNum">    6416 </span><span class="lineCov">          1 :                                         if (ctx-&gt;do_mpd) {</span>
<span class="lineNum">    6417 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Manifest forward mode got M3U6 but output is DASH MPD, cannot operate - change formats or dasher forward mode\n&quot;));</span>
<span class="lineNum">    6418 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    6419 </span><span class="lineNoCov">          0 :                                                 return;</span>
<span class="lineNum">    6420 </span>            :                                         } else {
<span class="lineNum">    6421 </span><span class="lineCov">          1 :                                                 dasher_forward_manifest_raw(ctx, ds, p_manifest-&gt;value.string, NULL);</span>
<span class="lineNum">    6422 </span>            :                                         }
<span class="lineNum">    6423 </span>            :                                 }
<span class="lineNum">    6424 </span>            :                         }
<span class="lineNum">    6425 </span><span class="lineCov">          3 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_DASH_MANIFEST, NULL);</span>
<span class="lineNum">    6426 </span>            :                 }
<span class="lineNum">    6427 </span>            : 
<span class="lineNum">    6428 </span>            :                 //check for HLS child playlist update
<span class="lineNum">    6429 </span><span class="lineCov">         54 :                 p_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_HLS_VARIANT);</span>
<span class="lineNum">    6430 </span><span class="lineCov">         54 :                 p_fname = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_HLS_VARIANT_NAME);</span>
<span class="lineNum">    6431 </span><span class="lineCov">         54 :                 if (p_manifest &amp;&amp; p_fname &amp;&amp; (p_fname-&gt;value.string_list.nb_items==p_manifest-&gt;value.string_list.nb_items)) {</span>
<span class="lineNum">    6432 </span>            :                         u32 i, count = p_fname-&gt;value.string_list.nb_items;
<span class="lineNum">    6433 </span><span class="lineCov">          3 :                         for (i=0; i&lt;count; i++)</span>
<span class="lineNum">    6434 </span><span class="lineCov">          3 :                                 dasher_forward_manifest_raw(ctx, ds, p_manifest-&gt;value.string_list.vals[i], p_fname-&gt;value.string_list.vals[i]);</span>
<span class="lineNum">    6435 </span>            :                 }
<span class="lineNum">    6436 </span><span class="lineCov">         54 :                 if (p_manifest)</span>
<span class="lineNum">    6437 </span><span class="lineCov">          1 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_VARIANT, NULL);</span>
<span class="lineNum">    6438 </span><span class="lineCov">         54 :                 if (p_fname)</span>
<span class="lineNum">    6439 </span><span class="lineCov">          1 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_VARIANT_NAME, NULL);</span>
<span class="lineNum">    6440 </span>            : 
<span class="lineNum">    6441 </span>            :                 //we need to move from segment name to output name
<span class="lineNum">    6442 </span><span class="lineCov">         54 :                 if (ctx-&gt;forward_mode==DASHER_FWD_ALL)</span>
<span class="lineNum">    6443 </span>            :                         goto send_packet;
<span class="lineNum">    6444 </span>            : 
<span class="lineNum">    6445 </span>            :         }
<span class="lineNum">    6446 </span><span class="lineCov">       3472 :         if (pck) {</span>
<span class="lineNum">    6447 </span><span class="lineCov">       3400 :                 if (ctx-&gt;ntp==DASHER_NTP_YES) {</span>
<span class="lineNum">    6448 </span><span class="lineNoCov">          0 :                         u64 ntpts = gf_net_get_ntp_ts();</span>
<span class="lineNum">    6449 </span><span class="lineNoCov">          0 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &amp;PROP_LONGUINT(ntpts));</span>
<span class="lineNum">    6450 </span><span class="lineCov">       3400 :                 } else if (ctx-&gt;ntp==DASHER_NTP_REM) {</span>
<span class="lineNum">    6451 </span><span class="lineCov">       3400 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, NULL);</span>
<span class="lineNum">    6452 </span>            :                 }
<span class="lineNum">    6453 </span>            : 
<span class="lineNum">    6454 </span><span class="lineCov">       3400 :                 gf_filter_pck_set_property(pck, GF_PROP_PCK_FILENUM, &amp;PROP_UINT(base_ds-&gt;seg_number ) );</span>
<span class="lineNum">    6455 </span>            :         }
<span class="lineNum">    6456 </span>            : 
<span class="lineNum">    6457 </span>            :         //only signal file name &amp; insert timelines on one stream for muxed representations
<span class="lineNum">    6458 </span><span class="lineCov">       3472 :         if (ds-&gt;muxed_base) return;</span>
<span class="lineNum">    6459 </span>            : 
<span class="lineNum">    6460 </span><span class="lineCov">       3315 :         ds-&gt;seg_start_time = ds-&gt;first_cts_in_seg;</span>
<span class="lineNum">    6461 </span><span class="lineCov">       3315 :         if (ds-&gt;timescale != ds-&gt;mpd_timescale) {</span>
<span class="lineNum">    6462 </span><span class="lineNoCov">          0 :                 ds-&gt;seg_start_time *= ds-&gt;mpd_timescale;</span>
<span class="lineNum">    6463 </span><span class="lineNoCov">          0 :                 ds-&gt;seg_start_time /= ds-&gt;timescale;</span>
<span class="lineNum">    6464 </span>            :         }
<span class="lineNum">    6465 </span>            : 
<span class="lineNum">    6466 </span><span class="lineCov">       3315 :         if (ctx-&gt;store_seg_states) {</span>
<span class="lineNum">    6467 </span>            :                 char *kms_uri;
<span class="lineNum">    6468 </span>            :                 const GF_PropertyValue *p;
<span class="lineNum">    6469 </span><span class="lineCov">        528 :                 if (!ds-&gt;rep-&gt;state_seg_list) {</span>
<span class="lineNum">    6470 </span><span class="lineCov">         71 :                         ds-&gt;rep-&gt;state_seg_list = gf_list_new();</span>
<span class="lineNum">    6471 </span>            :                 }
<span class="lineNum">    6472 </span><span class="lineCov">        528 :                 if (!ds-&gt;rep-&gt;dash_dur.num) {</span>
<span class="lineNum">    6473 </span><span class="lineCov">         85 :                         ds-&gt;rep-&gt;timescale = ds-&gt;timescale;</span>
<span class="lineNum">    6474 </span><span class="lineCov">         85 :                         ds-&gt;rep-&gt;streamtype = ds-&gt;stream_type;</span>
<span class="lineNum">    6475 </span><span class="lineCov">         85 :                         ds-&gt;rep-&gt;timescale_mpd = ds-&gt;mpd_timescale;</span>
<span class="lineNum">    6476 </span><span class="lineCov">         85 :                         p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_HLS_GROUPID);</span>
<span class="lineNum">    6477 </span><span class="lineCov">         85 :                         if (p)</span>
<span class="lineNum">    6478 </span><span class="lineCov">          2 :                                 ds-&gt;rep-&gt;groupID = p-&gt;value.string;</span>
<span class="lineNum">    6479 </span>            : 
<span class="lineNum">    6480 </span><span class="lineCov">         85 :                         ds-&gt;rep-&gt;dash_dur = ds-&gt;dash_dur;</span>
<span class="lineNum">    6481 </span><span class="lineCov">         85 :                         if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    6482 </span><span class="lineCov">          2 :                                 const GF_PropertyValue *pid_url = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_URL);</span>
<span class="lineNum">    6483 </span><span class="lineCov">          2 :                                 if (pid_url &amp;&amp; pid_url-&gt;value.string) {</span>
<span class="lineNum">    6484 </span><span class="lineCov">          2 :                                         ds-&gt;rep-&gt;hls_single_file_name = dasher_strip_base(ctx, pid_url-&gt;value.string);</span>
<span class="lineNum">    6485 </span>            :                                 }
<span class="lineNum">    6486 </span>            :                         }
<span class="lineNum">    6487 </span>            : 
<span class="lineNum">    6488 </span><span class="lineCov">         85 :                         if (!ds-&gt;rep-&gt;hls_single_file_name &amp;&amp; !ctx-&gt;m2ts) {</span>
<span class="lineNum">    6489 </span><span class="lineCov">         80 :                                 switch (ctx-&gt;muxtype) {</span>
<span class="lineNum">    6490 </span>            :                                 case DASHER_MUX_TS:
<span class="lineNum">    6491 </span>            :                                 case DASHER_MUX_OGG:
<span class="lineNum">    6492 </span>            :                                 case DASHER_MUX_RAW:
<span class="lineNum">    6493 </span>            :                                         break;
<span class="lineNum">    6494 </span><span class="lineCov">         80 :                                 default:</span>
<span class="lineNum">    6495 </span><span class="lineCov">         80 :                                         if (ds-&gt;set-&gt;bitstream_switching &amp;&amp; ds-&gt;set-&gt;segment_template)</span>
<span class="lineNum">    6496 </span><span class="lineCov">          4 :                                                 ds-&gt;rep-&gt;hls_single_file_name = ds-&gt;set-&gt;segment_template-&gt;hls_init_name;</span>
<span class="lineNum">    6497 </span>            :                                         else
<span class="lineNum">    6498 </span><span class="lineCov">         76 :                                                 ds-&gt;rep-&gt;hls_single_file_name = ds-&gt;init_seg;</span>
<span class="lineNum">    6499 </span>            :                                 }
<span class="lineNum">    6500 </span>            :                         }
<span class="lineNum">    6501 </span><span class="lineCov">         85 :                         ds-&gt;rep-&gt;nb_chan = ds-&gt;nb_ch;</span>
<span class="lineNum">    6502 </span><span class="lineCov">         85 :                         ds-&gt;rep-&gt;m3u8_name = ds-&gt;hls_vp_name;</span>
<span class="lineNum">    6503 </span><span class="lineCov">         85 :                         if (ds-&gt;fps.den) {</span>
<span class="lineNum">    6504 </span><span class="lineCov">         48 :                                 ds-&gt;rep-&gt;fps = ds-&gt;fps.num;</span>
<span class="lineNum">    6505 </span><span class="lineCov">         48 :                                 ds-&gt;rep-&gt;fps /= ds-&gt;fps.den;</span>
<span class="lineNum">    6506 </span>            :                         }
<span class="lineNum">    6507 </span>            :                 }
<span class="lineNum">    6508 </span><span class="lineCov">        528 :                 GF_SAFEALLOC(seg_state, GF_DASH_SegmentContext);</span>
<span class="lineNum">    6509 </span><span class="lineCov">        528 :                 if (!seg_state) return;</span>
<span class="lineNum">    6510 </span><span class="lineCov">        528 :                 seg_state-&gt;time = ds-&gt;seg_start_time;</span>
<span class="lineNum">    6511 </span><span class="lineCov">        528 :                 seg_state-&gt;seg_num = ds-&gt;seg_number;</span>
<span class="lineNum">    6512 </span><span class="lineCov">        528 :                 seg_state-&gt;llhls_mode = ctx-&gt;llhls;</span>
<span class="lineNum">    6513 </span><span class="lineCov">        528 :                 ds-&gt;current_seg_state = seg_state;</span>
<span class="lineNum">    6514 </span><span class="lineCov">        528 :                 seg_state-&gt;encrypted = GF_FALSE;</span>
<span class="lineNum">    6515 </span>            : 
<span class="lineNum">    6516 </span><span class="lineCov">        528 :                 p = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_HLS_KMS);</span>
<span class="lineNum">    6517 </span><span class="lineCov">        528 :                 kms_uri = (p &amp;&amp; p-&gt;value.string) ? p-&gt;value.string : NULL;</span>
<span class="lineNum">    6518 </span><span class="lineCov">        528 :                 if (ds-&gt;tci) {</span>
<span class="lineNum">    6519 </span>            :                         u32 s;
<span class="lineNum">    6520 </span><span class="lineNoCov">          0 :                         ds-&gt;iv_low++;</span>
<span class="lineNum">    6521 </span><span class="lineNoCov">          0 :                         if (ds-&gt;iv_low == 0)</span>
<span class="lineNum">    6522 </span><span class="lineNoCov">          0 :                                 ds-&gt;iv_high++;</span>
<span class="lineNum">    6523 </span><span class="lineNoCov">          0 :                         for (s=0; s&lt;8; s++)</span>
<span class="lineNum">    6524 </span><span class="lineNoCov">          0 :                                 seg_state-&gt;hls_iv[s] = (ds-&gt;iv_high &gt;&gt; 8*(7-s) ) &amp; 0xFF;</span>
<span class="lineNum">    6525 </span><span class="lineNoCov">          0 :                         for (s=0; s&lt;8; s++)</span>
<span class="lineNum">    6526 </span><span class="lineNoCov">          0 :                                 seg_state-&gt;hls_iv[s+8] = (ds-&gt;iv_low &gt;&gt; 8*(7-s) ) &amp; 0xFF;</span>
<span class="lineNum">    6527 </span>            : 
<span class="lineNum">    6528 </span><span class="lineNoCov">          0 :                         seg_state-&gt;encrypted = GF_TRUE;</span>
<span class="lineNum">    6529 </span><span class="lineNoCov">          0 :                         gf_cryptfout_push_key(ds-&gt;dst_filter, &amp; ds-&gt;tci-&gt;keys[ds-&gt;key_idx].key, &amp;seg_state-&gt;hls_iv);</span>
<span class="lineNum">    6530 </span>            : 
<span class="lineNum">    6531 </span><span class="lineNoCov">          0 :                         if (ds-&gt;tci-&gt;keys[ds-&gt;key_idx].hls_info)</span>
<span class="lineNum">    6532 </span>            :                                 kms_uri = ds-&gt;tci-&gt;keys[ds-&gt;key_idx].hls_info;
<span class="lineNum">    6533 </span>            : 
<span class="lineNum">    6534 </span><span class="lineNoCov">          0 :                         ds-&gt;nb_crypt_seg++;</span>
<span class="lineNum">    6535 </span><span class="lineNoCov">          0 :                         if (ds-&gt;tci-&gt;keyRoll) {</span>
<span class="lineNum">    6536 </span><span class="lineNoCov">          0 :                                 if (ds-&gt;nb_crypt_seg == ds-&gt;tci-&gt;keyRoll) {</span>
<span class="lineNum">    6537 </span><span class="lineNoCov">          0 :                                         ds-&gt;nb_crypt_seg = 0;</span>
<span class="lineNum">    6538 </span><span class="lineNoCov">          0 :                                         ds-&gt;key_idx = (ds-&gt;key_idx+1) % ds-&gt;tci-&gt;nb_keys;</span>
<span class="lineNum">    6539 </span>            :                                 }
<span class="lineNum">    6540 </span>            :                         }
<span class="lineNum">    6541 </span>            :                 }
<span class="lineNum">    6542 </span>            :                 //we need a hard copy as the pid may reconfigure before we flush the segment
<span class="lineNum">    6543 </span><span class="lineCov">        528 :                 if (kms_uri)</span>
<span class="lineNum">    6544 </span><span class="lineCov">         24 :                         seg_state-&gt;hls_key_uri = gf_strdup(kms_uri);</span>
<span class="lineNum">    6545 </span>            : 
<span class="lineNum">    6546 </span><span class="lineCov">        528 :                 gf_list_add(ds-&gt;rep-&gt;state_seg_list, seg_state);</span>
<span class="lineNum">    6547 </span><span class="lineCov">        528 :                 if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    6548 </span><span class="lineCov">         24 :                         const GF_PropertyValue *frag_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FRAG_RANGE);</span>
<span class="lineNum">    6549 </span><span class="lineCov">         24 :                         const GF_PropertyValue *frag_url = gf_filter_pck_get_property(in_pck, GF_PROP_PID_URL);</span>
<span class="lineNum">    6550 </span><span class="lineCov">         33 :                         if (frag_url &amp;&amp; frag_url-&gt;value.string) {</span>
<span class="lineNum">    6551 </span><span class="lineCov">          9 :                                 char *f_url = dasher_strip_base(ctx, frag_url-&gt;value.string);</span>
<span class="lineNum">    6552 </span><span class="lineCov">          9 :                                 seg_state-&gt;filename = gf_strdup(f_url);</span>
<span class="lineNum">    6553 </span>            :                         }
<span class="lineNum">    6554 </span><span class="lineCov">         15 :                         else if (frag_range) {</span>
<span class="lineNum">    6555 </span><span class="lineCov">         15 :                                 seg_state-&gt;file_offset = frag_range-&gt;value.lfrac.num;</span>
<span class="lineNum">    6556 </span><span class="lineCov">         15 :                                 seg_state-&gt;file_size = (u32) (frag_range-&gt;value.lfrac.den - seg_state-&gt;file_offset);</span>
<span class="lineNum">    6557 </span>            : 
<span class="lineNum">    6558 </span><span class="lineCov">         15 :                                 if (ds-&gt;rep-&gt;segment_base &amp;&amp; !ds-&gt;rep-&gt;segment_base-&gt;initialization_segment) {</span>
<span class="lineNum">    6559 </span>            :                                         GF_MPD_URL *url;
<span class="lineNum">    6560 </span><span class="lineNoCov">          0 :                                         GF_SAFEALLOC(url, GF_MPD_URL);</span>
<span class="lineNum">    6561 </span><span class="lineNoCov">          0 :                                         if (url) {</span>
<span class="lineNum">    6562 </span><span class="lineNoCov">          0 :                                                 GF_SAFEALLOC(url-&gt;byte_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    6563 </span><span class="lineNoCov">          0 :                                                 if (url-&gt;byte_range) {</span>
<span class="lineNum">    6564 </span><span class="lineNoCov">          0 :                                                         url-&gt;byte_range-&gt;start_range = 0;</span>
<span class="lineNum">    6565 </span><span class="lineNoCov">          0 :                                                         url-&gt;byte_range-&gt;end_range = seg_state-&gt;file_offset-1;</span>
<span class="lineNum">    6566 </span>            :                                                 }
<span class="lineNum">    6567 </span>            :                                         }
<span class="lineNum">    6568 </span><span class="lineNoCov">          0 :                                         ds-&gt;rep-&gt;segment_base-&gt;initialization_segment = url;</span>
<span class="lineNum">    6569 </span>            :                                 }
<span class="lineNum">    6570 </span>            :                         } else {
<span class="lineNum">    6571 </span><span class="lineNoCov">          0 :                                 gf_list_del_item(ds-&gt;rep-&gt;state_seg_list, seg_state);</span>
<span class="lineNum">    6572 </span><span class="lineNoCov">          0 :                                 gf_free(seg_state);</span>
<span class="lineNum">    6573 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Manifest generation only but not fragment information in packet, source demux not properly configured\n&quot;));</span>
<span class="lineNum">    6574 </span><span class="lineNoCov">          0 :                                 ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    6575 </span>            :                         }
<span class="lineNum">    6576 </span>            :                 } else {
<span class="lineNum">    6577 </span><span class="lineCov">        504 :                         gf_list_add(ds-&gt;pending_segment_states, seg_state);</span>
<span class="lineNum">    6578 </span><span class="lineCov">        504 :                         ctx-&gt;nb_seg_url_pending++;</span>
<span class="lineNum">    6579 </span>            :                 }
<span class="lineNum">    6580 </span>            :         }
<span class="lineNum">    6581 </span>            : 
<span class="lineNum">    6582 </span><span class="lineCov">       3315 :         szIndexName[0] = 0;</span>
<span class="lineNum">    6583 </span><span class="lineCov">       3315 :         if (ds-&gt;idx_template) {</span>
<span class="lineNum">    6584 </span>            :                 //get final segment template - output file name is NULL, we already have solved this in source_setup
<span class="lineNum">    6585 </span><span class="lineCov">          8 :                 gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, ds-&gt;set-&gt;bitstream_switching, szIndexName, base_ds-&gt;rep_id, NULL, base_ds-&gt;idx_template, NULL, base_ds-&gt;seg_start_time, base_ds-&gt;rep-&gt;bandwidth, base_ds-&gt;seg_number, ctx-&gt;stl);</span>
<span class="lineNum">    6586 </span>            : 
<span class="lineNum">    6587 </span>            :                 strcpy(szSegmentFullPath, szIndexName);
<span class="lineNum">    6588 </span><span class="lineCov">          8 :                 if (ctx-&gt;out_path) {</span>
<span class="lineNum">    6589 </span><span class="lineCov">          8 :                         char *rel = gf_url_concatenate(ctx-&gt;out_path, szIndexName);</span>
<span class="lineNum">    6590 </span><span class="lineCov">          8 :                         if (rel) {</span>
<span class="lineNum">    6591 </span>            :                                 strcpy(szSegmentFullPath, rel);
<span class="lineNum">    6592 </span><span class="lineCov">          8 :                                 gf_free(rel);</span>
<span class="lineNum">    6593 </span>            :                         }
<span class="lineNum">    6594 </span>            :                 }
<span class="lineNum">    6595 </span><span class="lineCov">          8 :                 if (pck)</span>
<span class="lineNum">    6596 </span><span class="lineCov">          8 :                         gf_filter_pck_set_property(pck, GF_PROP_PCK_IDXFILENAME, &amp;PROP_STRING(szSegmentFullPath) );</span>
<span class="lineNum">    6597 </span>            :         }
<span class="lineNum">    6598 </span>            : 
<span class="lineNum">    6599 </span><span class="lineCov">       3315 :         if (ctx-&gt;sseg) {</span>
<span class="lineNum">    6600 </span><span class="lineCov">        324 :                 if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    6601 </span><span class="lineCov">         15 :                         const GF_PropertyValue *p = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_SIDX_RANGE);</span>
<span class="lineNum">    6602 </span><span class="lineCov">         15 :                         if (p) {</span>
<span class="lineNum">    6603 </span><span class="lineCov">          1 :                                 if (ds-&gt;rep-&gt;segment_base &amp;&amp; !ds-&gt;rep-&gt;segment_base-&gt;index_range) {</span>
<span class="lineNum">    6604 </span><span class="lineCov">          1 :                                         GF_SAFEALLOC(ds-&gt;rep-&gt;segment_base-&gt;index_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    6605 </span><span class="lineCov">          1 :                                         if (ds-&gt;rep-&gt;segment_base-&gt;index_range) {</span>
<span class="lineNum">    6606 </span><span class="lineCov">          1 :                                                 ds-&gt;rep-&gt;segment_base-&gt;index_range-&gt;start_range = p-&gt;value.lfrac.num;</span>
<span class="lineNum">    6607 </span><span class="lineCov">          1 :                                                 ds-&gt;rep-&gt;segment_base-&gt;index_range-&gt;end_range = p-&gt;value.lfrac.den;</span>
<span class="lineNum">    6608 </span><span class="lineCov">          1 :                                                 ds-&gt;rep-&gt;segment_base-&gt;index_range_exact = GF_TRUE;</span>
<span class="lineNum">    6609 </span>            :                                         }
<span class="lineNum">    6610 </span>            : 
<span class="lineNum">    6611 </span><span class="lineCov">          1 :                                         if (!ds-&gt;rep-&gt;segment_base-&gt;initialization_segment) {</span>
<span class="lineNum">    6612 </span><span class="lineCov">          1 :                                                 GF_SAFEALLOC(ds-&gt;rep-&gt;segment_base-&gt;initialization_segment, GF_MPD_URL);</span>
<span class="lineNum">    6613 </span>            :                                         }
<span class="lineNum">    6614 </span><span class="lineCov">          1 :                                         if (ds-&gt;rep-&gt;segment_base-&gt;initialization_segment &amp;&amp; !ds-&gt;rep-&gt;segment_base-&gt;initialization_segment-&gt;byte_range) {</span>
<span class="lineNum">    6615 </span><span class="lineCov">          1 :                                                 GF_SAFEALLOC(ds-&gt;rep-&gt;segment_base-&gt;initialization_segment-&gt;byte_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    6616 </span><span class="lineCov">          1 :                                                 if (ds-&gt;rep-&gt;segment_base-&gt;initialization_segment-&gt;byte_range) {</span>
<span class="lineNum">    6617 </span><span class="lineCov">          1 :                                                         ds-&gt;rep-&gt;segment_base-&gt;initialization_segment-&gt;byte_range-&gt;start_range = 0;</span>
<span class="lineNum">    6618 </span><span class="lineCov">          1 :                                                         ds-&gt;rep-&gt;segment_base-&gt;initialization_segment-&gt;byte_range-&gt;end_range = p-&gt;value.lfrac.num-1;</span>
<span class="lineNum">    6619 </span>            :                                                 }
<span class="lineNum">    6620 </span>            :                                         }
<span class="lineNum">    6621 </span>            :                                 } else {
<span class="lineNum">    6622 </span><span class="lineNoCov">          0 :                                         ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    6623 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Several SIDX found but trying to regenerate an on-demand MPD, source file is not compatible. Try re-dashing the content or use main or full profiles\n&quot;));</span>
<span class="lineNum">    6624 </span>            :                                 }
<span class="lineNum">    6625 </span>            :                         }
<span class="lineNum">    6626 </span>            :                 }
<span class="lineNum">    6627 </span>            :                 return;
<span class="lineNum">    6628 </span>            :         }
<span class="lineNum">    6629 </span>            : 
<span class="lineNum">    6630 </span><span class="lineCov">       2991 :         if (ctx-&gt;sfile) {</span>
<span class="lineNum">    6631 </span>            :                 GF_MPD_SegmentURL *seg_url;
<span class="lineNum">    6632 </span>            :                 assert(ds-&gt;rep-&gt;segment_list);
<span class="lineNum">    6633 </span><span class="lineCov">        349 :                 GF_SAFEALLOC(seg_url, GF_MPD_SegmentURL);</span>
<span class="lineNum">    6634 </span><span class="lineCov">        349 :                 if (!seg_url) return;</span>
<span class="lineNum">    6635 </span>            : 
<span class="lineNum">    6636 </span><span class="lineCov">        349 :                 gf_list_add(ds-&gt;rep-&gt;segment_list-&gt;segment_URLs, seg_url);</span>
<span class="lineNum">    6637 </span><span class="lineCov">        349 :                 if (szIndexName[0])</span>
<span class="lineNum">    6638 </span><span class="lineNoCov">          0 :                         seg_url-&gt;index = gf_strdup(szIndexName);</span>
<span class="lineNum">    6639 </span>            : 
<span class="lineNum">    6640 </span><span class="lineCov">        349 :                 if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    6641 </span><span class="lineCov">         48 :                         const GF_PropertyValue *frag_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FRAG_RANGE);</span>
<span class="lineNum">    6642 </span><span class="lineCov">         48 :                         const GF_PropertyValue *frag_url = gf_filter_pck_get_property(in_pck, GF_PROP_PID_URL);</span>
<span class="lineNum">    6643 </span><span class="lineCov">         48 :                         if (frag_url &amp;&amp; frag_url-&gt;value.string) {</span>
<span class="lineNum">    6644 </span><span class="lineCov">         18 :                                 seg_url-&gt;media = gf_strdup(dasher_strip_base(ctx, frag_url-&gt;value.string));</span>
<span class="lineNum">    6645 </span><span class="lineCov">         18 :                                 if (ds-&gt;rep-&gt;segment_list &amp;&amp; ds-&gt;rep-&gt;segment_list-&gt;initialization_segment &amp;&amp; !ds-&gt;rep-&gt;segment_list-&gt;initialization_segment-&gt;sourceURL) {</span>
<span class="lineNum">    6646 </span>            : 
<span class="lineNum">    6647 </span><span class="lineCov">          2 :                                         frag_url = gf_filter_pid_get_property(ds-&gt;ipid, GF_PROP_PID_URL);</span>
<span class="lineNum">    6648 </span><span class="lineCov">          2 :                                         if (frag_url &amp;&amp; frag_url-&gt;value.string) {</span>
<span class="lineNum">    6649 </span>            :                                                 u32 j, nb_base;
<span class="lineNum">    6650 </span><span class="lineCov">          2 :                                                 ds-&gt;rep-&gt;segment_list-&gt;initialization_segment-&gt;sourceURL = gf_strdup(dasher_strip_base(ctx, frag_url-&gt;value.string) );</span>
<span class="lineNum">    6651 </span>            : 
<span class="lineNum">    6652 </span><span class="lineCov">          2 :                                                 nb_base = gf_list_count(ds-&gt;rep-&gt;base_URLs);</span>
<span class="lineNum">    6653 </span><span class="lineCov">          4 :                                                 for (j=0; j&lt;nb_base; j++) {</span>
<span class="lineNum">    6654 </span><span class="lineCov">          2 :                                                         GF_MPD_BaseURL *burl = gf_list_get(ds-&gt;rep-&gt;base_URLs, j);</span>
<span class="lineNum">    6655 </span><span class="lineCov">          2 :                                                         if (! strcmp(burl-&gt;URL, frag_url-&gt;value.string)) {</span>
<span class="lineNum">    6656 </span><span class="lineNoCov">          0 :                                                                 gf_list_rem(ds-&gt;rep-&gt;base_URLs, j);</span>
<span class="lineNum">    6657 </span><span class="lineNoCov">          0 :                                                                 gf_mpd_base_url_free(burl);</span>
<span class="lineNum">    6658 </span><span class="lineNoCov">          0 :                                                                 break;</span>
<span class="lineNum">    6659 </span>            :                                                         }
<span class="lineNum">    6660 </span>            :                                                 }
<span class="lineNum">    6661 </span>            :                                         }
<span class="lineNum">    6662 </span>            :                                 }
<span class="lineNum">    6663 </span>            :                         }
<span class="lineNum">    6664 </span><span class="lineCov">         30 :                         else if (frag_range) {</span>
<span class="lineNum">    6665 </span><span class="lineCov">         30 :                                 GF_SAFEALLOC(seg_url-&gt;media_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    6666 </span><span class="lineCov">         30 :                                 if (seg_url-&gt;media_range) {</span>
<span class="lineNum">    6667 </span><span class="lineCov">         30 :                                         seg_url-&gt;media_range-&gt;start_range = frag_range-&gt;value.lfrac.num;</span>
<span class="lineNum">    6668 </span><span class="lineCov">         30 :                                         seg_url-&gt;media_range-&gt;end_range = frag_range-&gt;value.lfrac.den - 1;</span>
<span class="lineNum">    6669 </span>            :                                 }
<span class="lineNum">    6670 </span><span class="lineCov">         30 :                                 if (ds-&gt;rep-&gt;segment_list &amp;&amp; ds-&gt;rep-&gt;segment_list-&gt;initialization_segment &amp;&amp; !ds-&gt;rep-&gt;segment_list-&gt;initialization_segment-&gt;byte_range) {</span>
<span class="lineNum">    6671 </span><span class="lineCov">          2 :                                         GF_SAFEALLOC(ds-&gt;rep-&gt;segment_list-&gt;initialization_segment-&gt;byte_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    6672 </span><span class="lineCov">          2 :                                         if (ds-&gt;rep-&gt;segment_list-&gt;initialization_segment-&gt;byte_range) {</span>
<span class="lineNum">    6673 </span><span class="lineCov">          2 :                                                 ds-&gt;rep-&gt;segment_list-&gt;initialization_segment-&gt;byte_range-&gt;start_range = 0;</span>
<span class="lineNum">    6674 </span><span class="lineCov">          2 :                                                 ds-&gt;rep-&gt;segment_list-&gt;initialization_segment-&gt;byte_range-&gt;end_range = frag_range-&gt;value.lfrac.num-1;</span>
<span class="lineNum">    6675 </span>            :                                         }
<span class="lineNum">    6676 </span>            :                                 }
<span class="lineNum">    6677 </span>            :                         }
<span class="lineNum">    6678 </span>            :                 } else {
<span class="lineNum">    6679 </span><span class="lineCov">        301 :                         gf_list_add(ds-&gt;pending_segment_urls, seg_url);</span>
<span class="lineNum">    6680 </span><span class="lineCov">        301 :                         ctx-&gt;nb_seg_url_pending++;</span>
<span class="lineNum">    6681 </span>            :                 }
<span class="lineNum">    6682 </span>            :                 return;
<span class="lineNum">    6683 </span>            :         }
<span class="lineNum">    6684 </span>            : 
<span class="lineNum">    6685 </span><span class="lineCov">       2642 :         if (!ctx-&gt;stl &amp;&amp; !ctx-&gt;cues &amp;&amp; !ctx-&gt;forward_mode) {</span>
<span class="lineNum">    6686 </span><span class="lineCov">       2545 :                 Double drift, seg_start = (Double) ds-&gt;seg_start_time;</span>
<span class="lineNum">    6687 </span><span class="lineCov">       2545 :                 seg_start /= ds-&gt;mpd_timescale;</span>
<span class="lineNum">    6688 </span><span class="lineCov">       2545 :                 drift = seg_start - ((Double)(ds-&gt;seg_number - ds-&gt;startNumber)) * ds-&gt;dash_dur.num / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6689 </span>            : 
<span class="lineNum">    6690 </span><span class="lineCov">       2545 :                 if ((ds-&gt;dash_dur.num&gt;0) &amp;&amp; (ABS(drift) * 2 * ds-&gt;dash_dur.den &gt; ds-&gt;dash_dur.num)) {</span>
<span class="lineNum">    6691 </span>            :                         u64 cts = 0;
<span class="lineNum">    6692 </span><span class="lineCov">         24 :                         if (pck) {</span>
<span class="lineNum">    6693 </span><span class="lineCov">         24 :                                 cts = dasher_translate_cts(ds, gf_filter_pck_get_cts(pck) );</span>
<span class="lineNum">    6694 </span>            :                         }
<span class="lineNum">    6695 </span><span class="lineCov">         24 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] First CTS &quot;LLU&quot; in segment %d drifting by %g (more than half a segment duration) from segment time, consider reencoding or using segment timeline\n&quot;, cts, ds-&gt;seg_number,  drift));</span>
<span class="lineNum">    6696 </span>            :                 }
<span class="lineNum">    6697 </span>            :         }
<span class="lineNum">    6698 </span>            : 
<span class="lineNum">    6699 </span><span class="lineCov">       2642 :         if (!ctx-&gt;forward_mode) {</span>
<span class="lineNum">    6700 </span>            :                 //get final segment template - output file name is NULL, we already have solved this in source_setup
<span class="lineNum">    6701 </span><span class="lineCov">       2606 :                 gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, ds-&gt;set-&gt;bitstream_switching, szSegmentName, base_ds-&gt;rep_id, NULL, base_ds-&gt;seg_template, NULL, base_ds-&gt;seg_start_time, base_ds-&gt;rep-&gt;bandwidth, base_ds-&gt;seg_number, ctx-&gt;stl);</span>
<span class="lineNum">    6702 </span>            :         }
<span class="lineNum">    6703 </span>            : 
<span class="lineNum">    6704 </span>            : 
<span class="lineNum">    6705 </span><span class="lineCov">       2714 : send_packet:</span>
<span class="lineNum">    6706 </span>            :         strcpy(szSegmentFullPath, szSegmentName);
<span class="lineNum">    6707 </span>            : 
<span class="lineNum">    6708 </span><span class="lineCov">       2660 :         if (ctx-&gt;out_path) {</span>
<span class="lineNum">    6709 </span>            :                 char *rel = NULL;
<span class="lineNum">    6710 </span><span class="lineCov">       2660 :                 if (ctx-&gt;do_m3u8 &amp;&amp; ds-&gt;hls_vp_name &amp;&amp; !ctx-&gt;forward_mode) {</span>
<span class="lineNum">    6711 </span><span class="lineNoCov">          0 :                         char *tmp = gf_url_concatenate(ctx-&gt;out_path, ds-&gt;hls_vp_name);</span>
<span class="lineNum">    6712 </span><span class="lineNoCov">          0 :                         if (tmp) {</span>
<span class="lineNum">    6713 </span><span class="lineNoCov">          0 :                                 rel = gf_url_concatenate(tmp, szSegmentName);</span>
<span class="lineNum">    6714 </span><span class="lineNoCov">          0 :                                 gf_free(tmp);</span>
<span class="lineNum">    6715 </span>            :                         }
<span class="lineNum">    6716 </span>            :                 }
<span class="lineNum">    6717 </span><span class="lineNoCov">          0 :                 if (!rel)</span>
<span class="lineNum">    6718 </span><span class="lineCov">       2660 :                         rel = gf_url_concatenate(ctx-&gt;out_path, szSegmentName);</span>
<span class="lineNum">    6719 </span>            : 
<span class="lineNum">    6720 </span><span class="lineCov">       2660 :                 if (rel) {</span>
<span class="lineNum">    6721 </span>            :                         strcpy(szSegmentFullPath, rel);
<span class="lineNum">    6722 </span><span class="lineCov">       2660 :                         gf_free(rel);</span>
<span class="lineNum">    6723 </span>            :                 }
<span class="lineNum">    6724 </span>            :         }
<span class="lineNum">    6725 </span>            : 
<span class="lineNum">    6726 </span><span class="lineCov">       2660 :         if (seg_state) {</span>
<span class="lineNum">    6727 </span><span class="lineCov">        443 :                 seg_state-&gt;filepath = gf_strdup(szSegmentFullPath);</span>
<span class="lineNum">    6728 </span><span class="lineCov">        443 :                 seg_state-&gt;filename = gf_strdup(szSegmentName);</span>
<span class="lineNum">    6729 </span>            :         }
<span class="lineNum">    6730 </span>            : 
<span class="lineNum">    6731 </span><span class="lineCov">       2660 :         if (ds-&gt;rep-&gt;segment_list &amp;&amp; (ctx-&gt;forward_mode!=DASHER_FWD_ALL) ) {</span>
<span class="lineNum">    6732 </span>            :                 GF_MPD_SegmentURL *seg_url;
<span class="lineNum">    6733 </span><span class="lineCov">         41 :                 GF_SAFEALLOC(seg_url, GF_MPD_SegmentURL);</span>
<span class="lineNum">    6734 </span><span class="lineCov">         41 :                 if (seg_url) {</span>
<span class="lineNum">    6735 </span><span class="lineCov">         41 :                         gf_list_add(ds-&gt;rep-&gt;segment_list-&gt;segment_URLs, seg_url);</span>
<span class="lineNum">    6736 </span><span class="lineCov">         41 :                         seg_url-&gt;media = gf_strdup(szSegmentName);</span>
<span class="lineNum">    6737 </span><span class="lineCov">         41 :                         gf_list_add(ds-&gt;pending_segment_urls, seg_url);</span>
<span class="lineNum">    6738 </span><span class="lineCov">         41 :                         if (szIndexName[0])</span>
<span class="lineNum">    6739 </span><span class="lineNoCov">          0 :                                 seg_url-&gt;index = gf_strdup(szIndexName);</span>
<span class="lineNum">    6740 </span>            :                 }
<span class="lineNum">    6741 </span><span class="lineCov">         41 :                 ctx-&gt;nb_seg_url_pending++;</span>
<span class="lineNum">    6742 </span>            :         }
<span class="lineNum">    6743 </span><span class="lineCov">       2660 :         if (pck)</span>
<span class="lineNum">    6744 </span><span class="lineCov">       2651 :                 gf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &amp;PROP_STRING(szSegmentFullPath) );</span>
<a name="6745"><span class="lineNum">    6745 </span>            : }</a>
<span class="lineNum">    6746 </span>            : 
<span class="lineNum">    6747 </span><span class="lineCov">        140 : static Bool dasher_check_loop(GF_DasherCtx *ctx, GF_DashStream *ds)</span>
<span class="lineNum">    6748 </span>            : {
<span class="lineNum">    6749 </span>            :         u32 i, count;
<span class="lineNum">    6750 </span>            :         u32 pmode = GF_PLAYBACK_MODE_NONE;
<span class="lineNum">    6751 </span>            :         u64 ts_offset, max_ts_offset, max_ts_scale;
<span class="lineNum">    6752 </span>            :         const GF_PropertyValue *p;
<span class="lineNum">    6753 </span><span class="lineCov">        140 :         if (!ds-&gt;src_url) return GF_FALSE;</span>
<span class="lineNum">    6754 </span>            : 
<span class="lineNum">    6755 </span>            :         //loop requested
<span class="lineNum">    6756 </span><span class="lineCov">        140 :         if (ds-&gt;loop_state==2) return GF_TRUE;</span>
<span class="lineNum">    6757 </span>            : 
<span class="lineNum">    6758 </span><span class="lineCov">        140 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    6759 </span><span class="lineCov">        140 :         if (!ds-&gt;loop_state) {</span>
<span class="lineNum">    6760 </span><span class="lineCov">         28 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6761 </span><span class="lineCov">         28 :                         GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6762 </span>            : 
<span class="lineNum">    6763 </span><span class="lineCov">         28 :                         p = gf_filter_pid_get_property(a_ds-&gt;ipid, GF_PROP_PID_PLAYBACK_MODE);</span>
<span class="lineNum">    6764 </span><span class="lineCov">         28 :                         if (p) pmode = p-&gt;value.uint;</span>
<span class="lineNum">    6765 </span><span class="lineCov">         28 :                         if (pmode == GF_PLAYBACK_MODE_NONE) {</span>
<span class="lineNum">    6766 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Loop requested in subdur mode, but source cannot seek, defaulting to multi period for all streams\n&quot;));</span>
<span class="lineNum">    6767 </span><span class="lineNoCov">          0 :                                 ctx-&gt;loop = GF_FALSE;</span>
<span class="lineNum">    6768 </span><span class="lineNoCov">          0 :                                 return GF_FALSE;</span>
<span class="lineNum">    6769 </span>            :                         }
<span class="lineNum">    6770 </span>            :                 }
<span class="lineNum">    6771 </span><span class="lineCov">         14 :                 ds-&gt;loop_state = 1;</span>
<span class="lineNum">    6772 </span>            :         }
<span class="lineNum">    6773 </span>            : 
<span class="lineNum">    6774 </span>            :         max_ts_offset = 0;
<span class="lineNum">    6775 </span>            :         max_ts_scale = 1;
<span class="lineNum">    6776 </span>            :         //check all input media duration
<span class="lineNum">    6777 </span><span class="lineCov">        110 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6778 </span><span class="lineCov">        243 :                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6779 </span>            : 
<span class="lineNum">    6780 </span>            :                 //one pid is waiting for loop while another has done its subdur and won't process any new segment until the next subdur call, which
<span class="lineNum">    6781 </span>            :                 //will never happen since the first PID waits for loop. We must force early generation in this case
<span class="lineNum">    6782 </span><span class="lineCov">        243 :                 if (a_ds-&gt;subdur_done) {</span>
<span class="lineNum">    6783 </span><span class="lineCov">          3 :                         a_ds-&gt;subdur_done = GF_FALSE;</span>
<span class="lineNum">    6784 </span>            :                         //remember the max period dur before this forced segment generation
<span class="lineNum">    6785 </span><span class="lineCov">          3 :                         a_ds-&gt;subdur_forced_use_period_dur = a_ds-&gt;max_period_dur;</span>
<span class="lineNum">    6786 </span>            :                 }
<span class="lineNum">    6787 </span>            : 
<span class="lineNum">    6788 </span>            :                 //wait for each input to query loop
<span class="lineNum">    6789 </span><span class="lineCov">        243 :                 if (!a_ds-&gt;loop_state) {</span>
<span class="lineNum">    6790 </span><span class="lineCov">        133 :                         a_ds-&gt;done = 0;</span>
<span class="lineNum">    6791 </span><span class="lineCov">        133 :                         return GF_TRUE;</span>
<span class="lineNum">    6792 </span>            :                 }
<span class="lineNum">    6793 </span>            : 
<span class="lineNum">    6794 </span>            :                 //get max duration
<span class="lineNum">    6795 </span><span class="lineCov">        110 :                 ts_offset = a_ds-&gt;est_next_dts;</span>
<span class="lineNum">    6796 </span>            : 
<span class="lineNum">    6797 </span><span class="lineCov">        110 :                 if (max_ts_offset * a_ds-&gt;timescale &lt; ts_offset * max_ts_scale) {</span>
<span class="lineNum">    6798 </span>            :                         max_ts_offset = ts_offset;
<span class="lineNum">    6799 </span>            :                         max_ts_scale = a_ds-&gt;timescale;
<span class="lineNum">    6800 </span>            :                 }
<span class="lineNum">    6801 </span>            :         }
<span class="lineNum">    6802 </span>            : 
<span class="lineNum">    6803 </span>            :         //assign ts offset and send stop/play
<span class="lineNum">    6804 </span><span class="lineCov">         14 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6805 </span><span class="lineCov">         14 :                 GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6806 </span>            : 
<span class="lineNum">    6807 </span><span class="lineCov">         14 :                 if (a_ds-&gt;subdur_done)</span>
<span class="lineNum">    6808 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    6809 </span>            : 
<span class="lineNum">    6810 </span>            :                 ts_offset = max_ts_offset;
<span class="lineNum">    6811 </span><span class="lineCov">         14 :                 ts_offset *= a_ds-&gt;timescale;</span>
<span class="lineNum">    6812 </span><span class="lineCov">         14 :                 ts_offset /= max_ts_scale;</span>
<span class="lineNum">    6813 </span>            : 
<span class="lineNum">    6814 </span><span class="lineCov">         14 :                 a_ds-&gt;ts_offset = ts_offset;</span>
<span class="lineNum">    6815 </span><span class="lineCov">         14 :                 if (a_ds-&gt;done) continue;</span>
<span class="lineNum">    6816 </span><span class="lineCov">         13 :                 if (a_ds-&gt;ts_offset &gt; a_ds-&gt;est_next_dts) {</span>
<span class="lineNum">    6817 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Looping streams of unequal duration, inserting &quot;LLU&quot; us of timestamp delay in pid %s from %s\n&quot;, ((a_ds-&gt;ts_offset - a_ds-&gt;est_next_dts) * 1000000) / a_ds-&gt;timescale, gf_filter_pid_get_name(a_ds-&gt;ipid), a_ds-&gt;src_url));</span>
<span class="lineNum">    6818 </span>            :                 }
<span class="lineNum">    6819 </span>            : 
<span class="lineNum">    6820 </span><span class="lineCov">         13 :                 a_ds-&gt;seek_to_pck = 0;</span>
<span class="lineNum">    6821 </span><span class="lineCov">         13 :                 a_ds-&gt;nb_pck = 0;</span>
<span class="lineNum">    6822 </span><span class="lineCov">         13 :                 a_ds-&gt;clamp_done = GF_FALSE;</span>
<span class="lineNum">    6823 </span>            : 
<span class="lineNum">    6824 </span><span class="lineCov">         13 :                 a_ds-&gt;loop_state = 2;</span>
<span class="lineNum">    6825 </span>            : 
<span class="lineNum">    6826 </span><span class="lineCov">         13 :                 if (ctx-&gt;subdur) {</span>
<span class="lineNum">    6827 </span>            :                         GF_FilterEvent evt;
<span class="lineNum">    6828 </span>            : 
<span class="lineNum">    6829 </span><span class="lineCov">         12 :                         GF_FEVT_INIT(evt, GF_FEVT_STOP, a_ds-&gt;ipid);</span>
<span class="lineNum">    6830 </span><span class="lineCov">         12 :                         gf_filter_pid_send_event(a_ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">    6831 </span>            : 
<span class="lineNum">    6832 </span><span class="lineCov">         12 :                         gf_filter_pid_set_discard(a_ds-&gt;ipid, GF_FALSE);</span>
<span class="lineNum">    6833 </span>            : 
<span class="lineNum">    6834 </span><span class="lineCov">         12 :                         dasher_send_encode_hints(ctx, ds);</span>
<span class="lineNum">    6835 </span>            : 
<span class="lineNum">    6836 </span><span class="lineCov">         12 :                         GF_FEVT_INIT(evt, GF_FEVT_PLAY, a_ds-&gt;ipid);</span>
<span class="lineNum">    6837 </span><span class="lineCov">         12 :                         evt.play.speed = 1.0;</span>
<span class="lineNum">    6838 </span><span class="lineCov">         12 :                         gf_filter_pid_send_event(a_ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">    6839 </span>            :                 }
<span class="lineNum">    6840 </span>            :         }
<span class="lineNum">    6841 </span>            : 
<span class="lineNum">    6842 </span>            :         return GF_TRUE;
<span class="lineNum">    6843 </span>            : }
<a name="6844"><span class="lineNum">    6844 </span>            : </a>
<span class="lineNum">    6845 </span>            : //depending on input formats, streams may be declared with or without DCD. For streams requiring the config, wait for it
<span class="lineNum">    6846 </span><span class="lineCov">        100 : static Bool dasher_check_period_ready(GF_DasherCtx *ctx, Bool is_session_end)</span>
<span class="lineNum">    6847 </span>            : {
<span class="lineNum">    6848 </span><span class="lineCov">        100 :         u32 i=0;</span>
<span class="lineNum">    6849 </span>            :         GF_DashStream *ds;
<span class="lineNum">    6850 </span><span class="lineCov">        100 :         ctx-&gt;period_not_ready = GF_FALSE;</span>
<span class="lineNum">    6851 </span><span class="lineCov">        286 :         while ((ds = gf_list_enum(ctx-&gt;current_period-&gt;streams, &amp;i))) {</span>
<span class="lineNum">    6852 </span>            : 
<span class="lineNum">    6853 </span><span class="lineCov">        181 :                 if (is_session_end)</span>
<span class="lineNum">    6854 </span><span class="lineNoCov">          0 :                         gf_filter_pid_set_discard(ds-&gt;ipid, GF_TRUE);</span>
<span class="lineNum">    6855 </span>            : 
<span class="lineNum">    6856 </span><span class="lineCov">        181 :                 if (ds-&gt;dcd_not_ready) {</span>
<span class="lineNum">    6857 </span>            :                         GF_FilterPacket *pck;
<span class="lineNum">    6858 </span>            :                         u32 prev = ds-&gt;dcd_not_ready;
<span class="lineNum">    6859 </span><span class="lineCov">        104 :                         ds-&gt;dcd_not_ready = 0;</span>
<span class="lineNum">    6860 </span><span class="lineCov">        104 :                         pck = gf_filter_pid_get_packet(ds-&gt;ipid);</span>
<span class="lineNum">    6861 </span><span class="lineCov">        104 :                         if (!pck) {</span>
<span class="lineNum">    6862 </span><span class="lineCov">         95 :                                 u32 diff = gf_sys_clock() - prev;</span>
<span class="lineNum">    6863 </span><span class="lineCov">         95 :                                 if (diff &gt; 10000) {</span>
<span class="lineNum">    6864 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Failed to initialize PID %s, no packets after %d ms, aborting\n&quot;, gf_filter_pid_get_name(ds-&gt;ipid), diff));</span>
<span class="lineNum">    6865 </span><span class="lineNoCov">          0 :                                         ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    6866 </span><span class="lineNoCov">          0 :                                         return GF_FALSE;</span>
<span class="lineNum">    6867 </span>            :                                 }
<span class="lineNum">    6868 </span><span class="lineCov">         95 :                                 ds-&gt;dcd_not_ready = prev;</span>
<span class="lineNum">    6869 </span><span class="lineCov">         95 :                                 ctx-&gt;period_not_ready = GF_TRUE;</span>
<span class="lineNum">    6870 </span><span class="lineCov">         95 :                                 return GF_FALSE;</span>
<span class="lineNum">    6871 </span>            :                         }
<span class="lineNum">    6872 </span>            :                 }
<span class="lineNum">    6873 </span>            :         }
<span class="lineNum">    6874 </span>            :         return GF_TRUE;
<a name="6875"><span class="lineNum">    6875 </span>            : }</a>
<span class="lineNum">    6876 </span>            : 
<span class="lineNum">    6877 </span><span class="lineCov">    5720281 : void dasher_format_report(GF_Filter *filter, GF_DasherCtx *ctx)</span>
<span class="lineNum">    6878 </span>            : {
<span class="lineNum">    6879 </span>            :         u32 i, count;
<span class="lineNum">    6880 </span>            :         Double max_ts=0;
<span class="lineNum">    6881 </span>            :         u32 total_pc = 0;
<span class="lineNum">    6882 </span>            :         char szDS[200];
<span class="lineNum">    6883 </span><span class="lineCov">    5720281 :         char *szStatus = NULL;</span>
<span class="lineNum">    6884 </span>            : 
<span class="lineNum">    6885 </span><span class="lineCov">    5720281 :         if (!gf_filter_reporting_enabled(filter))</span>
<span class="lineNum">    6886 </span><span class="lineCov">    5720281 :                 return;</span>
<span class="lineNum">    6887 </span><span class="lineNoCov">          0 :         if (!ctx-&gt;update_report)</span>
<span class="lineNum">    6888 </span>            :                 return;
<span class="lineNum">    6889 </span>            :         //don't update at each packet, this would be too much
<span class="lineNum">    6890 </span><span class="lineNoCov">          0 :         if ((ctx-&gt;update_report&gt;0) &amp;&amp; (ctx-&gt;update_report &lt; 20))</span>
<span class="lineNum">    6891 </span>            :                 return;
<span class="lineNum">    6892 </span>            : 
<span class="lineNum">    6893 </span><span class="lineNoCov">          0 :         ctx-&gt;update_report = 0;</span>
<span class="lineNum">    6894 </span>            : 
<span class="lineNum">    6895 </span><span class="lineNoCov">          0 :         sprintf(szDS, &quot;P%s&quot;, ctx-&gt;current_period-&gt;period-&gt;ID ? ctx-&gt;current_period-&gt;period-&gt;ID : &quot;1&quot;);</span>
<span class="lineNum">    6896 </span><span class="lineNoCov">          0 :         gf_dynstrcat(&amp;szStatus, szDS, NULL);</span>
<span class="lineNum">    6897 </span>            : 
<span class="lineNum">    6898 </span><span class="lineNoCov">          0 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    6899 </span><span class="lineNoCov">          0 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    6900 </span>            :                 s32 pc=-1;
<span class="lineNum">    6901 </span>            :                 Double mpdtime;
<span class="lineNum">    6902 </span>            :                 u32 set_idx;
<span class="lineNum">    6903 </span>            :                 u32 rep_idx;
<span class="lineNum">    6904 </span>            :                 u8 stype;
<span class="lineNum">    6905 </span><span class="lineNoCov">          0 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    6906 </span><span class="lineNoCov">          0 :                 if (ds-&gt;muxed_base) continue;</span>
<span class="lineNum">    6907 </span>            : 
<span class="lineNum">    6908 </span><span class="lineNoCov">          0 :                 set_idx = 1 + gf_list_find(ctx-&gt;current_period-&gt;period-&gt;adaptation_sets, ds-&gt;set);</span>
<span class="lineNum">    6909 </span><span class="lineNoCov">          0 :                 rep_idx = 1 + gf_list_find(ds-&gt;set-&gt;representations, ds-&gt;rep);</span>
<span class="lineNum">    6910 </span><span class="lineNoCov">          0 :                 if (ds-&gt;stream_type==GF_STREAM_VISUAL) stype='V';</span>
<span class="lineNum">    6911 </span><span class="lineNoCov">          0 :                 else if (ds-&gt;stream_type==GF_STREAM_AUDIO) stype='A';</span>
<span class="lineNum">    6912 </span><span class="lineNoCov">          0 :                 else if (ds-&gt;stream_type==GF_STREAM_TEXT) stype='T';</span>
<span class="lineNum">    6913 </span>            :                 else stype='M';
<span class="lineNum">    6914 </span>            : 
<span class="lineNum">    6915 </span><span class="lineNoCov">          0 :                 if (ds-&gt;done || ds-&gt;subdur_done) {</span>
<span class="lineNum">    6916 </span><span class="lineNoCov">          0 :                         sprintf(szDS, &quot;AS#%d.%d(%c) done (%d segs)&quot;, set_idx, rep_idx, stype, ds-&gt;seg_number);</span>
<span class="lineNum">    6917 </span><span class="lineNoCov">          0 :                         pc = 10000;</span>
<span class="lineNum">    6918 </span>            :                 } else {
<span class="lineNum">    6919 </span>            :                         Double done;
<span class="lineNum">    6920 </span><span class="lineNoCov">          0 :                         if (ctx-&gt;cues) {</span>
<span class="lineNum">    6921 </span><span class="lineNoCov">          0 :                                 done = (Double) (ds-&gt;last_dts);</span>
<span class="lineNum">    6922 </span><span class="lineNoCov">          0 :                                 done /= ds-&gt;timescale;</span>
<span class="lineNum">    6923 </span><span class="lineNoCov">          0 :                                 snprintf(szDS, 200, &quot;AS#%d.%d(%c) seg #%d %.2fs&quot;, set_idx, rep_idx, stype, ds-&gt;seg_number, done);</span>
<span class="lineNum">    6924 </span>            :                         } else {
<span class="lineNum">    6925 </span>            :                                 Double pcent, ddur;
<span class="lineNum">    6926 </span><span class="lineNoCov">          0 :                                 done = (Double) ds-&gt;adjusted_next_seg_start;</span>
<span class="lineNum">    6927 </span><span class="lineNoCov">          0 :                                 done -= (Double) ds-&gt;last_dts;</span>
<span class="lineNum">    6928 </span><span class="lineNoCov">          0 :                                 if (done&lt;0)</span>
<span class="lineNum">    6929 </span>            :                                         done=0;
<span class="lineNum">    6930 </span><span class="lineNoCov">          0 :                                 done /= ds-&gt;timescale;</span>
<span class="lineNum">    6931 </span><span class="lineNoCov">          0 :                                 ddur = ((Double)ds-&gt;dash_dur.num) / ds-&gt;dash_dur.den;</span>
<span class="lineNum">    6932 </span><span class="lineNoCov">          0 :                                 done = ddur - done;</span>
<span class="lineNum">    6933 </span>            :                                 //this may happen since we don't print info at segment start
<span class="lineNum">    6934 </span><span class="lineNoCov">          0 :                                 if (done&lt;0)</span>
<span class="lineNum">    6935 </span>            :                                         done=0;
<span class="lineNum">    6936 </span><span class="lineNoCov">          0 :                                 pcent = done / ddur;</span>
<span class="lineNum">    6937 </span><span class="lineNoCov">          0 :                                 pc = (s32) (done * 10000);</span>
<span class="lineNum">    6938 </span><span class="lineNoCov">          0 :                                 snprintf(szDS, 200, &quot;AS#%d.%d(%c) seg #%d %.2fs (%.2f %%)&quot;, set_idx, rep_idx, stype, ds-&gt;seg_number, done, 100*pcent);</span>
<span class="lineNum">    6939 </span>            :                         }
<span class="lineNum">    6940 </span>            : 
<span class="lineNum">    6941 </span><span class="lineNoCov">          0 :                         mpdtime = (Double) ds-&gt;last_dts;</span>
<span class="lineNum">    6942 </span><span class="lineNoCov">          0 :                         mpdtime -= (Double) ds-&gt;first_dts;</span>
<span class="lineNum">    6943 </span><span class="lineNoCov">          0 :                         if (mpdtime&lt;0) mpdtime=0;</span>
<span class="lineNum">    6944 </span><span class="lineNoCov">          0 :                         mpdtime /= ds-&gt;timescale;</span>
<span class="lineNum">    6945 </span>            : 
<span class="lineNum">    6946 </span><span class="lineNoCov">          0 :                         if (ds-&gt;duration.den &amp;&amp; ds-&gt;duration.num) {</span>
<span class="lineNum">    6947 </span>            :                                 done = mpdtime;
<span class="lineNum">    6948 </span>            : 
<span class="lineNum">    6949 </span><span class="lineNoCov">          0 :                                 done *= ds-&gt;duration.den;</span>
<span class="lineNum">    6950 </span><span class="lineNoCov">          0 :                                 done /= ds-&gt;duration.num;</span>
<span class="lineNum">    6951 </span><span class="lineNoCov">          0 :                                 pc = (u32) (10000*done);</span>
<span class="lineNum">    6952 </span>            :                         }
<span class="lineNum">    6953 </span><span class="lineNoCov">          0 :                         if (max_ts&lt;mpdtime)</span>
<span class="lineNum">    6954 </span>            :                                 max_ts = mpdtime;
<span class="lineNum">    6955 </span>            :                 }
<span class="lineNum">    6956 </span><span class="lineNoCov">          0 :                 if (pc &gt; (s32) total_pc) total_pc = (u32) pc;</span>
<span class="lineNum">    6957 </span><span class="lineNoCov">          0 :                 gf_dynstrcat(&amp;szStatus, szDS, &quot; &quot;);</span>
<span class="lineNum">    6958 </span>            :         }
<span class="lineNum">    6959 </span><span class="lineNoCov">          0 :         if (total_pc!=10000) {</span>
<span class="lineNum">    6960 </span><span class="lineNoCov">          0 :                 sprintf(szDS, &quot; / MPD %.2fs %d %%&quot;, max_ts, total_pc/100);</span>
<span class="lineNum">    6961 </span><span class="lineNoCov">          0 :                 gf_dynstrcat(&amp;szStatus, szDS, NULL);</span>
<span class="lineNum">    6962 </span>            :         }
<span class="lineNum">    6963 </span><span class="lineNoCov">          0 :         gf_filter_update_status(filter, total_pc, szStatus);</span>
<span class="lineNum">    6964 </span><span class="lineNoCov">          0 :         gf_free(szStatus);</span>
<a name="6965"><span class="lineNum">    6965 </span>            : }</a>
<span class="lineNum">    6966 </span>            : 
<span class="lineNum">    6967 </span><span class="lineCov">     123044 : static void dasher_drop_input(GF_DasherCtx *ctx, GF_DashStream *ds, Bool discard_all)</span>
<span class="lineNum">    6968 </span>            : {
<span class="lineNum">    6969 </span><span class="lineCov">     123044 :         if (ds-&gt;sbound) {</span>
<span class="lineNum">    6970 </span><span class="lineCov">       1152 :                 while (gf_list_count(ds-&gt;packet_queue)) {</span>
<span class="lineNum">    6971 </span><span class="lineCov">       1143 :                         GF_FilterPacket *pck = gf_list_pop_front(ds-&gt;packet_queue);</span>
<span class="lineNum">    6972 </span><span class="lineCov">       1143 :                         if (gf_filter_pck_get_sap(pck)) {</span>
<span class="lineNum">    6973 </span>            :                                 assert(ds-&gt;nb_sap_in_queue);
<span class="lineNum">    6974 </span><span class="lineCov">        699 :                                 ds-&gt;nb_sap_in_queue --;</span>
<span class="lineNum">    6975 </span>            :                         }
<span class="lineNum">    6976 </span><span class="lineCov">       1143 :                         gf_filter_pck_unref(pck);</span>
<span class="lineNum">    6977 </span><span class="lineCov">       1143 :                         if (!discard_all) break;</span>
<span class="lineNum">    6978 </span>            :                 }
<span class="lineNum">    6979 </span>            :         } else {
<span class="lineNum">    6980 </span><span class="lineCov">     121978 :                 gf_filter_pid_drop_packet(ds-&gt;ipid);</span>
<span class="lineNum">    6981 </span>            :         }
<span class="lineNum">    6982 </span><span class="lineCov">     123044 :         if (discard_all) {</span>
<span class="lineNum">    6983 </span><span class="lineCov">         82 :                 gf_filter_pid_set_discard(ds-&gt;ipid, GF_TRUE);</span>
<span class="lineNum">    6984 </span>            :         }
<span class="lineNum">    6985 </span><span class="lineCov">     123044 : }</span>
<span class="lineNum">    6986 </span>            : 
<a name="6987"><span class="lineNum">    6987 </span>            : </a>
<span class="lineNum">    6988 </span>            : 
<span class="lineNum">    6989 </span><span class="lineCov">    5730092 : static GF_Err dasher_process(GF_Filter *filter)</span>
<span class="lineNum">    6990 </span>            : {
<span class="lineNum">    6991 </span>            :         u32 i, count, nb_init, has_init, nb_reg_done;
<span class="lineNum">    6992 </span><span class="lineCov">    5730092 :         GF_DasherCtx *ctx = gf_filter_get_udta(filter);</span>
<span class="lineNum">    6993 </span>            :         GF_Err e;
<span class="lineNum">    6994 </span>            :         Bool seg_done = GF_FALSE;
<span class="lineNum">    6995 </span>            : 
<span class="lineNum">    6996 </span><span class="lineCov">    5730092 :         if (ctx-&gt;in_error) {</span>
<span class="lineNum">    6997 </span><span class="lineNoCov">          0 :                 gf_filter_abort(filter);</span>
<span class="lineNum">    6998 </span><span class="lineNoCov">          0 :                 return GF_SERVICE_ERROR;</span>
<span class="lineNum">    6999 </span>            :         }
<span class="lineNum">    7000 </span>            : 
<span class="lineNum">    7001 </span>            :         //session regulation is on and we have a an MPD (setup done) and a next time (first seg processed)
<span class="lineNum">    7002 </span>            :         //check if we have reached the next time
<span class="lineNum">    7003 </span><span class="lineCov">    5730092 :         if (ctx-&gt;sreg &amp;&amp; !ctx-&gt;state &amp;&amp; ctx-&gt;mpd &amp;&amp; ctx-&gt;mpd-&gt;gpac_next_ntp_ms) {</span>
<span class="lineNum">    7004 </span><span class="lineNoCov">          0 :                 s64 diff = (s64) ctx-&gt;mpd-&gt;gpac_next_ntp_ms;</span>
<span class="lineNum">    7005 </span><span class="lineNoCov">          0 :                 diff -= (s64) gf_net_get_ntp_ms();</span>
<span class="lineNum">    7006 </span><span class="lineNoCov">          0 :                 if (diff&gt;100) {</span>
<span class="lineNum">    7007 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (&quot;[Dasher] Next generation scheduled in %d ms, nothing to do\n&quot;, diff));</span>
<span class="lineNum">    7008 </span><span class="lineNoCov">          0 :                         gf_filter_ask_rt_reschedule(filter, (u32) (diff*1000));</span>
<span class="lineNum">    7009 </span><span class="lineNoCov">          0 :                         return GF_OK;</span>
<span class="lineNum">    7010 </span>            :                 }
<span class="lineNum">    7011 </span>            :         }
<span class="lineNum">    7012 </span>            : 
<span class="lineNum">    7013 </span>            :         //streams in period are not all ready, wait for them
<span class="lineNum">    7014 </span><span class="lineCov">    5730092 :         if (ctx-&gt;period_not_ready) {</span>
<span class="lineNum">    7015 </span><span class="lineCov">        100 :                 Bool is_eos = gf_filter_end_of_session(filter);</span>
<span class="lineNum">    7016 </span><span class="lineCov">        100 :                 if (! dasher_check_period_ready(ctx, is_eos)) {</span>
<span class="lineNum">    7017 </span><span class="lineCov">         95 :                         return is_eos ? GF_SERVICE_ERROR : GF_OK;</span>
<span class="lineNum">    7018 </span>            :                 }
<span class="lineNum">    7019 </span><span class="lineCov">          5 :                 e = dasher_setup_period(filter, ctx, NULL);</span>
<span class="lineNum">    7020 </span><span class="lineCov">          5 :                 if (e) return e;</span>
<span class="lineNum">    7021 </span>            :         }
<span class="lineNum">    7022 </span><span class="lineCov">    5729997 :         if (ctx-&gt;check_connections) {</span>
<span class="lineNum">    7023 </span><span class="lineCov">        925 :                 if (gf_filter_connections_pending(filter))</span>
<span class="lineNum">    7024 </span>            :                         return GF_OK;
<span class="lineNum">    7025 </span><span class="lineCov">        670 :                 ctx-&gt;check_connections = GF_FALSE;</span>
<span class="lineNum">    7026 </span>            :         }
<span class="lineNum">    7027 </span>            : 
<span class="lineNum">    7028 </span><span class="lineCov">    5729742 :         if (ctx-&gt;is_eos)</span>
<span class="lineNum">    7029 </span>            :                 return GF_EOS;
<span class="lineNum">    7030 </span><span class="lineCov">    5720283 :         if (ctx-&gt;setup_failure) return ctx-&gt;setup_failure;</span>
<span class="lineNum">    7031 </span>            : 
<span class="lineNum">    7032 </span>            :         nb_init = has_init = nb_reg_done = 0;
<span class="lineNum">    7033 </span>            : 
<span class="lineNum">    7034 </span><span class="lineCov">    5720283 :         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    7035 </span><span class="lineCov">   11538225 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    7036 </span>            :                 GF_DashStream *base_ds;
<span class="lineNum">    7037 </span><span class="lineCov">    5817944 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    7038 </span>            :                 assert(ds);
<span class="lineNum">    7039 </span><span class="lineCov">    5817944 :                 if (ds-&gt;done) continue;</span>
<span class="lineNum">    7040 </span><span class="lineCov">    5726729 :                 base_ds = ds-&gt;muxed_base ? ds-&gt;muxed_base : ds;</span>
<span class="lineNum">    7041 </span>            :                 //subdur mode abort, don't process
<span class="lineNum">    7042 </span><span class="lineCov">    5726729 :                 if (ds-&gt;subdur_done) {</span>
<span class="lineNum">    7043 </span><span class="lineCov">        250 :                         continue;</span>
<span class="lineNum">    7044 </span>            :                 }
<span class="lineNum">    7045 </span><span class="lineCov">    5726479 :                 if (ds-&gt;seg_done) continue;</span>
<span class="lineNum">    7046 </span>            : 
<span class="lineNum">    7047 </span><span class="lineCov">    5724793 :                 if (ctx-&gt;dmode == GF_MPD_TYPE_DYNAMIC_LAST) {</span>
<span class="lineNum">    7048 </span><span class="lineNoCov">          0 :                         ds-&gt;done = 1;</span>
<span class="lineNum">    7049 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    7050 </span>            :                 }
<span class="lineNum">    7051 </span>            : 
<span class="lineNum">    7052 </span>            :                 //flush as much as possible
<span class="lineNum">    7053 </span>            :                 while (1) {
<span class="lineNum">    7054 </span>            :                         u32 sap_type, dur, o_dur, split_dur;
<span class="lineNum">    7055 </span>            :                         s32 check_dur;
<span class="lineNum">    7056 </span>            :                         u64 cts, orig_cts, dts, split_dur_next, pcont_cts;
<span class="lineNum">    7057 </span>            :                         Bool seg_over = GF_FALSE;
<span class="lineNum">    7058 </span>            :                         Bool is_packet_split = GF_FALSE;
<span class="lineNum">    7059 </span>            :                         Bool is_queue_flush = GF_FALSE;
<span class="lineNum">    7060 </span>            :                         GF_FilterPacket *dst;
<span class="lineNum">    7061 </span><span class="lineCov">    5851433 :                         GF_FilterPacket *pck = NULL;</span>
<span class="lineNum">    7062 </span>            : 
<span class="lineNum">    7063 </span><span class="lineCov">    5851433 :                         if (!ds-&gt;request_period_switch) {</span>
<span class="lineNum">    7064 </span>            :                                 assert(ds-&gt;period == ctx-&gt;current_period);
<span class="lineNum">    7065 </span><span class="lineCov">    5851433 :                                 pck = gf_filter_pid_get_packet(ds-&gt;ipid);</span>
<span class="lineNum">    7066 </span>            :                                 //we may change period after a packet fetch (reconfigure of input pid)
<span class="lineNum">    7067 </span><span class="lineCov">    5851433 :                                 if ((ds-&gt;period != ctx-&gt;current_period) || ds-&gt;request_period_switch) {</span>
<span class="lineNum">    7068 </span>            :                                         //in closest mode, flush queue
<span class="lineNum">    7069 </span><span class="lineNoCov">          0 :                                         if (!ds-&gt;sbound || !gf_list_count(ds-&gt;packet_queue)) {</span>
<span class="lineNum">    7070 </span>            :                                                 assert(gf_list_find(ctx-&gt;current_period-&gt;streams, ds)&lt;0);
<span class="lineNum">    7071 </span><span class="lineNoCov">          0 :                                                 count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    7072 </span><span class="lineNoCov">          0 :                                                 i--;</span>
<span class="lineNum">    7073 </span><span class="lineCov">    5724791 :                                                 break;</span>
<span class="lineNum">    7074 </span>            :                                         }
<span class="lineNum">    7075 </span>            :                                         is_queue_flush = GF_TRUE;
<span class="lineNum">    7076 </span>            :                                 }
<span class="lineNum">    7077 </span>            :                         } else {
<span class="lineNum">    7078 </span>            :                                 is_queue_flush = GF_TRUE;
<span class="lineNum">    7079 </span>            :                         }
<span class="lineNum">    7080 </span><span class="lineCov">    5851433 :                         if (ds-&gt;sbound &amp;&amp; pck &amp;&amp; gf_filter_pck_is_blocking_ref(pck)) {</span>
<span class="lineNum">    7081 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Cannot use `sbound` with blocking input packet references, disabling packet buffering for PID %s\n&quot;, gf_filter_pid_get_name(ds-&gt;ipid) ));</span>
<span class="lineNum">    7082 </span><span class="lineNoCov">          0 :                                 ds-&gt;sbound = DASHER_BOUNDS_OUT;</span>
<span class="lineNum">    7083 </span>            :                         }
<span class="lineNum">    7084 </span>            : 
<span class="lineNum">    7085 </span>            :                         //skipped merged tile base
<span class="lineNum">    7086 </span><span class="lineCov">    5851433 :                         if (ds-&gt;merged_tile_dep) {</span>
<span class="lineNum">    7087 </span><span class="lineCov">        780 :                                 if (pck) gf_filter_pid_drop_packet(ds-&gt;ipid);</span>
<span class="lineNum">    7088 </span><span class="lineCov">        780 :                                 pck = NULL;</span>
<span class="lineNum">    7089 </span>            :                         }
<span class="lineNum">    7090 </span>            :                         //queue mode
<span class="lineNum">    7091 </span><span class="lineCov">    5850653 :                         else if (ds-&gt;sbound) {</span>
<span class="lineNum">    7092 </span><span class="lineCov">       2224 :                                 if (!is_queue_flush &amp;&amp; pck) {</span>
<span class="lineNum">    7093 </span><span class="lineCov">       1143 :                                         gf_filter_pck_ref(&amp;pck);</span>
<span class="lineNum">    7094 </span><span class="lineCov">       1143 :                                         gf_filter_pid_drop_packet(ds-&gt;ipid);</span>
<span class="lineNum">    7095 </span><span class="lineCov">       1143 :                                         gf_list_add(ds-&gt;packet_queue, pck);</span>
<span class="lineNum">    7096 </span><span class="lineCov">       1143 :                                         if (gf_filter_pck_get_sap(pck))</span>
<span class="lineNum">    7097 </span><span class="lineCov">        699 :                                                 ds-&gt;nb_sap_in_queue ++;</span>
<span class="lineNum">    7098 </span>            :                                 }
<span class="lineNum">    7099 </span><span class="lineCov">       2224 :                                 if (</span>
<span class="lineNum">    7100 </span>            :                                         //we are flushing due to period switch
<span class="lineNum">    7101 </span>            :                                         is_queue_flush
<span class="lineNum">    7102 </span>            :                                         //we are flushing due to end of stream
<span class="lineNum">    7103 </span><span class="lineCov">       2224 :                                         || gf_filter_pid_is_eos(ds-&gt;ipid) || ds-&gt;clamp_done</span>
<span class="lineNum">    7104 </span>            :                                 ) {
<span class="lineNum">    7105 </span><span class="lineCov">        246 :                                         pck = gf_list_get(ds-&gt;packet_queue, 0);</span>
<span class="lineNum">    7106 </span><span class="lineCov">        246 :                                         is_queue_flush = GF_TRUE;</span>
<span class="lineNum">    7107 </span><span class="lineCov">       1978 :                                 } else if (</span>
<span class="lineNum">    7108 </span>            :                                         //if current segment is not started, always get packet from queue
<span class="lineNum">    7109 </span><span class="lineCov">       1978 :                                         !ds-&gt;segment_started</span>
<span class="lineNum">    7110 </span>            :                                         //wait until we have more than 2 saps to get packet from queue, to check if next sap will be closer or not
<span class="lineNum">    7111 </span><span class="lineCov">       1962 :                                         || (ds-&gt;nb_sap_in_queue&gt;=2)</span>
<span class="lineNum">    7112 </span>            :                                 ) {
<span class="lineNum">    7113 </span><span class="lineCov">        838 :                                         pck = gf_list_get(ds-&gt;packet_queue, 0);</span>
<span class="lineNum">    7114 </span>            :                                 } else {
<span class="lineNum">    7115 </span><span class="lineCov">       1140 :                                         pck = NULL;</span>
<span class="lineNum">    7116 </span>            :                                 }
<span class="lineNum">    7117 </span>            :                         }
<span class="lineNum">    7118 </span>            : 
<span class="lineNum">    7119 </span>            : 
<span class="lineNum">    7120 </span><span class="lineCov">    5851433 :                         if (!pck) {</span>
<span class="lineNum">    7121 </span><span class="lineCov">    5717672 :                                 if (ds-&gt;request_period_switch) {</span>
<span class="lineNum">    7122 </span><span class="lineNoCov">          0 :                                         e = dasher_stream_period_changed(filter, ctx, ds, (ds-&gt;request_period_switch==2) ? GF_TRUE : GF_FALSE);</span>
<span class="lineNum">    7123 </span><span class="lineNoCov">          0 :                                         if (e &lt; 0) {</span>
<span class="lineNum">    7124 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Period switch request failed.\n&quot;));</span>
<span class="lineNum">    7125 </span><span class="lineNoCov">          0 :                                                 i--;</span>
<span class="lineNum">    7126 </span><span class="lineNoCov">          0 :                                                 break;</span>
<span class="lineNum">    7127 </span>            :                                         }
<span class="lineNum">    7128 </span>            :                                         assert(gf_list_find(ctx-&gt;current_period-&gt;streams, ds)&lt;0);
<span class="lineNum">    7129 </span><span class="lineNoCov">          0 :                                         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    7130 </span><span class="lineNoCov">          0 :                                         i--;</span>
<span class="lineNum">    7131 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    7132 </span>            :                                 }
<span class="lineNum">    7133 </span>            : 
<span class="lineNum">    7134 </span>            : 
<span class="lineNum">    7135 </span><span class="lineCov">    5717672 :                                 if (gf_filter_pid_is_eos(ds-&gt;ipid) || ds-&gt;clamp_done) {</span>
<span class="lineNum">    7136 </span>            :                                         u32 ds_done = 1;
<span class="lineNum">    7137 </span><span class="lineCov">        480 :                                         if (ctx-&gt;loop &amp;&amp; dasher_check_loop(ctx, ds)) {</span>
<span class="lineNum">    7138 </span><span class="lineCov">        140 :                                                 if (ctx-&gt;subdur)</span>
<span class="lineNum">    7139 </span>            :                                                         break;
<span class="lineNum">    7140 </span>            :                                                 //loop on the entire source, consider the stream not done for segment flush
<span class="lineNum">    7141 </span>            :                                                 ds_done = 0;
<span class="lineNum">    7142 </span>            :                                         }
<span class="lineNum">    7143 </span>            : 
<span class="lineNum">    7144 </span><span class="lineCov">        342 :                                         ds-&gt;clamp_done = GF_FALSE;</span>
<span class="lineNum">    7145 </span>            : 
<span class="lineNum">    7146 </span><span class="lineCov">        342 :                                         ctx-&gt;update_report = -1;</span>
<span class="lineNum">    7147 </span>            :                                         //opid may be NULL for skipped tile rep
<span class="lineNum">    7148 </span><span class="lineCov">        342 :                                         if (!ctx-&gt;sigfrag &amp;&amp; ds-&gt;opid)</span>
<span class="lineNum">    7149 </span><span class="lineCov">        335 :                                                 gf_filter_pid_set_eos(ds-&gt;opid);</span>
<span class="lineNum">    7150 </span>            : 
<span class="lineNum">    7151 </span><span class="lineCov">        342 :                                         if (!ds-&gt;done) ds-&gt;done = ds_done;</span>
<span class="lineNum">    7152 </span><span class="lineCov">        342 :                                         ds-&gt;seg_done = GF_TRUE;</span>
<span class="lineNum">    7153 </span>            :                                         seg_done = GF_TRUE;
<span class="lineNum">    7154 </span><span class="lineCov">        342 :                                         ds-&gt;first_cts_in_next_seg = ds-&gt;est_first_cts_in_next_seg;</span>
<span class="lineNum">    7155 </span><span class="lineCov">        342 :                                         ds-&gt;est_first_cts_in_next_seg = 0;</span>
<span class="lineNum">    7156 </span>            :                                         assert(base_ds-&gt;nb_comp_done &lt; base_ds-&gt;nb_comp);
<span class="lineNum">    7157 </span><span class="lineCov">        342 :                                         base_ds-&gt;nb_comp_done ++;</span>
<span class="lineNum">    7158 </span><span class="lineCov">        342 :                                         if (base_ds-&gt;nb_comp_done == base_ds-&gt;nb_comp) {</span>
<span class="lineNum">    7159 </span><span class="lineCov">        333 :                                                 dasher_flush_segment(ctx, base_ds, GF_FALSE);</span>
<span class="lineNum">    7160 </span><span class="lineCov">        333 :                                                 base_ds-&gt;nb_comp_done = 0;</span>
<span class="lineNum">    7161 </span>            :                                         }
<span class="lineNum">    7162 </span>            :                                         //loop on the entire source, mark as done for subdur and check if all other streams are done
<span class="lineNum">    7163 </span><span class="lineCov">        342 :                                         if (!ds-&gt;done) {</span>
<span class="lineNum">    7164 </span>            :                                                 u32 j;
<span class="lineNum">    7165 </span><span class="lineCov">          2 :                                                 ds-&gt;done = 2;</span>
<span class="lineNum">    7166 </span><span class="lineCov">          2 :                                                 ds-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    7167 </span>            :                                                 u32 nb_sub_done=0;
<span class="lineNum">    7168 </span><span class="lineCov">          6 :                                                 for (j=0; j&lt;count; j++) {</span>
<span class="lineNum">    7169 </span><span class="lineCov">          4 :                                                         GF_DashStream *a_ds = gf_list_get(ctx-&gt;current_period-&gt;streams, j);</span>
<span class="lineNum">    7170 </span><span class="lineCov">          4 :                                                         if (a_ds-&gt;muxed_base) a_ds = a_ds-&gt;muxed_base;</span>
<span class="lineNum">    7171 </span><span class="lineCov">          4 :                                                         if (a_ds-&gt;subdur_done) {</span>
<span class="lineNum">    7172 </span><span class="lineCov">          2 :                                                                 nb_sub_done++;</span>
<span class="lineNum">    7173 </span>            :                                                         }
<span class="lineNum">    7174 </span>            :                                                 }
<span class="lineNum">    7175 </span><span class="lineCov">          2 :                                                 if (nb_sub_done==count)</span>
<span class="lineNum">    7176 </span><span class="lineNoCov">          0 :                                                         ctx-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    7177 </span><span class="lineCov">        340 :                                         } else if (ctx-&gt;reschedule &amp;&amp; !ctx-&gt;loop &amp;&amp; (ctx-&gt;dmode==GF_MPD_TYPE_DYNAMIC) &amp;&amp; !strcmp(ds-&gt;period_id, DEFAULT_PERIOD_ID) ) {</span>
<span class="lineNum">    7178 </span><span class="lineCov">          8 :                                                 if (gf_list_find(ctx-&gt;next_period-&gt;streams, ds)&lt;0) {</span>
<span class="lineNum">    7179 </span><span class="lineCov">          4 :                                                         gf_list_add(ctx-&gt;next_period-&gt;streams, ds);</span>
<span class="lineNum">    7180 </span>            :                                                 }
<span class="lineNum">    7181 </span><span class="lineCov">          8 :                                                 ctx-&gt;post_play_events = GF_TRUE;</span>
<span class="lineNum">    7182 </span><span class="lineCov">          8 :                                                 ds-&gt;nb_repeat++;</span>
<span class="lineNum">    7183 </span><span class="lineCov">          8 :                                                 ds-&gt;reschedule = GF_TRUE;</span>
<span class="lineNum">    7184 </span><span class="lineCov">          8 :                                                 gf_filter_pid_discard_block(ds-&gt;opid);</span>
<span class="lineNum">    7185 </span>            :                                         }
<span class="lineNum">    7186 </span>            :                                 }
<span class="lineNum">    7187 </span>            :                                 break;
<span class="lineNum">    7188 </span>            :                         }
<span class="lineNum">    7189 </span><span class="lineCov">     133761 :                         if (ds-&gt;seek_to_pck) {</span>
<span class="lineNum">    7190 </span><span class="lineCov">        200 :                                 u32 sn = gf_filter_pck_get_seq_num(pck);</span>
<span class="lineNum">    7191 </span><span class="lineCov">        200 :                                 if (sn) {</span>
<span class="lineNum">    7192 </span><span class="lineCov">        200 :                                         if (sn &lt;= ds-&gt;seek_to_pck) {</span>
<span class="lineNum">    7193 </span><span class="lineCov">        186 :                                                 dasher_drop_input(ctx, ds, GF_FALSE);</span>
<span class="lineNum">    7194 </span><span class="lineCov">       4024 :                                                 continue;</span>
<span class="lineNum">    7195 </span>            :                                         }
<span class="lineNum">    7196 </span><span class="lineCov">         14 :                                         ds-&gt;nb_pck = sn-1;</span>
<span class="lineNum">    7197 </span>            :                                 } else {
<span class="lineNum">    7198 </span>            :                                         //no sn signaled, this implies we played from the beginning
<span class="lineNum">    7199 </span><span class="lineNoCov">          0 :                                         if (ds-&gt;nb_pck &lt; ds-&gt;seek_to_pck) {</span>
<span class="lineNum">    7200 </span><span class="lineNoCov">          0 :                                                 ds-&gt;nb_pck ++;</span>
<span class="lineNum">    7201 </span><span class="lineNoCov">          0 :                                                 dasher_drop_input(ctx, ds, GF_FALSE);</span>
<span class="lineNum">    7202 </span><span class="lineNoCov">          0 :                                                 continue;</span>
<span class="lineNum">    7203 </span>            :                                         }
<span class="lineNum">    7204 </span>            :                                 }
<span class="lineNum">    7205 </span>            :                         }
<span class="lineNum">    7206 </span><span class="lineCov">     133575 :                         sap_type = gf_filter_pck_get_sap(pck);</span>
<span class="lineNum">    7207 </span><span class="lineCov">     133575 :                         ds-&gt;loop_state = 0;</span>
<span class="lineNum">    7208 </span>            : 
<span class="lineNum">    7209 </span><span class="lineCov">     133575 :                         cts = gf_filter_pck_get_cts(pck);</span>
<span class="lineNum">    7210 </span><span class="lineCov">     133575 :                         dts = gf_filter_pck_get_dts(pck);</span>
<span class="lineNum">    7211 </span><span class="lineCov">     133575 :                         if (dts==GF_FILTER_NO_TS) dts = cts;</span>
<span class="lineNum">    7212 </span>            : 
<span class="lineNum">    7213 </span>            :                         pcont_cts = cts;
<span class="lineNum">    7214 </span>            : 
<span class="lineNum">    7215 </span><span class="lineCov">     133575 :                         if (!ds-&gt;rep_init) {</span>
<span class="lineNum">    7216 </span>            :                                 u32 set_start_with_sap;
<span class="lineNum">    7217 </span><span class="lineCov">        357 :                                 if (!sap_type) {</span>
<span class="lineNum">    7218 </span><span class="lineNoCov">          0 :                                         dasher_drop_input(ctx, ds, GF_FALSE);</span>
<span class="lineNum">    7219 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    7220 </span>            :                                 }
<span class="lineNum">    7221 </span>            : 
<span class="lineNum">    7222 </span><span class="lineCov">        357 :                                 set_start_with_sap = ctx-&gt;sseg ? base_ds-&gt;set-&gt;subsegment_starts_with_sap : base_ds-&gt;set-&gt;starts_with_sap;</span>
<span class="lineNum">    7223 </span><span class="lineCov">        357 :                                 if (!ds-&gt;muxed_base) {</span>
<span class="lineNum">    7224 </span>            :                                         //force sap type to 1 for non-visual streams if strict_sap is set to off
<span class="lineNum">    7225 </span><span class="lineCov">        425 :                                         if ((ds-&gt;stream_type!=GF_STREAM_VISUAL) &amp;&amp; (ctx-&gt;strict_sap==DASHER_SAP_OFF) ) {</span>
<span class="lineNum">    7226 </span><span class="lineCov">         79 :                                                 switch (ds-&gt;codec_id) {</span>
<span class="lineNum">    7227 </span>            :                                                 //MPEG-H requires saps
<span class="lineNum">    7228 </span>            :                                                 case GF_CODECID_MPHA:
<span class="lineNum">    7229 </span>            :                                                 case GF_CODECID_MHAS:
<span class="lineNum">    7230 </span>            :                                                         break;
<span class="lineNum">    7231 </span><span class="lineCov">         79 :                                                 default:</span>
<span class="lineNum">    7232 </span>            :                                                         sap_type = 1;
<span class="lineNum">    7233 </span><span class="lineCov">         79 :                                                         break;</span>
<span class="lineNum">    7234 </span>            :                                                 }
<span class="lineNum">    7235 </span><span class="lineCov">        267 :                                         }</span>
<span class="lineNum">    7236 </span>            :                                         //set AS sap type
<span class="lineNum">    7237 </span><span class="lineCov">        346 :                                         if (!set_start_with_sap) {</span>
<span class="lineNum">    7238 </span>            :                                                 //don't set SAP type if not a base rep - could be further checked
<span class="lineNum">    7239 </span>            :                                                 //if (!gf_list_count(ds-&gt;complementary_streams) )
<span class="lineNum">    7240 </span>            :                                                 {
<span class="lineNum">    7241 </span><span class="lineCov">        317 :                                                         if (ctx-&gt;sseg) {</span>
<span class="lineNum">    7242 </span><span class="lineCov">         21 :                                                                 ds-&gt;set-&gt;subsegment_starts_with_sap = sap_type;</span>
<span class="lineNum">    7243 </span>            :                                                         } else {
<span class="lineNum">    7244 </span><span class="lineCov">        296 :                                                                 ds-&gt;set-&gt;starts_with_sap = sap_type;</span>
<span class="lineNum">    7245 </span>            :                                                         }
<span class="lineNum">    7246 </span>            :                                                 }
<span class="lineNum">    7247 </span>            :                                         }
<span class="lineNum">    7248 </span><span class="lineCov">         29 :                                         else if (set_start_with_sap != sap_type) {</span>
<span class="lineNum">    7249 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Segments do not start with the same SAP types: set initialized with %d but first packet got %d - bitstream will not be compliant\n&quot;, set_start_with_sap, sap_type));</span>
<span class="lineNum">    7250 </span>            :                                         }
<span class="lineNum">    7251 </span>            :                                         //TODO setup proper PTO, the code below will break sync by realigning first AU of each stream
<span class="lineNum">    7252 </span><span class="lineCov">        346 :                                         if ((s64) cts + ds-&gt;pts_minus_cts &gt; 0) {</span>
<span class="lineNum">    7253 </span><span class="lineCov">          3 :                                                 u64 pto = cts + ds-&gt;pts_minus_cts;</span>
<span class="lineNum">    7254 </span><span class="lineCov">          3 :                                                 if (ds-&gt;rep-&gt;segment_list)</span>
<span class="lineNum">    7255 </span><span class="lineCov">          2 :                                                         ds-&gt;rep-&gt;segment_list-&gt;presentation_time_offset = pto;</span>
<span class="lineNum">    7256 </span><span class="lineCov">          1 :                                                 else if (ds-&gt;rep-&gt;segment_template)</span>
<span class="lineNum">    7257 </span><span class="lineNoCov">          0 :                                                         ds-&gt;rep-&gt;segment_template-&gt;presentation_time_offset = pto;</span>
<span class="lineNum">    7258 </span><span class="lineCov">          1 :                                                 else if (ds-&gt;set-&gt;segment_template)</span>
<span class="lineNum">    7259 </span><span class="lineCov">          1 :                                                         ds-&gt;set-&gt;segment_template-&gt;presentation_time_offset = pto;</span>
<span class="lineNum">    7260 </span><span class="lineNoCov">          0 :                                                 else if (ds-&gt;rep-&gt;segment_base)</span>
<span class="lineNum">    7261 </span><span class="lineNoCov">          0 :                                                         ds-&gt;rep-&gt;segment_base-&gt;presentation_time_offset = pto;</span>
<span class="lineNum">    7262 </span>            :                                         }
<span class="lineNum">    7263 </span>            :                                         //period continuity, skip priming in new periods
<span class="lineNum">    7264 </span><span class="lineCov">        346 :                                         if (ds-&gt;period_continuity_id)</span>
<span class="lineNum">    7265 </span><span class="lineNoCov">          0 :                                                 ds-&gt;pts_minus_cts = 0;</span>
<span class="lineNum">    7266 </span>            :                                 }
<span class="lineNum">    7267 </span>            : 
<span class="lineNum">    7268 </span><span class="lineCov">        357 :                                 ds-&gt;first_cts = cts;</span>
<span class="lineNum">    7269 </span><span class="lineCov">        357 :                                 ds-&gt;first_dts = dts;</span>
<span class="lineNum">    7270 </span><span class="lineCov">        357 :                                 ds-&gt;rep_init++;</span>
<span class="lineNum">    7271 </span><span class="lineCov">        357 :                                 has_init++;</span>
<span class="lineNum">    7272 </span>            :                         }
<span class="lineNum">    7273 </span>            : 
<span class="lineNum">    7274 </span><span class="lineCov">     133575 :                         nb_init++;</span>
<span class="lineNum">    7275 </span>            : 
<span class="lineNum">    7276 </span><span class="lineCov">     133575 :                         if (ds-&gt;ts_offset) {</span>
<span class="lineNum">    7277 </span><span class="lineCov">        579 :                                 cts += ds-&gt;ts_offset;</span>
<span class="lineNum">    7278 </span><span class="lineCov">        579 :                                 dts += ds-&gt;ts_offset;</span>
<span class="lineNum">    7279 </span>            :                         }
<span class="lineNum">    7280 </span>            : 
<span class="lineNum">    7281 </span>            :                         //ready to write MPD for the first time in dynamic mode with template
<span class="lineNum">    7282 </span><span class="lineCov">     133575 :                         if (has_init &amp;&amp; (nb_init==count) &amp;&amp; (ctx-&gt;dmode==GF_MPD_TYPE_DYNAMIC) &amp;&amp; ctx-&gt;tpl &amp;&amp; ctx-&gt;do_mpd &amp;&amp; !ctx-&gt;dyn_rate) {</span>
<span class="lineNum">    7283 </span><span class="lineCov">         13 :                                 e = dasher_send_manifest(filter, ctx, GF_TRUE);</span>
<span class="lineNum">    7284 </span><span class="lineCov">         15 :                                 if (e) return e;</span>
<span class="lineNum">    7285 </span>            :                         }
<span class="lineNum">    7286 </span>            : 
<span class="lineNum">    7287 </span>            :                         cts = dasher_translate_cts(ds, cts);
<span class="lineNum">    7288 </span><span class="lineCov">     133575 :                         dts -= ds-&gt;first_dts;</span>
<span class="lineNum">    7289 </span>            : 
<span class="lineNum">    7290 </span><span class="lineCov">     133575 :                         if (ctx-&gt;sreg &amp;&amp; ctx-&gt;mpd-&gt;gpac_mpd_time &amp;&amp; (dts * 1000 &gt; ctx-&gt;mpd-&gt;gpac_mpd_time * ds-&gt;timescale)) {</span>
<span class="lineNum">    7291 </span><span class="lineNoCov">          0 :                                 nb_reg_done++;</span>
<span class="lineNum">    7292 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    7293 </span>            :                         }
<span class="lineNum">    7294 </span>            : 
<span class="lineNum">    7295 </span><span class="lineCov">     133575 :                         dur = o_dur = gf_filter_pck_get_duration(pck);</span>
<span class="lineNum">    7296 </span><span class="lineCov">     133575 :                         pcont_cts += dur;</span>
<span class="lineNum">    7297 </span><span class="lineCov">     133575 :                         if (ds-&gt;period_continuity_next_cts &lt; pcont_cts)</span>
<span class="lineNum">    7298 </span><span class="lineCov">     116120 :                                 ds-&gt;period_continuity_next_cts = pcont_cts;</span>
<span class="lineNum">    7299 </span>            : 
<span class="lineNum">    7300 </span>            :                         split_dur = 0;
<span class="lineNum">    7301 </span>            :                         split_dur_next = 0;
<span class="lineNum">    7302 </span>            : 
<span class="lineNum">    7303 </span>            :                         //patch to align old arch with new
<span class="lineNum">    7304 </span>            :                         check_dur = 0;
<span class="lineNum">    7305 </span><span class="lineCov">     133575 :                         if (ds-&gt;stream_type==GF_STREAM_AUDIO)</span>
<span class="lineNum">    7306 </span><span class="lineCov">      42376 :                                 check_dur = dur;</span>
<span class="lineNum">    7307 </span>            : 
<span class="lineNum">    7308 </span>            :                         //adjust duration and cts
<span class="lineNum">    7309 </span>            :                         orig_cts = cts;
<span class="lineNum">    7310 </span><span class="lineCov">     133575 :                         if (ds-&gt;split_dur_next) {</span>
<span class="lineNum">    7311 </span><span class="lineCov">         52 :                                 cts += ds-&gt;split_dur_next;</span>
<span class="lineNum">    7312 </span>            :                                 assert(dur &gt; ds-&gt;split_dur_next);
<span class="lineNum">    7313 </span><span class="lineCov">         52 :                                 dur -= ds-&gt;split_dur_next;</span>
<span class="lineNum">    7314 </span>            :                                 split_dur_next = ds-&gt;split_dur_next;
<span class="lineNum">    7315 </span><span class="lineCov">         52 :                                 ds-&gt;split_dur_next = 0;</span>
<span class="lineNum">    7316 </span>            :                                 is_packet_split = GF_TRUE;
<span class="lineNum">    7317 </span>            :                         }
<span class="lineNum">    7318 </span>            : 
<span class="lineNum">    7319 </span><span class="lineCov">     133575 :                         if (ds-&gt;splitable &amp;&amp; !ds-&gt;split_dur_next &amp;&amp; !ds-&gt;cues &amp;&amp; !ds-&gt;inband_cues) {</span>
<span class="lineNum">    7320 </span>            :                                 Bool do_split = GF_FALSE;
<span class="lineNum">    7321 </span>            :                                 //adding this sample would exceed the segment duration
<span class="lineNum">    7322 </span><span class="lineCov">         74 :                                 if (gf_sys_old_arch_compat()) {</span>
<span class="lineNum">    7323 </span><span class="lineCov">         74 :                                         if ( (cts + dur) * base_ds-&gt;timescale &gt;= base_ds-&gt;adjusted_next_seg_start * ds-&gt;timescale )</span>
<span class="lineNum">    7324 </span>            :                                                 do_split = GF_TRUE;
<span class="lineNum">    7325 </span>            :                                 } else {
<span class="lineNum">    7326 </span><span class="lineNoCov">          0 :                                         if ( (cts + dur) * base_ds-&gt;timescale &gt; base_ds-&gt;adjusted_next_seg_start * ds-&gt;timescale )</span>
<span class="lineNum">    7327 </span>            :                                                 do_split = GF_TRUE;
<span class="lineNum">    7328 </span>            :                                 }
<span class="lineNum">    7329 </span>            :                                 if (do_split) {
<span class="lineNum">    7330 </span>            :                                         //this sample starts in the current segment - split it
<span class="lineNum">    7331 </span><span class="lineCov">         52 :                                         if (cts * base_ds-&gt;timescale &lt; base_ds-&gt;adjusted_next_seg_start * ds-&gt;timescale ) {</span>
<span class="lineNum">    7332 </span><span class="lineCov">         26 :                                                 split_dur = (u32) (base_ds-&gt;adjusted_next_seg_start * ds-&gt;timescale / base_ds-&gt;timescale - ds-&gt;last_cts);</span>
<span class="lineNum">    7333 </span>            : 
<span class="lineNum">    7334 </span><span class="lineCov">         26 :                                                 if (gf_sys_old_arch_compat() &amp;&amp; (split_dur==dur))</span>
<span class="lineNum">    7335 </span>            :                                                         split_dur=0;
<span class="lineNum">    7336 </span>            : 
<span class="lineNum">    7337 </span><span class="lineCov">         26 :                                                 if (split_dur&gt;=dur)</span>
<span class="lineNum">    7338 </span>            :                                                         split_dur=0;
<span class="lineNum">    7339 </span>            :                                         }
<span class="lineNum">    7340 </span>            :                                 }
<span class="lineNum">    7341 </span>            :                         }
<span class="lineNum">    7342 </span>            : 
<span class="lineNum">    7343 </span>            :                         //mux rep, wait for a CTS more than our base if base not yet over
<span class="lineNum">    7344 </span><span class="lineCov">     133575 :                         if ((base_ds != ds) &amp;&amp; !base_ds-&gt;seg_done &amp;&amp; (cts * base_ds-&gt;timescale &gt; base_ds-&gt;last_cts * ds-&gt;timescale ) )</span>
<span class="lineNum">    7345 </span>            :                                 break;
<span class="lineNum">    7346 </span>            : 
<span class="lineNum">    7347 </span><span class="lineCov">     129605 :                         if (ds-&gt;seek_to_pck) {</span>
<span class="lineNum">    7348 </span><span class="lineCov">         14 :                                 ds-&gt;seek_to_pck = 0;</span>
<span class="lineNum">    7349 </span>            :                         }
<span class="lineNum">    7350 </span>            :                         //force flush mode, segment is done upon eos
<span class="lineNum">    7351 </span><span class="lineCov">     129591 :                         else if (ctx-&gt;force_flush) {</span>
<span class="lineNum">    7352 </span>            :                         }
<span class="lineNum">    7353 </span>            :                         //source-driven fragmentation check for segment start
<span class="lineNum">    7354 </span><span class="lineCov">     129591 :                         else if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    7355 </span><span class="lineCov">       3666 :                                 const GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);</span>
<span class="lineNum">    7356 </span><span class="lineCov">       3666 :                                 if (p &amp;&amp; (p-&gt;value.uint&gt;=1) &amp;&amp; base_ds-&gt;segment_started) {</span>
<span class="lineNum">    7357 </span>            :                                         seg_over = GF_TRUE;
<span class="lineNum">    7358 </span><span class="lineCov">         66 :                                         if (ds == base_ds) {</span>
<span class="lineNum">    7359 </span><span class="lineCov">         66 :                                                 base_ds-&gt;adjusted_next_seg_start = cts;</span>
<span class="lineNum">    7360 </span>            :                                         }
<span class="lineNum">    7361 </span>            :                                 }
<span class="lineNum">    7362 </span>            :                         }
<span class="lineNum">    7363 </span>            :                         //inband-cue based segmentation
<span class="lineNum">    7364 </span><span class="lineCov">     125925 :                         else if (ds-&gt;inband_cues) {</span>
<span class="lineNum">    7365 </span><span class="lineCov">       3375 :                                 const GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_CUE_START);</span>
<span class="lineNum">    7366 </span><span class="lineCov">       3375 :                                 if (p &amp;&amp; p-&gt;value.boolean &amp;&amp; base_ds-&gt;segment_started) {</span>
<span class="lineNum">    7367 </span>            :                                         seg_over = GF_TRUE;
<span class="lineNum">    7368 </span><span class="lineCov">         27 :                                         if (ds == base_ds) {</span>
<span class="lineNum">    7369 </span><span class="lineCov">         27 :                                                 base_ds-&gt;adjusted_next_seg_start = cts;</span>
<span class="lineNum">    7370 </span>            :                                         }
<span class="lineNum">    7371 </span>            :                                 }
<span class="lineNum">    7372 </span>            :                         }
<span class="lineNum">    7373 </span>            :                         //cue-list based segmentation
<span class="lineNum">    7374 </span><span class="lineCov">     122550 :                         else if (ds-&gt;cues) {</span>
<span class="lineNum">    7375 </span>            :                                 u32 cidx;
<span class="lineNum">    7376 </span>            :                                 GF_DASHCueInfo *cue=NULL;
<span class="lineNum">    7377 </span>            :                                 Bool is_cue_split = GF_FALSE;
<span class="lineNum">    7378 </span>            :                                 s32 has_mismatch = -1;
<span class="lineNum">    7379 </span>            : 
<span class="lineNum">    7380 </span><span class="lineCov">          2 :                                 for (cidx=0;cidx&lt;ds-&gt;nb_cues; cidx++) {</span>
<span class="lineNum">    7381 </span><span class="lineCov">       5049 :                                         cue = &amp;ds-&gt;cues[cidx];</span>
<span class="lineNum">    7382 </span><span class="lineCov">       5049 :                                         if (cue-&gt;sample_num) {</span>
<span class="lineNum">    7383 </span><span class="lineCov">       1212 :                                                 if (cue-&gt;sample_num == ds-&gt;nb_pck + 1) {</span>
<span class="lineNum">    7384 </span>            :                                                         is_cue_split = GF_TRUE;
<span class="lineNum">    7385 </span>            :                                                         break;
<span class="lineNum">    7386 </span><span class="lineCov">       1200 :                                                 } else if (cue-&gt;sample_num &lt; ds-&gt;nb_pck) {</span>
<span class="lineNum">    7387 </span><span class="lineNoCov">          0 :                                                         has_mismatch = cidx;</span>
<span class="lineNum">    7388 </span>            :                                                 } else {
<span class="lineNum">    7389 </span>            :                                                         break;
<span class="lineNum">    7390 </span>            :                                                 }
<span class="lineNum">    7391 </span>            :                                         }
<span class="lineNum">    7392 </span><span class="lineCov">       3837 :                                         else if (cue-&gt;dts) {</span>
<span class="lineNum">    7393 </span><span class="lineCov">       1212 :                                                 u64 ts = (cue-&gt;dts - ds-&gt;cues_ts_offset) * ds-&gt;timescale;</span>
<span class="lineNum">    7394 </span><span class="lineCov">       1212 :                                                 u64 ts2 = dts * ds-&gt;cues_timescale;</span>
<span class="lineNum">    7395 </span><span class="lineCov">       1212 :                                                 if (ts == ts2) {</span>
<span class="lineNum">    7396 </span>            :                                                         is_cue_split = GF_TRUE;
<span class="lineNum">    7397 </span>            :                                                         break;
<span class="lineNum">    7398 </span><span class="lineCov">       1200 :                                                 } else if (ts &lt; ts2) {</span>
<span class="lineNum">    7399 </span><span class="lineNoCov">          0 :                                                         has_mismatch = cidx;</span>
<span class="lineNum">    7400 </span>            :                                                 } else {
<span class="lineNum">    7401 </span>            :                                                         break;
<span class="lineNum">    7402 </span>            :                                                 }
<span class="lineNum">    7403 </span>            :                                         }
<span class="lineNum">    7404 </span><span class="lineCov">       2625 :                                         else if (cue-&gt;cts) {</span>
<span class="lineNum">    7405 </span><span class="lineCov">       2625 :                                                 s64 ts = (cue-&gt;cts - ds-&gt;cues_ts_offset) * ds-&gt;timescale;</span>
<span class="lineNum">    7406 </span><span class="lineCov">       2625 :                                                 s64 ts2 = (cts + ds-&gt;first_cts) * ds-&gt;cues_timescale;</span>
<span class="lineNum">    7407 </span>            : 
<span class="lineNum">    7408 </span>            :                                                 //cues are given in track timeline (presentation time), subtract the media time to pres time offset
<span class="lineNum">    7409 </span><span class="lineCov">       2625 :                                                 if (ds-&gt;cues_use_edits) {</span>
<span class="lineNum">    7410 </span><span class="lineCov">       1212 :                                                         ts2 += (s64) (ds-&gt;pts_minus_cts) * ds-&gt;cues_timescale;</span>
<span class="lineNum">    7411 </span>            :                                                 }
<span class="lineNum">    7412 </span><span class="lineCov">       2625 :                                                 if (ts == ts2) {</span>
<span class="lineNum">    7413 </span>            :                                                         is_cue_split = GF_TRUE;
<span class="lineNum">    7414 </span>            :                                                         break;
<span class="lineNum">    7415 </span><span class="lineCov">       2602 :                                                 } else if (ts &lt; ts2) {</span>
<span class="lineNum">    7416 </span><span class="lineCov">          2 :                                                         has_mismatch = cidx;</span>
<span class="lineNum">    7417 </span>            :                                                 } else {
<span class="lineNum">    7418 </span>            :                                                         break;
<span class="lineNum">    7419 </span>            :                                                 }
<span class="lineNum">    7420 </span>            :                                         }
<span class="lineNum">    7421 </span>            :                                 }
<span class="lineNum">    7422 </span>            :                                 //start of first segment
<span class="lineNum">    7423 </span><span class="lineCov">       6247 :                                 if (is_cue_split &amp;&amp; !ds-&gt;segment_started) {</span>
<span class="lineNum">    7424 </span><span class="lineNoCov">          0 :                                         memmove(ds-&gt;cues, &amp;ds-&gt;cues[cidx+1], (ds-&gt;nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));</span>
<span class="lineNum">    7425 </span><span class="lineNoCov">          0 :                                         ds-&gt;nb_cues -= cidx+1;</span>
<span class="lineNum">    7426 </span>            :                                         is_cue_split = 0;
<span class="lineNum">    7427 </span>            :                                 }
<span class="lineNum">    7428 </span>            : 
<span class="lineNum">    7429 </span><span class="lineCov">       6247 :                                 if (is_cue_split) {</span>
<span class="lineNum">    7430 </span><span class="lineCov">         47 :                                         if (!sap_type) {</span>
<span class="lineNum">    7431 </span><span class="lineNoCov">          0 :                                                 GF_LOG(ctx-&gt;strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (&quot;[DASH] cue found (sn %d - dts &quot;LLD&quot; - cts &quot;LLD&quot;) for PID %s but packet %d is not RAP !\n&quot;, cue-&gt;sample_num, cue-&gt;dts, cue-&gt;cts, gf_filter_pid_get_name(ds-&gt;ipid), ds-&gt;nb_pck));</span>
<span class="lineNum">    7432 </span><span class="lineNoCov">          0 :                                                 if (ctx-&gt;strict_cues) {</span>
<span class="lineNum">    7433 </span><span class="lineNoCov">          0 :                                                         gf_filter_pid_drop_packet(ds-&gt;ipid);</span>
<span class="lineNum">    7434 </span><span class="lineNoCov">          0 :                                                         gf_filter_pid_set_discard(ds-&gt;ipid, GF_TRUE);</span>
<span class="lineNum">    7435 </span><span class="lineNoCov">          0 :                                                         return GF_BAD_PARAM;</span>
<span class="lineNum">    7436 </span>            :                                                 }
<span class="lineNum">    7437 </span>            :                                         }
<span class="lineNum">    7438 </span><span class="lineCov">         47 :                                         memmove(ds-&gt;cues, &amp;ds-&gt;cues[cidx+1], (ds-&gt;nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));</span>
<span class="lineNum">    7439 </span><span class="lineCov">         47 :                                         ds-&gt;nb_cues -= cidx+1;</span>
<span class="lineNum">    7440 </span>            : 
<span class="lineNum">    7441 </span><span class="lineCov">         47 :                                         if (sap_type==3)</span>
<span class="lineNum">    7442 </span><span class="lineCov">         47 :                                                 ds-&gt;nb_sap_3 ++;</span>
<span class="lineNum">    7443 </span><span class="lineNoCov">          0 :                                         else if (sap_type&gt;3)</span>
<span class="lineNum">    7444 </span><span class="lineNoCov">          0 :                                                 ds-&gt;nb_sap_4 ++;</span>
<span class="lineNum">    7445 </span>            : 
<span class="lineNum">    7446 </span>            :                                         /*check requested profiles can be generated, or adjust them*/
<span class="lineNum">    7447 </span><span class="lineCov">         47 :                                         if (</span>
<span class="lineNum">    7448 </span><span class="lineCov">         94 :                                                 (ds-&gt;nb_sap_4 || (ds-&gt;nb_sap_3 &gt; 1))</span>
<span class="lineNum">    7449 </span><span class="lineCov">         39 :                                                 &amp;&amp; (ctx-&gt;profile != GF_DASH_PROFILE_FULL)</span>
<span class="lineNum">    7450 </span>            :                                                 /*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)
<span class="lineNum">    7451 </span>            :                                                 for now we only complain for video*/
<span class="lineNum">    7452 </span><span class="lineCov">          8 :                                                 &amp;&amp; ((ds-&gt;stream_type==GF_STREAM_VISUAL) || (ctx-&gt;strict_sap==DASHER_SAP_ON) )</span>
<span class="lineNum">    7453 </span>            :                                         ) {
<span class="lineNum">    7454 </span><span class="lineCov">          8 :                                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\n&quot;, ds-&gt;nb_sap_4 ? 4 : 3));</span>
<span class="lineNum">    7455 </span><span class="lineCov">          8 :                                                 ctx-&gt;profile = GF_DASH_PROFILE_FULL;</span>
<span class="lineNum">    7456 </span><span class="lineCov">          8 :                                                 if (ctx-&gt;sseg)</span>
<span class="lineNum">    7457 </span><span class="lineNoCov">          0 :                                                         ds-&gt;set-&gt;subsegment_starts_with_sap = sap_type;</span>
<span class="lineNum">    7458 </span>            :                                                 else
<span class="lineNum">    7459 </span><span class="lineCov">          8 :                                                         ds-&gt;set-&gt;starts_with_sap = sap_type;</span>
<span class="lineNum">    7460 </span>            :                                         }
<span class="lineNum">    7461 </span>            : 
<span class="lineNum">    7462 </span>            : 
<span class="lineNum">    7463 </span>            :                                         seg_over = GF_TRUE;
<span class="lineNum">    7464 </span><span class="lineCov">         47 :                                         if (ds == base_ds) {</span>
<span class="lineNum">    7465 </span><span class="lineCov">         47 :                                                 base_ds-&gt;adjusted_next_seg_start = cts;</span>
<span class="lineNum">    7466 </span>            :                                         }
<span class="lineNum">    7467 </span>            :                                 }
<span class="lineNum">    7468 </span>            : 
<span class="lineNum">    7469 </span><span class="lineCov">       6247 :                                 if (has_mismatch&gt;=0) {</span>
<span class="lineNum">    7470 </span><span class="lineCov">          2 :                                         cue = &amp;ds-&gt;cues[has_mismatch];</span>
<span class="lineNum">    7471 </span><span class="lineCov">          2 :                                         GF_LOG(ctx-&gt;strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (&quot;[DASH] found cue (sn %d - dts &quot;LLD&quot; - cts &quot;LLD&quot;) in stream %s before current packet (sn %d - dts &quot;LLD&quot; - cts &quot;LLD&quot;) , buggy source cues ?\n&quot;, cue-&gt;sample_num, cue-&gt;dts, cue-&gt;cts, gf_filter_pid_get_name(ds-&gt;ipid), ds-&gt;nb_pck+1, dts + ds-&gt;first_cts, cts + ds-&gt;first_cts));</span>
<span class="lineNum">    7472 </span><span class="lineCov">          2 :                                         if (ctx-&gt;strict_cues) {</span>
<span class="lineNum">    7473 </span><span class="lineCov">          2 :                                                 gf_filter_pid_drop_packet(ds-&gt;ipid);</span>
<span class="lineNum">    7474 </span><span class="lineCov">          2 :                                                 gf_filter_pid_set_discard(ds-&gt;ipid, GF_TRUE);</span>
<span class="lineNum">    7475 </span><span class="lineCov">          2 :                                                 return GF_BAD_PARAM;</span>
<span class="lineNum">    7476 </span>            :                                         }
<span class="lineNum">    7477 </span>            :                                 }
<span class="lineNum">    7478 </span>            :                         }
<span class="lineNum">    7479 </span>            :                         //forcing max time
<span class="lineNum">    7480 </span><span class="lineCov">     116303 :                         else if (</span>
<span class="lineNum">    7481 </span><span class="lineCov">     116303 :                                 (base_ds-&gt;force_rep_end &amp;&amp; (cts * base_ds-&gt;timescale &gt;= base_ds-&gt;force_rep_end * ds-&gt;timescale) )</span>
<span class="lineNum">    7482 </span><span class="lineCov">     116303 :                                 || (base_ds-&gt;clamped_dur.num &amp;&amp; (cts + o_dur &gt; ds-&gt;ts_offset + base_ds-&gt;clamped_dur.num * ds-&gt;timescale / base_ds-&gt;clamped_dur.den))</span>
<span class="lineNum">    7483 </span>            :                         ) {
<span class="lineNum">    7484 </span><span class="lineCov">         52 :                                 if (!base_ds-&gt;period-&gt;period-&gt;duration &amp;&amp; base_ds-&gt;force_rep_end) {</span>
<span class="lineNum">    7485 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Inputs duration do not match, %s truncated to %g duration\n&quot;, ds-&gt;src_url, ((Double)base_ds-&gt;force_rep_end)/base_ds-&gt;timescale ));</span>
<span class="lineNum">    7486 </span>            :                                 }
<span class="lineNum">    7487 </span><span class="lineCov">         52 :                                 dasher_drop_input(ctx, ds, GF_TRUE);</span>
<span class="lineNum">    7488 </span><span class="lineCov">         52 :                                 ds-&gt;clamp_done = GF_TRUE;</span>
<span class="lineNum">    7489 </span><span class="lineCov">         52 :                                 continue;</span>
<span class="lineNum">    7490 </span>            :                         }
<span class="lineNum">    7491 </span>            :                         //we have a SAP and we work in closest mode: check the next SAP in the queue, and decide if we
<span class="lineNum">    7492 </span>            :                         //split the segment at this SAP or wait for the next one
<span class="lineNum">    7493 </span><span class="lineCov">     116251 :                         else if (ds-&gt;segment_started &amp;&amp; ds-&gt;sbound &amp;&amp; sap_type) {</span>
<span class="lineNum">    7494 </span><span class="lineCov">        683 :                                 u32 idx, nb_queued, nb_pck = gf_list_count(ds-&gt;packet_queue);</span>
<span class="lineNum">    7495 </span>            :                                 nb_queued = nb_pck;
<span class="lineNum">    7496 </span><span class="lineCov">        683 :                                 if (is_queue_flush) nb_queued += 1;</span>
<span class="lineNum">    7497 </span>            :                                 
<span class="lineNum">    7498 </span><span class="lineCov">       1550 :                                 for (idx=1; idx&lt;nb_queued; idx++) {</span>
<span class="lineNum">    7499 </span>            :                                         GF_FilterPacket *next;
<span class="lineNum">    7500 </span><span class="lineCov">        883 :                                         if (idx==nb_pck) {</span>
<span class="lineNum">    7501 </span><span class="lineCov">          5 :                                                 next = gf_list_last(ds-&gt;packet_queue);</span>
<span class="lineNum">    7502 </span>            :                                         } else {
<span class="lineNum">    7503 </span><span class="lineCov">        878 :                                                 next = gf_list_get(ds-&gt;packet_queue, idx);</span>
<span class="lineNum">    7504 </span><span class="lineCov">        878 :                                                 u32 sap_next = gf_filter_pck_get_sap(next);</span>
<span class="lineNum">    7505 </span><span class="lineCov">        878 :                                                 if (!sap_next) continue;</span>
<span class="lineNum">    7506 </span>            :                                         }
<span class="lineNum">    7507 </span><span class="lineCov">        683 :                                         u32 next_dur = gf_filter_pck_get_duration(next);</span>
<span class="lineNum">    7508 </span>            :                                         //compute cts next
<span class="lineNum">    7509 </span><span class="lineCov">        683 :                                         u64 cts_next = gf_filter_pck_get_cts(next);</span>
<span class="lineNum">    7510 </span><span class="lineCov">        683 :                                         if (ds-&gt;ts_offset) {</span>
<span class="lineNum">    7511 </span><span class="lineCov">         72 :                                                 cts_next += ds-&gt;ts_offset;</span>
<span class="lineNum">    7512 </span>            :                                         }
<span class="lineNum">    7513 </span>            :                                         cts_next = dasher_translate_cts(ds, cts_next);
<span class="lineNum">    7514 </span>            : 
<span class="lineNum">    7515 </span><span class="lineCov">        683 :                                         if ((idx==nb_pck) &amp;&amp; ctx-&gt;last_seg_merge) {</span>
<span class="lineNum">    7516 </span><span class="lineNoCov">          0 :                                                 u64 next_seg_dur = (cts_next + next_dur - cts);</span>
<span class="lineNum">    7517 </span><span class="lineNoCov">          0 :                                                 if (next_seg_dur * ds-&gt;dash_dur.den &lt; (u64) ds-&gt;dash_dur.num * ds-&gt;timescale / 2)</span>
<span class="lineNum">    7518 </span><span class="lineNoCov">          0 :                                                         continue;</span>
<span class="lineNum">    7519 </span>            :                                         }
<span class="lineNum">    7520 </span>            : 
<span class="lineNum">    7521 </span>            :                                         //same rule as above
<span class="lineNum">    7522 </span><span class="lineCov">        683 :                                         if ((cts_next + next_dur) * base_ds-&gt;timescale &gt;= base_ds-&gt;adjusted_next_seg_start * ds-&gt;timescale ) {</span>
<span class="lineNum">    7523 </span>            :                                                 Bool force_seg_flush = GF_FALSE;
<span class="lineNum">    7524 </span><span class="lineCov">         31 :                                                 s64 diff_next = cts_next * base_ds-&gt;timescale / ds-&gt;timescale;</span>
<span class="lineNum">    7525 </span><span class="lineCov">         31 :                                                 diff_next -= base_ds-&gt;adjusted_next_seg_start;</span>
<span class="lineNum">    7526 </span>            :                                                 //bounds at closest: if this SAP is closer to the target next segment start than the next SAP, split at this packet
<span class="lineNum">    7527 </span><span class="lineCov">         31 :                                                 if (ds-&gt;sbound==DASHER_BOUNDS_CLOSEST) {</span>
<span class="lineNum">    7528 </span><span class="lineCov">         16 :                                                         s64 diff = cts * base_ds-&gt;timescale / ds-&gt;timescale;</span>
<span class="lineNum">    7529 </span><span class="lineCov">         16 :                                                         diff -= base_ds-&gt;adjusted_next_seg_start;</span>
<span class="lineNum">    7530 </span>            :                                                         //this one may be negative, but we always want diff_next positive (next SAP in next segment)
<span class="lineNum">    7531 </span><span class="lineCov">         16 :                                                         if (diff&lt;0)</span>
<span class="lineNum">    7532 </span><span class="lineCov">         12 :                                                                 diff = -diff;</span>
<span class="lineNum">    7533 </span>            :                                                         //old arch was only using closest for tracks with sync points
<span class="lineNum">    7534 </span><span class="lineCov">         16 :                                                         if (gf_sys_old_arch_compat() &amp;&amp; (base_ds-&gt;sync_points_type==DASHER_SYNC_NONE) ) {</span>
<span class="lineNum">    7535 </span><span class="lineCov">          8 :                                                                 if (diff_next &gt; 0) {</span>
<span class="lineNum">    7536 </span>            :                                                                         force_seg_flush = GF_TRUE;
<span class="lineNum">    7537 </span>            :                                                                 }
<span class="lineNum">    7538 </span>            :                                                         }
<span class="lineNum">    7539 </span><span class="lineCov">          8 :                                                         else if (diff&lt;diff_next) {</span>
<span class="lineNum">    7540 </span>            :                                                                 force_seg_flush = GF_TRUE;
<span class="lineNum">    7541 </span>            :                                                         }
<span class="lineNum">    7542 </span>            :                                                 }
<span class="lineNum">    7543 </span>            :                                                 //bounds always in: if the next SAP is strictly greater than the target next segment start, split at this packet
<span class="lineNum">    7544 </span>            :                                                 else {
<span class="lineNum">    7545 </span><span class="lineCov">         15 :                                                         if (diff_next &gt; 0) {</span>
<span class="lineNum">    7546 </span>            :                                                                 force_seg_flush = GF_TRUE;
<span class="lineNum">    7547 </span>            :                                                         }
<span class="lineNum">    7548 </span>            :                                                 }
<span class="lineNum">    7549 </span>            :                                                 if (force_seg_flush) {
<span class="lineNum">    7550 </span>            :                                                         seg_over = GF_TRUE;
<span class="lineNum">    7551 </span><span class="lineCov">         16 :                                                         if (ds == base_ds) {</span>
<span class="lineNum">    7552 </span><span class="lineCov">         16 :                                                                 base_ds-&gt;adjusted_next_seg_start = cts;</span>
<span class="lineNum">    7553 </span>            :                                                         }
<span class="lineNum">    7554 </span>            :                                                         break;
<span class="lineNum">    7555 </span>            :                                                 }
<span class="lineNum">    7556 </span>            :                                         }
<span class="lineNum">    7557 </span>            :                                 }
<span class="lineNum">    7558 </span>            :                         }
<span class="lineNum">    7559 </span>            :                         //we exceed segment duration - if segment was started, check if we need to stop segment
<span class="lineNum">    7560 </span>            :                         //if segment was not started we insert the packet anyway
<span class="lineNum">    7561 </span><span class="lineCov">     115568 :                         else if (!ds-&gt;sbound &amp;&amp; ds-&gt;segment_started &amp;&amp; ((cts + check_dur) * base_ds-&gt;timescale &gt;= base_ds-&gt;adjusted_next_seg_start * ds-&gt;timescale ) ) {</span>
<span class="lineNum">    7562 </span>            :                                 //no sap, segment is over
<span class="lineNum">    7563 </span><span class="lineCov">       6568 :                                 if (! ctx-&gt;sap) {</span>
<span class="lineNum">    7564 </span>            :                                         seg_over = GF_TRUE;
<span class="lineNum">    7565 </span>            :                                 }
<span class="lineNum">    7566 </span><span class="lineCov">       6501 :                                 else if ((ds-&gt;stream_type==GF_STREAM_AUDIO)</span>
<span class="lineNum">    7567 </span><span class="lineCov">        653 :                                         &amp;&amp; ((cts + check_dur) * base_ds-&gt;timescale == base_ds-&gt;adjusted_next_seg_start * ds-&gt;timescale)</span>
<span class="lineNum">    7568 </span>            :                                 ) {
<span class="lineNum">    7569 </span>            : 
<span class="lineNum">    7570 </span>            :                                 }
<span class="lineNum">    7571 </span>            :                                 // sap, segment is over
<span class="lineNum">    7572 </span><span class="lineCov">       6500 :                                 else if (sap_type) {</span>
<span class="lineNum">    7573 </span>            : 
<span class="lineNum">    7574 </span><span class="lineCov">       2939 :                                         if (sap_type==3)</span>
<span class="lineNum">    7575 </span><span class="lineCov">          8 :                                                 ds-&gt;nb_sap_3 ++;</span>
<span class="lineNum">    7576 </span><span class="lineCov">       2931 :                                         else if (sap_type&gt;3)</span>
<span class="lineNum">    7577 </span><span class="lineCov">         14 :                                                 ds-&gt;nb_sap_4 ++;</span>
<span class="lineNum">    7578 </span>            : 
<span class="lineNum">    7579 </span>            :                                         /*check requested profiles can be generated, or adjust them*/
<span class="lineNum">    7580 </span><span class="lineCov">       2939 :                                         if ((ctx-&gt;profile != GF_DASH_PROFILE_FULL)</span>
<span class="lineNum">    7581 </span><span class="lineCov">       2621 :                                                 &amp;&amp; (ds-&gt;nb_sap_4 || (ds-&gt;nb_sap_3 &gt; 1))</span>
<span class="lineNum">    7582 </span>            :                                                 /*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)
<span class="lineNum">    7583 </span>            :                                                 for now we only complain for video*/
<span class="lineNum">    7584 </span><span class="lineCov">          2 :                                                 &amp;&amp; ((ds-&gt;stream_type==GF_STREAM_VISUAL) || (ctx-&gt;strict_sap==DASHER_SAP_ON) )</span>
<span class="lineNum">    7585 </span>            :                                         ) {
<span class="lineNum">    7586 </span><span class="lineCov">          2 :                                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\n&quot;, ds-&gt;nb_sap_4 ? 4 : 3));</span>
<span class="lineNum">    7587 </span><span class="lineCov">          2 :                                                 ctx-&gt;profile = GF_DASH_PROFILE_FULL;</span>
<span class="lineNum">    7588 </span><span class="lineCov">          2 :                                                 if (ctx-&gt;sseg)</span>
<span class="lineNum">    7589 </span><span class="lineCov">          2 :                                                         ds-&gt;set-&gt;subsegment_starts_with_sap = sap_type;</span>
<span class="lineNum">    7590 </span>            :                                                 else
<span class="lineNum">    7591 </span><span class="lineNoCov">          0 :                                                         ds-&gt;set-&gt;starts_with_sap = sap_type;</span>
<span class="lineNum">    7592 </span>            :                                         }
<span class="lineNum">    7593 </span>            : 
<span class="lineNum">    7594 </span>            :                                         seg_over = GF_TRUE;
<span class="lineNum">    7595 </span><span class="lineCov">       2939 :                                         if (ds == base_ds) {</span>
<span class="lineNum">    7596 </span><span class="lineCov">       2828 :                                                 base_ds-&gt;adjusted_next_seg_start = cts;</span>
<span class="lineNum">    7597 </span>            :                                         }
<span class="lineNum">    7598 </span>            :                                 }
<span class="lineNum">    7599 </span>            :                         }
<span class="lineNum">    7600 </span>            : 
<span class="lineNum">    7601 </span>            : 
<span class="lineNum">    7602 </span><span class="lineCov">     129551 :                         if (ds-&gt;muxed_base &amp;&amp; ds-&gt;muxed_base-&gt;done) {</span>
<span class="lineNum">    7603 </span>            :                                 seg_over = GF_FALSE;
<span class="lineNum">    7604 </span>            :                         }
<span class="lineNum">    7605 </span>            :                         //if flushing now will result in a one sample fragment afterwards
<span class="lineNum">    7606 </span>            :                         //because this is the before-last sample, don't flush unless:
<span class="lineNum">    7607 </span>            :                         //- we have an asto set (low latency)
<span class="lineNum">    7608 </span>            :                         //- this is not an audio stream or all samples are SAPs
<span class="lineNum">    7609 </span>            :                         //- we use cues
<span class="lineNum">    7610 </span><span class="lineCov">     129502 :                         else if (seg_over &amp;&amp; ds-&gt;nb_samples_in_source &amp;&amp; !ctx-&gt;loop</span>
<span class="lineNum">    7611 </span><span class="lineCov">       2081 :                                 &amp;&amp; (ds-&gt;nb_pck+1 == ds-&gt;nb_samples_in_source)</span>
<span class="lineNum">    7612 </span><span class="lineCov">         13 :                                 &amp;&amp; !ds-&gt;inband_cues &amp;&amp; !ds-&gt;cues</span>
<span class="lineNum">    7613 </span><span class="lineCov">         13 :                                 &amp;&amp; !ctx-&gt;asto</span>
<span class="lineNum">    7614 </span><span class="lineCov">         13 :                                 &amp;&amp; ! ((ds-&gt;sync_points_type==DASHER_SYNC_NONE) &amp;&amp; (ds-&gt;stream_type!=GF_STREAM_AUDIO))</span>
<span class="lineNum">    7615 </span>            :                         ) {
<span class="lineNum">    7616 </span>            :                                 seg_over = GF_FALSE;
<span class="lineNum">    7617 </span>            :                         }
<span class="lineNum">    7618 </span>            :                         //if dur=0 (some text streams), don't flush segment
<span class="lineNum">    7619 </span><span class="lineCov">     129551 :                         if (seg_over &amp;&amp; dur) {</span>
<span class="lineNum">    7620 </span>            :                                 assert(!ds-&gt;seg_done);
<span class="lineNum">    7621 </span>            : 
<span class="lineNum">    7622 </span><span class="lineCov">       3149 :                                 if (ds-&gt;request_period_switch &amp;&amp; !gf_list_count(ds-&gt;packet_queue)) {</span>
<span class="lineNum">    7623 </span><span class="lineNoCov">          0 :                                         e = dasher_stream_period_changed(filter, ctx, ds, (ds-&gt;request_period_switch==2) ? GF_TRUE : GF_FALSE);</span>
<span class="lineNum">    7624 </span><span class="lineNoCov">          0 :                                         if (e &lt; 0) {</span>
<span class="lineNum">    7625 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Period switch request failed.\n&quot;));</span>
<span class="lineNum">    7626 </span>            :                                                 break;
<span class="lineNum">    7627 </span>            :                                         }
<span class="lineNum">    7628 </span>            :                                         assert(gf_list_find(ctx-&gt;current_period-&gt;streams, ds)&lt;0);
<span class="lineNum">    7629 </span><span class="lineNoCov">          0 :                                         count = gf_list_count(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    7630 </span><span class="lineNoCov">          0 :                                         i--;</span>
<span class="lineNum">    7631 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    7632 </span>            :                                 }
<span class="lineNum">    7633 </span>            : 
<span class="lineNum">    7634 </span><span class="lineCov">       3149 :                                 ds-&gt;seg_done = GF_TRUE;</span>
<span class="lineNum">    7635 </span>            : 
<span class="lineNum">    7636 </span>            :                                 //in dynamic mode, send end of dash segment marker to flush segment right away, otherwise we will
<span class="lineNum">    7637 </span>            :                                 //flush the segment at next segment start which could be after the segment AST =&gt; 404
<span class="lineNum">    7638 </span><span class="lineCov">       3149 :                                 if (!ctx-&gt;subdur &amp;&amp; (ctx-&gt;dmode&gt;=GF_DASH_DYNAMIC)) {</span>
<span class="lineNum">    7639 </span>            :                                         GF_FilterPacket *eods_pck;
<span class="lineNum">    7640 </span><span class="lineCov">         74 :                                         eods_pck = gf_filter_pck_new_alloc(ds-&gt;opid, 0, NULL);</span>
<span class="lineNum">    7641 </span><span class="lineCov">         74 :                                         if (eods_pck) {</span>
<span class="lineNum">    7642 </span><span class="lineCov">         74 :                                                 gf_filter_pck_set_property(eods_pck, GF_PROP_PCK_EODS, &amp;PROP_BOOL(GF_TRUE) );</span>
<span class="lineNum">    7643 </span><span class="lineCov">         74 :                                                 gf_filter_pck_send(eods_pck);</span>
<span class="lineNum">    7644 </span>            :                                         }
<span class="lineNum">    7645 </span>            :                                 }
<span class="lineNum">    7646 </span>            : 
<span class="lineNum">    7647 </span><span class="lineCov">       3149 :                                 ds-&gt;first_cts_in_next_seg = cts;</span>
<span class="lineNum">    7648 </span>            :                                 assert(base_ds-&gt;nb_comp_done &lt; base_ds-&gt;nb_comp);
<span class="lineNum">    7649 </span><span class="lineCov">       3149 :                                 base_ds-&gt;nb_comp_done ++;</span>
<span class="lineNum">    7650 </span>            : 
<span class="lineNum">    7651 </span><span class="lineCov">       3149 :                                 if (split_dur_next)</span>
<span class="lineNum">    7652 </span><span class="lineCov">         26 :                                         ds-&gt;split_dur_next = (u32) split_dur_next;</span>
<span class="lineNum">    7653 </span>            : 
<span class="lineNum">    7654 </span><span class="lineCov">       3149 :                                 if (base_ds-&gt;nb_comp_done == base_ds-&gt;nb_comp) {</span>
<span class="lineNum">    7655 </span><span class="lineCov">       3001 :                                         dasher_flush_segment(ctx, base_ds, GF_FALSE);</span>
<span class="lineNum">    7656 </span>            :                                         seg_done = GF_TRUE;
<span class="lineNum">    7657 </span>            :                                 }
<span class="lineNum">    7658 </span>            :                                 break;
<span class="lineNum">    7659 </span>            :                         }
<span class="lineNum">    7660 </span>            : 
<span class="lineNum">    7661 </span><span class="lineCov">     126402 :                         if (cts==GF_FILTER_NO_TS) {</span>
<span class="lineNum">    7662 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] WARNING! Source packet has no timestamp !\n&quot;));</span>
<span class="lineNum">    7663 </span>            : 
<span class="lineNum">    7664 </span><span class="lineNoCov">          0 :                                 cts = ds-&gt;last_cts;</span>
<span class="lineNum">    7665 </span><span class="lineNoCov">          0 :                                 dts = ds-&gt;last_dts;</span>
<span class="lineNum">    7666 </span>            :                         } else {
<span class="lineNum">    7667 </span><span class="lineCov">     126402 :                                 u64 ncts = cts + (split_dur ? split_dur : dur);</span>
<span class="lineNum">    7668 </span><span class="lineCov">     126402 :                                 if (ncts&gt;ds-&gt;est_first_cts_in_next_seg)</span>
<span class="lineNum">    7669 </span><span class="lineCov">     116645 :                                         ds-&gt;est_first_cts_in_next_seg = ncts;</span>
<span class="lineNum">    7670 </span>            : 
<span class="lineNum">    7671 </span><span class="lineCov">     126402 :                                 ncts *= 1000;</span>
<span class="lineNum">    7672 </span><span class="lineCov">     126402 :                                 ncts /= ds-&gt;timescale;</span>
<span class="lineNum">    7673 </span><span class="lineCov">     126402 :                                 if (ncts&gt;base_ds-&gt;max_period_dur)</span>
<span class="lineNum">    7674 </span><span class="lineCov">     110988 :                                         base_ds-&gt;max_period_dur = ncts;</span>
<span class="lineNum">    7675 </span>            : 
<span class="lineNum">    7676 </span><span class="lineCov">     126402 :                                 ds-&gt;last_cts = cts + (split_dur ? split_dur : dur);</span>
<span class="lineNum">    7677 </span><span class="lineCov">     126402 :                                 ds-&gt;last_dts = dts;</span>
<span class="lineNum">    7678 </span><span class="lineCov">     126402 :                                 ds-&gt;est_next_dts = dts + o_dur;</span>
<span class="lineNum">    7679 </span>            :                         }
<span class="lineNum">    7680 </span><span class="lineCov">     126402 :                         ds-&gt;nb_pck ++;</span>
<span class="lineNum">    7681 </span>            : 
<span class="lineNum">    7682 </span><span class="lineCov">     126402 :                         if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    7683 </span><span class="lineCov">       3600 :                                 if (!ds-&gt;segment_started) {</span>
<span class="lineNum">    7684 </span><span class="lineCov">         72 :                                         ds-&gt;first_cts_in_seg = cts;</span>
<span class="lineNum">    7685 </span><span class="lineCov">         72 :                                         dasher_mark_segment_start(ctx, ds, NULL, pck);</span>
<span class="lineNum">    7686 </span><span class="lineCov">         72 :                                         ds-&gt;segment_started = GF_TRUE;</span>
<span class="lineNum">    7687 </span>            :                                 }
<span class="lineNum">    7688 </span>            : 
<span class="lineNum">    7689 </span><span class="lineCov">       3600 :                                 ds-&gt;cumulated_dur += dur;</span>
<span class="lineNum">    7690 </span>            : 
<span class="lineNum">    7691 </span>            :                                 //drop packet if not splitting
<span class="lineNum">    7692 </span><span class="lineCov">       3600 :                                 if (!ds-&gt;split_dur_next)</span>
<span class="lineNum">    7693 </span><span class="lineCov">       3600 :                                         gf_filter_pid_drop_packet(ds-&gt;ipid);</span>
<span class="lineNum">    7694 </span>            : 
<span class="lineNum">    7695 </span><span class="lineCov">       3600 :                                 if (ctx-&gt;in_error) {</span>
<span class="lineNum">    7696 </span><span class="lineNoCov">          0 :                                         gf_filter_pid_set_discard(ds-&gt;ipid, GF_TRUE);</span>
<span class="lineNum">    7697 </span><span class="lineNoCov">          0 :                                         gf_filter_pid_set_eos(ctx-&gt;opid);</span>
<span class="lineNum">    7698 </span><span class="lineNoCov">          0 :                                         return GF_BAD_PARAM;</span>
<span class="lineNum">    7699 </span>            :                                 }
<span class="lineNum">    7700 </span><span class="lineCov">       3600 :                                 continue;</span>
<span class="lineNum">    7701 </span>            :                         }
<span class="lineNum">    7702 </span>            :                         //create new ref to input
<span class="lineNum">    7703 </span><span class="lineCov">     122802 :                         dst = gf_filter_pck_new_ref(ds-&gt;opid, 0, 0, pck);</span>
<span class="lineNum">    7704 </span><span class="lineCov">     122802 :                         if (!dst) return GF_OUT_OF_MEM;</span>
<span class="lineNum">    7705 </span>            : 
<span class="lineNum">    7706 </span>            :                         //merge all props
<span class="lineNum">    7707 </span><span class="lineCov">     122802 :                         gf_filter_pck_merge_properties(pck, dst);</span>
<span class="lineNum">    7708 </span>            :                         //we have ts offset, use computed cts and dts
<span class="lineNum">    7709 </span><span class="lineCov">     122802 :                         if (ds-&gt;ts_offset) {</span>
<span class="lineNum">    7710 </span><span class="lineCov">        563 :                                 gf_filter_pck_set_cts(dst, gf_filter_pck_get_cts(pck) + ds-&gt;ts_offset);</span>
<span class="lineNum">    7711 </span><span class="lineCov">        563 :                                 gf_filter_pck_set_dts(dst, gf_filter_pck_get_dts(pck) + ds-&gt;ts_offset);</span>
<span class="lineNum">    7712 </span>            :                         }
<span class="lineNum">    7713 </span>            : 
<span class="lineNum">    7714 </span><span class="lineCov">     122802 :                         if (gf_sys_old_arch_compat() &amp;&amp; ds-&gt;clamped_dur.num &amp;&amp; ctx-&gt;loop</span>
<span class="lineNum">    7715 </span><span class="lineCov">       1917 :                                 &amp;&amp; (cts + 2*o_dur &gt;= ds-&gt;ts_offset + base_ds-&gt;clamped_dur.num * ds-&gt;timescale / base_ds-&gt;clamped_dur.den)</span>
<span class="lineNum">    7716 </span>            :                         ) {
<span class="lineNum">    7717 </span>            :                                 u32 _dur = dur;
<span class="lineNum">    7718 </span>            :                                 /* simple round with (int)+.5 to avoid trucating .99999 to 0 */
<span class="lineNum">    7719 </span><span class="lineCov">         21 :                                 dur = (u32) (ds-&gt;clamped_dur.num * ds-&gt;timescale / ds-&gt;clamped_dur.den - (dts - ds-&gt;ts_offset) + 0.5);</span>
<span class="lineNum">    7720 </span>            :                                 //it may happen that the sample duration is 0 if the clamp duration is right after the sample DTS and timescale is not big enough to express it - force to 1
<span class="lineNum">    7721 </span><span class="lineCov">         21 :                                 if (dur==0)</span>
<span class="lineNum">    7722 </span>            :                                         dur=1;
<span class="lineNum">    7723 </span>            : 
<span class="lineNum">    7724 </span><span class="lineCov">         21 :                                 gf_filter_pck_set_duration(dst, dur);</span>
<span class="lineNum">    7725 </span><span class="lineCov">         21 :                                 ds-&gt;est_next_dts += (s32) dur - (s32) _dur;;</span>
<span class="lineNum">    7726 </span>            :                         }
<span class="lineNum">    7727 </span>            : 
<span class="lineNum">    7728 </span><span class="lineCov">     122802 :                         if (!ds-&gt;segment_started) {</span>
<span class="lineNum">    7729 </span><span class="lineCov">       3418 :                                 ds-&gt;first_cts_in_seg = cts;</span>
<span class="lineNum">    7730 </span><span class="lineCov">       3418 :                                 dasher_mark_segment_start(ctx, ds, dst, pck);</span>
<span class="lineNum">    7731 </span><span class="lineCov">       3418 :                                 ds-&gt;segment_started = GF_TRUE;</span>
<span class="lineNum">    7732 </span>            :                         }
<span class="lineNum">    7733 </span>            :                         //prev packet was split
<span class="lineNum">    7734 </span><span class="lineCov">     122802 :                         if (is_packet_split) {</span>
<span class="lineNum">    7735 </span>            :                                 u64 diff=0;
<span class="lineNum">    7736 </span><span class="lineCov">         26 :                                 u8 dep_flags = gf_filter_pck_get_dependency_flags(pck);</span>
<span class="lineNum">    7737 </span><span class="lineCov">         26 :                                 u64 ts = gf_filter_pck_get_cts(pck);</span>
<span class="lineNum">    7738 </span><span class="lineCov">         26 :                                 if (ts != GF_FILTER_NO_TS) {</span>
<span class="lineNum">    7739 </span><span class="lineCov">         26 :                                         cts += ds-&gt;first_cts;</span>
<span class="lineNum">    7740 </span>            :                                         assert(cts &gt;= ts);
<span class="lineNum">    7741 </span><span class="lineCov">         26 :                                         diff = cts - ts;</span>
<span class="lineNum">    7742 </span>            :                                 } else {
<span class="lineNum">    7743 </span><span class="lineNoCov">          0 :                                         cts = ds-&gt;last_cts;</span>
<span class="lineNum">    7744 </span>            :                                 }
<span class="lineNum">    7745 </span><span class="lineCov">         26 :                                 gf_filter_pck_set_cts(dst, cts + ds-&gt;ts_offset);</span>
<span class="lineNum">    7746 </span>            : 
<span class="lineNum">    7747 </span><span class="lineCov">         26 :                                 ts = gf_filter_pck_get_dts(pck);</span>
<span class="lineNum">    7748 </span><span class="lineCov">         26 :                                 if (ts != GF_FILTER_NO_TS)</span>
<span class="lineNum">    7749 </span><span class="lineCov">         26 :                                         gf_filter_pck_set_dts(dst, ts + diff + ds-&gt;ts_offset);</span>
<span class="lineNum">    7750 </span>            : 
<span class="lineNum">    7751 </span>            :                                 //add sample is redundant flag
<span class="lineNum">    7752 </span><span class="lineCov">         26 :                                 dep_flags |= 0x1;</span>
<span class="lineNum">    7753 </span><span class="lineCov">         26 :                                 gf_filter_pck_set_dependency_flags(dst, dep_flags);</span>
<span class="lineNum">    7754 </span>            :                                 //this one might be incorrect of this split packet is also split, but we update the duration right below
<span class="lineNum">    7755 </span><span class="lineCov">         26 :                                 gf_filter_pck_set_duration(dst, dur);</span>
<span class="lineNum">    7756 </span>            :                         }
<span class="lineNum">    7757 </span>            : 
<span class="lineNum">    7758 </span>            :                         //if split, adjust duration - this may happen on a split packet, if it covered 3 or more segments
<span class="lineNum">    7759 </span><span class="lineCov">     122802 :                         if (split_dur) {</span>
<span class="lineNum">    7760 </span>            :                                 u32 cumulated_split_dur = split_dur;
<span class="lineNum">    7761 </span><span class="lineCov">         26 :                                 gf_filter_pck_set_duration(dst, split_dur);</span>
<span class="lineNum">    7762 </span>            :                                 //adjust dur
<span class="lineNum">    7763 </span><span class="lineCov">         26 :                                 cumulated_split_dur += (u32) (cts - orig_cts);</span>
<span class="lineNum">    7764 </span>            :                                 assert( dur &gt; split_dur);
<span class="lineNum">    7765 </span><span class="lineCov">         26 :                                 ds-&gt;split_dur_next = cumulated_split_dur;</span>
<span class="lineNum">    7766 </span>            :                                 dur = split_dur;
<span class="lineNum">    7767 </span>            :                         }
<span class="lineNum">    7768 </span>            : 
<span class="lineNum">    7769 </span>            :                         //remove NTP
<span class="lineNum">    7770 </span><span class="lineCov">     122802 :                         if (ctx-&gt;ntp != DASHER_NTP_KEEP)</span>
<span class="lineNum">    7771 </span><span class="lineCov">     122802 :                                 gf_filter_pck_set_property(dst, GF_PROP_PCK_SENDER_NTP, NULL);</span>
<span class="lineNum">    7772 </span>            : 
<span class="lineNum">    7773 </span>            :                         //change packet times
<span class="lineNum">    7774 </span><span class="lineCov">     122802 :                         if (ds-&gt;force_timescale) {</span>
<span class="lineNum">    7775 </span>            :                                 u64 ats;
<span class="lineNum">    7776 </span><span class="lineNoCov">          0 :                                 ats = gf_filter_pck_get_dts(dst);</span>
<span class="lineNum">    7777 </span><span class="lineNoCov">          0 :                                 if (ats!=GF_FILTER_NO_TS) {</span>
<span class="lineNum">    7778 </span><span class="lineNoCov">          0 :                                         ats *= ds-&gt;force_timescale;</span>
<span class="lineNum">    7779 </span><span class="lineNoCov">          0 :                                         ats /= ds-&gt;timescale;</span>
<span class="lineNum">    7780 </span><span class="lineNoCov">          0 :                                         gf_filter_pck_set_dts(dst, ats);</span>
<span class="lineNum">    7781 </span>            :                                 }
<span class="lineNum">    7782 </span><span class="lineNoCov">          0 :                                 ats = gf_filter_pck_get_cts(dst);</span>
<span class="lineNum">    7783 </span><span class="lineNoCov">          0 :                                 if (ats!=GF_FILTER_NO_TS) {</span>
<span class="lineNum">    7784 </span><span class="lineNoCov">          0 :                                         ats *= ds-&gt;force_timescale;</span>
<span class="lineNum">    7785 </span><span class="lineNoCov">          0 :                                         ats /= ds-&gt;timescale;</span>
<span class="lineNum">    7786 </span><span class="lineNoCov">          0 :                                         gf_filter_pck_set_cts(dst, ats);</span>
<span class="lineNum">    7787 </span>            :                                 }
<span class="lineNum">    7788 </span><span class="lineNoCov">          0 :                                 ats = (u64) gf_filter_pck_get_duration(dst);</span>
<span class="lineNum">    7789 </span><span class="lineNoCov">          0 :                                 if (ats) {</span>
<span class="lineNum">    7790 </span><span class="lineNoCov">          0 :                                         ats *= ds-&gt;force_timescale;</span>
<span class="lineNum">    7791 </span><span class="lineNoCov">          0 :                                         ats /= ds-&gt;timescale;</span>
<span class="lineNum">    7792 </span><span class="lineNoCov">          0 :                                         gf_filter_pck_set_duration(dst, (u32) ats);</span>
<span class="lineNum">    7793 </span>            :                                 }
<span class="lineNum">    7794 </span>            :                         }
<span class="lineNum">    7795 </span>            : 
<span class="lineNum">    7796 </span><span class="lineCov">     122802 :                         ds-&gt;cumulated_dur += dur;</span>
<span class="lineNum">    7797 </span>            : 
<span class="lineNum">    7798 </span><span class="lineCov">     122802 :                         if (ds-&gt;current_seg_state &amp;&amp; gf_filter_pck_get_crypt_flags(pck))</span>
<span class="lineNum">    7799 </span><span class="lineCov">       1416 :                                 ds-&gt;current_seg_state-&gt;encrypted = GF_TRUE;</span>
<span class="lineNum">    7800 </span>            :                         //TODO check drift between MPD start time and min CTS in segment (not just first CTS in segment)
<span class="lineNum">    7801 </span>            : 
<span class="lineNum">    7802 </span>            :                         //send packet
<span class="lineNum">    7803 </span><span class="lineCov">     122802 :                         gf_filter_pck_send(dst);</span>
<span class="lineNum">    7804 </span>            : 
<span class="lineNum">    7805 </span><span class="lineCov">     122802 :                         if (ctx-&gt;update_report&gt;=0)</span>
<span class="lineNum">    7806 </span><span class="lineCov">      21539 :                                 ctx-&gt;update_report++;</span>
<span class="lineNum">    7807 </span>            : 
<span class="lineNum">    7808 </span><span class="lineCov">     122802 :                         if (ds-&gt;dyn_bitrate) {</span>
<span class="lineNum">    7809 </span>            :                                 u32 dsize;
<span class="lineNum">    7810 </span><span class="lineCov">      26262 :                                 u64 dts = gf_filter_pck_get_dts(pck);</span>
<span class="lineNum">    7811 </span><span class="lineCov">      26262 :                                 gf_filter_pck_get_data(pck, &amp;dsize);</span>
<span class="lineNum">    7812 </span><span class="lineCov">      26262 :                                 if (!ds-&gt;rate_first_dts_plus_one)</span>
<span class="lineNum">    7813 </span><span class="lineCov">         60 :                                         ds-&gt;rate_first_dts_plus_one = 1 + dts;</span>
<span class="lineNum">    7814 </span><span class="lineCov">      26262 :                                 ds-&gt;rate_last_dts = dts;</span>
<span class="lineNum">    7815 </span><span class="lineCov">      26262 :                                 ds-&gt;rate_media_size += dsize;</span>
<span class="lineNum">    7816 </span>            :                         }
<span class="lineNum">    7817 </span>            : 
<span class="lineNum">    7818 </span>            :                         //drop packet if not splitting
<span class="lineNum">    7819 </span><span class="lineCov">     122802 :                         if (!ds-&gt;split_dur_next)</span>
<span class="lineNum">    7820 </span><span class="lineCov">     122776 :                                 dasher_drop_input(ctx, ds, GF_FALSE);</span>
<span class="lineNum">    7821 </span>            : 
<span class="lineNum">    7822 </span>            :                 }
<span class="lineNum">    7823 </span>            :         }
<span class="lineNum">    7824 </span>            :         nb_init  = 0;
<span class="lineNum">    7825 </span><span class="lineCov">    5817942 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    7826 </span><span class="lineCov">    5817942 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    7827 </span>            :                 //if (ds-&gt;muxed_base) ds = ds-&gt;muxed_base;
<span class="lineNum">    7828 </span><span class="lineCov">    5817942 :                 if (ds-&gt;done || ds-&gt;subdur_done) nb_init++;</span>
<span class="lineNum">    7829 </span><span class="lineCov">    5726104 :                 else if (ds-&gt;seg_done &amp;&amp; ctx-&gt;force_period_switch) nb_init++;</span>
<span class="lineNum">    7830 </span><span class="lineCov">    5726104 :                 else if (ds-&gt;seg_done &amp;&amp; ds-&gt;muxed_base &amp;&amp; ds-&gt;muxed_base-&gt;done) {</span>
<span class="lineNum">    7831 </span><span class="lineNoCov">          0 :                         nb_init++;</span>
<span class="lineNum">    7832 </span><span class="lineNoCov">          0 :                         ds-&gt;done = 1;</span>
<span class="lineNum">    7833 </span>            :                 }
<span class="lineNum">    7834 </span>            :         }
<span class="lineNum">    7835 </span>            : 
<span class="lineNum">    7836 </span><span class="lineCov">    5720281 :         if (nb_reg_done &amp;&amp; (nb_reg_done == count)) {</span>
<span class="lineNum">    7837 </span><span class="lineNoCov">          0 :                 ctx-&gt;mpd-&gt;gpac_mpd_time = 0;</span>
<span class="lineNum">    7838 </span>            :         }
<span class="lineNum">    7839 </span>            : 
<span class="lineNum">    7840 </span><span class="lineCov">    5720281 :         dasher_format_report(filter, ctx);</span>
<span class="lineNum">    7841 </span>            : 
<span class="lineNum">    7842 </span><span class="lineCov">    5720281 :         if (seg_done) {</span>
<span class="lineNum">    7843 </span>            :                 Bool update_period = GF_FALSE;
<span class="lineNum">    7844 </span>            :                 Bool update_manifest = GF_FALSE;
<span class="lineNum">    7845 </span><span class="lineCov">       2142 :                 if (ctx-&gt;purge_segments) update_period = GF_TRUE;</span>
<span class="lineNum">    7846 </span><span class="lineCov">       2142 :                 if (ctx-&gt;mpd) {</span>
<span class="lineNum">    7847 </span>            :                         //segment timeline used, always update manifest
<span class="lineNum">    7848 </span><span class="lineCov">       2142 :                         if (ctx-&gt;stl)</span>
<span class="lineNum">    7849 </span>            :                                 update_manifest = GF_TRUE;
<span class="lineNum">    7850 </span><span class="lineCov">       2138 :                         else if (ctx-&gt;dmode==GF_DASH_DYNAMIC) {</span>
<span class="lineNum">    7851 </span>            :                                 //publish time not set, we never send the manifest, do it
<span class="lineNum">    7852 </span><span class="lineCov">        128 :                                 if (!ctx-&gt;mpd-&gt;publishTime) {</span>
<span class="lineNum">    7853 </span>            :                                         update_manifest = GF_TRUE;
<span class="lineNum">    7854 </span>            :                                 }
<span class="lineNum">    7855 </span>            :                                 //whenever we have a new seg in HLS, push new manifest
<span class="lineNum">    7856 </span><span class="lineCov">        122 :                                 else if (ctx-&gt;do_m3u8) {</span>
<span class="lineNum">    7857 </span>            :                                         update_manifest = GF_TRUE;
<span class="lineNum">    7858 </span>            :                                 }
<span class="lineNum">    7859 </span>            :                                 //we have a minimum ipdate period
<span class="lineNum">    7860 </span><span class="lineCov">         60 :                                 else if (ctx-&gt;mpd-&gt;minimum_update_period) {</span>
<span class="lineNum">    7861 </span><span class="lineCov">         60 :                                         u64 diff = dasher_get_utc(ctx) - ctx-&gt;mpd-&gt;publishTime;</span>
<span class="lineNum">    7862 </span><span class="lineCov">         60 :                                         if (diff &gt;= ctx-&gt;mpd-&gt;minimum_update_period)</span>
<span class="lineNum">    7863 </span>            :                                                 update_manifest = GF_TRUE;
<span class="lineNum">    7864 </span>            :                                 }
<span class="lineNum">    7865 </span>            :                         }
<span class="lineNum">    7866 </span><span class="lineCov">       2142 :                         if (update_period)</span>
<span class="lineNum">    7867 </span><span class="lineCov">         95 :                                 dasher_update_period_duration(ctx, GF_FALSE);</span>
<span class="lineNum">    7868 </span>            : 
<span class="lineNum">    7869 </span><span class="lineCov">       2142 :                         if (update_manifest)</span>
<span class="lineNum">    7870 </span><span class="lineCov">         85 :                                 dasher_send_manifest(filter, ctx, GF_FALSE);</span>
<span class="lineNum">    7871 </span>            :                 }
<span class="lineNum">    7872 </span><span class="lineCov">    5718139 :         } else if (ctx-&gt;force_hls_ll_manifest) {</span>
<span class="lineNum">    7873 </span><span class="lineCov">        279 :                 ctx-&gt;force_hls_ll_manifest = GF_FALSE;</span>
<span class="lineNum">    7874 </span><span class="lineCov">        279 :                 dasher_send_manifest(filter, ctx, GF_FALSE);</span>
<span class="lineNum">    7875 </span>            :         }
<span class="lineNum">    7876 </span>            : 
<span class="lineNum">    7877 </span>            :         //still some running streams in period
<span class="lineNum">    7878 </span><span class="lineCov">    5720281 :         if (count &amp;&amp; (nb_init&lt;count)) {</span>
<span class="lineNum">    7879 </span><span class="lineCov">    5662697 :                 gf_filter_post_process_task(filter);</span>
<span class="lineNum">    7880 </span><span class="lineCov">    5662697 :                 return GF_OK;</span>
<span class="lineNum">    7881 </span>            :         }
<span class="lineNum">    7882 </span>            : 
<span class="lineNum">    7883 </span>            :         //in subdur mode once we are done, flush output pids and discard all input packets
<span class="lineNum">    7884 </span>            :         //this is done at the end to be able to resume dashing when loop is requested
<span class="lineNum">    7885 </span><span class="lineCov">      57584 :         if (ctx-&gt;subdur) {</span>
<span class="lineNum">    7886 </span><span class="lineCov">        139 :                 for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    7887 </span>            :                         GF_FilterPacket *eods_pck;
<span class="lineNum">    7888 </span><span class="lineCov">        139 :                         GF_DashStream *ds = gf_list_get(ctx-&gt;current_period-&gt;streams, i);</span>
<span class="lineNum">    7889 </span><span class="lineCov">        139 :                         if (ds-&gt;done) continue;</span>
<span class="lineNum">    7890 </span><span class="lineCov">         30 :                         eods_pck = gf_filter_pck_new_alloc(ds-&gt;opid, 0, NULL);</span>
<span class="lineNum">    7891 </span><span class="lineCov">         30 :                         if (!eods_pck) return GF_OUT_OF_MEM;</span>
<span class="lineNum">    7892 </span><span class="lineCov">         30 :                         ds-&gt;done = 2;</span>
<span class="lineNum">    7893 </span><span class="lineCov">         30 :                         ds-&gt;subdur_done = GF_TRUE;</span>
<span class="lineNum">    7894 </span><span class="lineCov">         30 :                         gf_filter_pck_set_property(eods_pck, GF_PROP_PCK_EODS, &amp;PROP_BOOL(GF_TRUE) );</span>
<span class="lineNum">    7895 </span><span class="lineCov">         30 :                         gf_filter_pck_send(eods_pck);</span>
<span class="lineNum">    7896 </span>            : 
<span class="lineNum">    7897 </span><span class="lineCov">         30 :                         dasher_drop_input(ctx, ds, GF_TRUE);</span>
<span class="lineNum">    7898 </span>            :                 }
<span class="lineNum">    7899 </span>            :         }
<span class="lineNum">    7900 </span>            : 
<span class="lineNum">    7901 </span>            :         //we need to wait for full flush of packets before switching periods in order to get the
<span class="lineNum">    7902 </span>            :         //proper segment size for segment_list+byte_range mode
<span class="lineNum">    7903 </span><span class="lineCov">      57584 :         if (ctx-&gt;nb_seg_url_pending) {</span>
<span class="lineNum">    7904 </span>            :                 u64 diff;
<span class="lineNum">    7905 </span><span class="lineCov">      57042 :                 if (!ctx-&gt;last_evt_check_time) ctx-&gt;last_evt_check_time = gf_sys_clock_high_res();</span>
<span class="lineNum">    7906 </span>            : 
<span class="lineNum">    7907 </span><span class="lineCov">      57042 :                 diff = gf_sys_clock_high_res() - ctx-&gt;last_evt_check_time;</span>
<span class="lineNum">    7908 </span><span class="lineCov">      57042 :                 if (diff &lt; 10000000) {</span>
<span class="lineNum">    7909 </span><span class="lineCov">      57042 :                         gf_filter_post_process_task(filter);</span>
<span class="lineNum">    7910 </span><span class="lineCov">      57042 :                         return GF_OK;</span>
<span class="lineNum">    7911 </span>            :                 }
<span class="lineNum">    7912 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] timeout %d segment info still pending but no event from muxer after &quot;LLU&quot; us, aborting\n&quot;, ctx-&gt;nb_seg_url_pending, diff));</span>
<span class="lineNum">    7913 </span><span class="lineNoCov">          0 :                 ctx-&gt;nb_seg_url_pending = 0;</span>
<span class="lineNum">    7914 </span><span class="lineNoCov">          0 :                 return GF_SERVICE_ERROR;</span>
<span class="lineNum">    7915 </span>            :         }
<span class="lineNum">    7916 </span><span class="lineCov">        542 :         if (ctx-&gt;sseg &amp;&amp; !ctx-&gt;on_demand_done &amp;&amp; !ctx-&gt;sigfrag) {</span>
<span class="lineNum">    7917 </span>            :                 return GF_OK;
<span class="lineNum">    7918 </span>            :         }
<span class="lineNum">    7919 </span><span class="lineCov">        511 :         ctx-&gt;force_period_switch = GF_FALSE;</span>
<span class="lineNum">    7920 </span>            :         //done with this period, do period switch - this will update the MPD if needed
<span class="lineNum">    7921 </span><span class="lineCov">        511 :         e = dasher_switch_period(filter, ctx);</span>
<span class="lineNum">    7922 </span>            :         //no more periods
<span class="lineNum">    7923 </span><span class="lineCov">        511 :         if (e==GF_EOS) {</span>
<span class="lineNum">    7924 </span><span class="lineCov">        255 :                 if (!ctx-&gt;is_eos) {</span>
<span class="lineNum">    7925 </span><span class="lineCov">        255 :                         ctx-&gt;is_eos = GF_TRUE;</span>
<span class="lineNum">    7926 </span><span class="lineCov">        255 :                         gf_filter_pid_set_eos(ctx-&gt;opid);</span>
<span class="lineNum">    7927 </span>            :                 }
<span class="lineNum">    7928 </span>            :         }
<span class="lineNum">    7929 </span>            :         return e;
<span class="lineNum">    7930 </span>            : }
<span class="lineNum">    7931 </span>            : 
<a name="7932"><span class="lineNum">    7932 </span>            : </a>
<span class="lineNum">    7933 </span>            : 
<span class="lineNum">    7934 </span><span class="lineCov">         17 : static void dasher_resume_subdur(GF_Filter *filter, GF_DasherCtx *ctx)</span>
<span class="lineNum">    7935 </span>            : {
<span class="lineNum">    7936 </span>            :         GF_FilterEvent evt;
<span class="lineNum">    7937 </span>            :         u32 i, count;
<span class="lineNum">    7938 </span><span class="lineCov">         17 :         Bool is_last = (ctx-&gt;dmode == GF_MPD_TYPE_DYNAMIC_LAST) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">    7939 </span><span class="lineCov">         17 :         if (!ctx-&gt;state) return;</span>
<span class="lineNum">    7940 </span>            : 
<span class="lineNum">    7941 </span><span class="lineCov">         17 :         count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    7942 </span><span class="lineCov">         48 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    7943 </span><span class="lineCov">         31 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    7944 </span><span class="lineCov">         31 :                 ds-&gt;rep = NULL;</span>
<span class="lineNum">    7945 </span><span class="lineCov">         31 :                 if ((ds-&gt;done==1) &amp;&amp; !ctx-&gt;subdur &amp;&amp; ctx-&gt;loop) {}</span>
<span class="lineNum">    7946 </span><span class="lineCov">         31 :                 else if (ds-&gt;reschedule) {</span>
<span class="lineNum">    7947 </span>            :                         //we possibly dispatched end of stream on all outputs, we need to force unblockink to get called again
<span class="lineNum">    7948 </span><span class="lineCov">          6 :                         gf_filter_pid_discard_block(ds-&gt;opid);</span>
<span class="lineNum">    7949 </span><span class="lineCov">          6 :                         continue;</span>
<span class="lineNum">    7950 </span>            :                 }
<span class="lineNum">    7951 </span><span class="lineCov">         25 :                 else if (ds-&gt;done != 2) continue;</span>
<span class="lineNum">    7952 </span>            : 
<span class="lineNum">    7953 </span><span class="lineCov">         25 :                 if (is_last) continue;</span>
<span class="lineNum">    7954 </span>            : 
<span class="lineNum">    7955 </span><span class="lineCov">         12 :                 gf_filter_pid_set_discard(ds-&gt;ipid, GF_FALSE);</span>
<span class="lineNum">    7956 </span>            : 
<span class="lineNum">    7957 </span>            :                 //send stop and play
<span class="lineNum">    7958 </span><span class="lineCov">         12 :                 GF_FEVT_INIT(evt, GF_FEVT_STOP, ds-&gt;ipid);</span>
<span class="lineNum">    7959 </span><span class="lineCov">         12 :                 gf_filter_pid_send_event(ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">    7960 </span>            : 
<span class="lineNum">    7961 </span><span class="lineCov">         12 :                 dasher_send_encode_hints(ctx, ds);</span>
<span class="lineNum">    7962 </span><span class="lineCov">         12 :                 GF_FEVT_INIT(evt, GF_FEVT_PLAY, ds-&gt;ipid);</span>
<span class="lineNum">    7963 </span><span class="lineCov">         12 :                 evt.play.speed = 1.0;</span>
<span class="lineNum">    7964 </span><span class="lineCov">         12 :                 if (!ctx-&gt;subdur || !ctx-&gt;loop) {</span>
<span class="lineNum">    7965 </span><span class="lineCov">          2 :                         ds-&gt;seek_to_pck = 0;</span>
<span class="lineNum">    7966 </span>            :                 } else {
<span class="lineNum">    7967 </span>            :                         //request start after the last packet we processed
<span class="lineNum">    7968 </span><span class="lineCov">         10 :                         evt.play.from_pck = (u32) ds-&gt;seek_to_pck+1;</span>
<span class="lineNum">    7969 </span>            :                 }
<span class="lineNum">    7970 </span><span class="lineCov">         12 :                 gf_filter_pid_send_event(ds-&gt;ipid, &amp;evt);</span>
<span class="lineNum">    7971 </span>            : 
<span class="lineNum">    7972 </span>            :                 //full stream looping
<span class="lineNum">    7973 </span><span class="lineCov">         12 :                 if (ds-&gt;subdur_done &amp;&amp; !ctx-&gt;subdur) {</span>
<span class="lineNum">    7974 </span><span class="lineNoCov">          0 :                         ds-&gt;loop_state = 0;</span>
<span class="lineNum">    7975 </span>            :                         //mark as subdur done to force a context reload through period switch
<span class="lineNum">    7976 </span><span class="lineNoCov">          0 :                         ds-&gt;done = 2;</span>
<span class="lineNum">    7977 </span><span class="lineNoCov">          0 :                         ds-&gt;seg_done = GF_FALSE;</span>
<span class="lineNum">    7978 </span><span class="lineNoCov">          0 :                         ds-&gt;subdur_done = GF_FALSE;</span>
<span class="lineNum">    7979 </span>            :                 }
<span class="lineNum">    7980 </span>            :         }
<span class="lineNum">    7981 </span>            : 
<span class="lineNum">    7982 </span><span class="lineCov">         17 :         ctx-&gt;subdur_done = GF_FALSE;</span>
<span class="lineNum">    7983 </span><span class="lineCov">         17 :         ctx-&gt;is_eos = GF_FALSE;</span>
<span class="lineNum">    7984 </span><span class="lineCov">         17 :         if (!ctx-&gt;post_play_events &amp;&amp; !is_last) {</span>
<span class="lineNum">    7985 </span><span class="lineCov">          7 :                 ctx-&gt;current_period-&gt;period = NULL;</span>
<span class="lineNum">    7986 </span><span class="lineCov">          7 :                 ctx-&gt;first_context_load = GF_TRUE;</span>
<span class="lineNum">    7987 </span><span class="lineCov">          7 :                 ctx-&gt;post_play_events = GF_TRUE;</span>
<span class="lineNum">    7988 </span>            :         }
<span class="lineNum">    7989 </span><span class="lineCov">         17 :         gf_filter_post_process_task(filter);</span>
<a name="7990"><span class="lineNum">    7990 </span>            : }</a>
<span class="lineNum">    7991 </span>            : 
<span class="lineNum">    7992 </span><span class="lineCov">        330 : static void dasher_process_hls_ll(GF_DasherCtx *ctx, const GF_FilterEvent *evt)</span>
<span class="lineNum">    7993 </span>            : {
<span class="lineNum">    7994 </span><span class="lineCov">        330 :         u32 i, count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    7995 </span>            :         GF_DASH_SegmentContext *sctx;
<span class="lineNum">    7996 </span>            :         GF_DashStream *ds = NULL;
<span class="lineNum">    7997 </span>            : 
<span class="lineNum">    7998 </span><span class="lineCov">        330 :         if (ctx-&gt;forward_mode)</span>
<span class="lineNum">    7999 </span>            :                 return;
<span class="lineNum">    8000 </span>            : 
<span class="lineNum">    8001 </span><span class="lineCov">        330 :         if (!ctx-&gt;store_seg_states) {</span>
<span class="lineNum">    8002 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Received fragment size info event but no associated segment state\n&quot;));</span>
<span class="lineNum">    8003 </span>            :                 return;
<span class="lineNum">    8004 </span>            :         }
<span class="lineNum">    8005 </span><span class="lineCov">         90 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    8006 </span><span class="lineCov">        420 :                 ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    8007 </span><span class="lineCov">        420 :                 if (ds-&gt;opid == evt-&gt;base.on_pid) break;</span>
<span class="lineNum">    8008 </span>            :                 ds = NULL;
<span class="lineNum">    8009 </span>            :         }
<span class="lineNum">    8010 </span><span class="lineCov">        330 :         if (!ds) {</span>
<span class="lineNum">    8011 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Received fragment size info event but no associated pid\n&quot;));</span>
<span class="lineNum">    8012 </span>            :                 return;
<span class="lineNum">    8013 </span>            :         }
<span class="lineNum">    8014 </span><span class="lineCov">        330 :         if (ds-&gt;muxed_base)</span>
<span class="lineNum">    8015 </span>            :                 ds = ds-&gt;muxed_base;
<span class="lineNum">    8016 </span>            : 
<span class="lineNum">    8017 </span><span class="lineCov">        330 :         sctx = gf_list_get(ds-&gt;pending_segment_states, 0);</span>
<span class="lineNum">    8018 </span><span class="lineCov">        330 :         if (!sctx || !ctx-&gt;nb_seg_url_pending) {</span>
<span class="lineNum">    8019 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Received segment size info event but no pending segments\n&quot;));</span>
<span class="lineNum">    8020 </span>            :                 return;
<span class="lineNum">    8021 </span>            :         }
<span class="lineNum">    8022 </span><span class="lineCov">        330 :         sctx-&gt;frags = gf_realloc(sctx-&gt;frags, sizeof (GF_DASH_FragmentContext) * (sctx-&gt;nb_frags+1));</span>
<span class="lineNum">    8023 </span><span class="lineCov">        330 :         if (!sctx-&gt;frags) {</span>
<span class="lineNum">    8024 </span><span class="lineNoCov">          0 :                 sctx-&gt;nb_frags = 0;</span>
<span class="lineNum">    8025 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8026 </span>            :         }
<span class="lineNum">    8027 </span><span class="lineCov">        330 :         sctx-&gt;frags[sctx-&gt;nb_frags].size = evt-&gt;frag_size.size;</span>
<span class="lineNum">    8028 </span><span class="lineCov">        330 :         sctx-&gt;frags[sctx-&gt;nb_frags].offset = evt-&gt;frag_size.offset;</span>
<span class="lineNum">    8029 </span><span class="lineCov">        330 :         if (evt-&gt;frag_size.duration.den) {</span>
<span class="lineNum">    8030 </span><span class="lineCov">        330 :                 sctx-&gt;frags[sctx-&gt;nb_frags].duration = (u32) ((u64) evt-&gt;frag_size.duration.num * ds-&gt;rep-&gt;timescale / evt-&gt;frag_size.duration.den);</span>
<span class="lineNum">    8031 </span>            :         } else {
<span class="lineNum">    8032 </span><span class="lineNoCov">          0 :                 sctx-&gt;frags[sctx-&gt;nb_frags].duration = 0;</span>
<span class="lineNum">    8033 </span>            :         }
<span class="lineNum">    8034 </span><span class="lineCov">        330 :         sctx-&gt;frags[sctx-&gt;nb_frags].independent = evt-&gt;frag_size.independent;</span>
<span class="lineNum">    8035 </span><span class="lineCov">        330 :         sctx-&gt;nb_frags++;</span>
<span class="lineNum">    8036 </span><span class="lineCov">        330 :         if (evt-&gt;frag_size.is_last) {</span>
<span class="lineNum">    8037 </span><span class="lineCov">         51 :                 sctx-&gt;llhls_done = GF_TRUE;</span>
<span class="lineNum">    8038 </span>            :         } else {
<span class="lineNum">    8039 </span><span class="lineCov">        279 :                 ctx-&gt;force_hls_ll_manifest = GF_TRUE;</span>
<span class="lineNum">    8040 </span>            :         }
<a name="8041"><span class="lineNum">    8041 </span>            : }</a>
<span class="lineNum">    8042 </span>            : 
<span class="lineNum">    8043 </span><span class="lineCov">      27868 : static Bool dasher_process_event(GF_Filter *filter, const GF_FilterEvent *evt)</span>
<span class="lineNum">    8044 </span>            : {
<span class="lineNum">    8045 </span>            :         u32 i, count;
<span class="lineNum">    8046 </span>            :         Bool flush_mpd = GF_FALSE;
<span class="lineNum">    8047 </span><span class="lineCov">      27868 :         GF_DasherCtx *ctx = gf_filter_get_udta(filter);</span>
<span class="lineNum">    8048 </span>            : 
<span class="lineNum">    8049 </span><span class="lineCov">      27868 :         ctx-&gt;last_evt_check_time = 0;</span>
<span class="lineNum">    8050 </span>            : 
<span class="lineNum">    8051 </span><span class="lineCov">      27868 :         if (evt-&gt;base.type == GF_FEVT_RESUME) {</span>
<span class="lineNum">    8052 </span>            :                 //only process resume event when coming from main output PID, but always cancel it
<span class="lineNum">    8053 </span>            :                 //this is needed in case the output filter where the resume event was initiated consumes both
<span class="lineNum">    8054 </span>            :                 //manifest and segment PIDs, as is the case with httpout
<span class="lineNum">    8055 </span><span class="lineCov">         20 :                 if (evt-&gt;base.on_pid == ctx-&gt;opid)</span>
<span class="lineNum">    8056 </span><span class="lineCov">         17 :                         dasher_resume_subdur(filter, ctx);</span>
<span class="lineNum">    8057 </span>            :                 return GF_TRUE;
<span class="lineNum">    8058 </span>            :         }
<span class="lineNum">    8059 </span><span class="lineCov">      27848 :         if (evt-&gt;base.type == GF_FEVT_CONNECT_FAIL) {</span>
<span class="lineNum">    8060 </span><span class="lineNoCov">          0 :                 ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    8061 </span><span class="lineNoCov">          0 :                 gf_filter_pid_set_eos(ctx-&gt;opid);</span>
<span class="lineNum">    8062 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;opid_alt)</span>
<span class="lineNum">    8063 </span><span class="lineNoCov">          0 :                         gf_filter_pid_set_eos(ctx-&gt;opid_alt);</span>
<span class="lineNum">    8064 </span>            :                 return GF_TRUE;
<span class="lineNum">    8065 </span>            :         }
<span class="lineNum">    8066 </span>            : 
<span class="lineNum">    8067 </span><span class="lineCov">      27848 :         if (evt-&gt;base.type == GF_FEVT_PLAY) {</span>
<span class="lineNum">    8068 </span><span class="lineCov">        599 :                 ctx-&gt;is_playing = GF_TRUE;</span>
<span class="lineNum">    8069 </span><span class="lineCov">        599 :                 if (!ctx-&gt;sfile &amp;&amp; !ctx-&gt;stl &amp;&amp; !ctx-&gt;use_cues) {</span>
<span class="lineNum">    8070 </span>            :                         GF_FilterEvent anevt;
<span class="lineNum">    8071 </span><span class="lineCov">        452 :                         GF_FEVT_INIT(anevt, GF_FEVT_ENCODE_HINTS, NULL)</span>
<span class="lineNum">    8072 </span><span class="lineCov">        452 :                         count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    8073 </span><span class="lineCov">       1654 :                         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    8074 </span><span class="lineCov">       1202 :                                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    8075 </span><span class="lineCov">       1202 :                                 anevt.base.on_pid = ds-&gt;ipid;</span>
<span class="lineNum">    8076 </span><span class="lineCov">       1202 :                                 anevt.encode_hints.intra_period = ds-&gt;dash_dur;</span>
<span class="lineNum">    8077 </span><span class="lineCov">       1202 :                                 gf_filter_pid_send_event(ds-&gt;ipid, &amp;anevt);</span>
<span class="lineNum">    8078 </span>            :                         }
<span class="lineNum">    8079 </span>            :                 }
<span class="lineNum">    8080 </span>            :                 return GF_FALSE;
<span class="lineNum">    8081 </span>            :         }
<span class="lineNum">    8082 </span><span class="lineCov">      27249 :         if (evt-&gt;base.type == GF_FEVT_STOP) {</span>
<span class="lineNum">    8083 </span><span class="lineNoCov">          0 :                 ctx-&gt;is_playing = GF_FALSE;</span>
<span class="lineNum">    8084 </span><span class="lineNoCov">          0 :                 return GF_FALSE;</span>
<span class="lineNum">    8085 </span>            :         }
<span class="lineNum">    8086 </span>            : 
<span class="lineNum">    8087 </span><span class="lineCov">      27249 :         if (evt-&gt;base.type == GF_FEVT_FRAGMENT_SIZE) {</span>
<span class="lineNum">    8088 </span><span class="lineCov">        330 :                 dasher_process_hls_ll(ctx, evt);</span>
<span class="lineNum">    8089 </span><span class="lineCov">        330 :                 return GF_TRUE;</span>
<span class="lineNum">    8090 </span>            :         }
<span class="lineNum">    8091 </span><span class="lineCov">      26919 :         if (evt-&gt;base.type != GF_FEVT_SEGMENT_SIZE) return GF_FALSE;</span>
<span class="lineNum">    8092 </span>            : 
<span class="lineNum">    8093 </span><span class="lineCov">       3567 :         if (ctx-&gt;forward_mode==DASHER_FWD_ALL)</span>
<span class="lineNum">    8094 </span>            :                 return GF_TRUE;
<span class="lineNum">    8095 </span>            : 
<span class="lineNum">    8096 </span><span class="lineCov">       3541 :         count = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    8097 </span><span class="lineCov">      25040 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    8098 </span>            :                 u64 r_start, r_end;
<span class="lineNum">    8099 </span><span class="lineCov">      21499 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    8100 </span><span class="lineCov">      21499 :                 if (ds-&gt;opid != evt-&gt;base.on_pid) continue;</span>
<span class="lineNum">    8101 </span>            : 
<span class="lineNum">    8102 </span><span class="lineCov">       3540 :                 if (ds-&gt;muxed_base)</span>
<span class="lineNum">    8103 </span>            :                         ds = ds-&gt;muxed_base;
<span class="lineNum">    8104 </span>            : 
<span class="lineNum">    8105 </span><span class="lineCov">       3540 :                 if (ctx-&gt;store_seg_states &amp;&amp; !evt-&gt;seg_size.is_init) {</span>
<span class="lineNum">    8106 </span><span class="lineCov">        504 :                         GF_DASH_SegmentContext *sctx = gf_list_pop_front(ds-&gt;pending_segment_states);</span>
<span class="lineNum">    8107 </span><span class="lineCov">        504 :                         if (!sctx || !ctx-&gt;nb_seg_url_pending) {</span>
<span class="lineNum">    8108 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Broken muxer, received segment size info event but no pending segments\n&quot;));</span>
<span class="lineNum">    8109 </span>            :                                 return GF_TRUE;
<span class="lineNum">    8110 </span>            :                         }
<span class="lineNum">    8111 </span>            :                         assert(sctx);
<span class="lineNum">    8112 </span>            :                         assert(ctx-&gt;nb_seg_url_pending);
<span class="lineNum">    8113 </span><span class="lineCov">        504 :                         ctx-&gt;nb_seg_url_pending--;</span>
<span class="lineNum">    8114 </span><span class="lineCov">        504 :                         sctx-&gt;file_size = 1 + (u32) (evt-&gt;seg_size.media_range_end - evt-&gt;seg_size.media_range_start);</span>
<span class="lineNum">    8115 </span><span class="lineCov">        504 :                         sctx-&gt;file_offset = evt-&gt;seg_size.media_range_start;</span>
<span class="lineNum">    8116 </span><span class="lineCov">        504 :                         sctx-&gt;index_size = 1 + (u32) (evt-&gt;seg_size.idx_range_end - evt-&gt;seg_size.idx_range_start);</span>
<span class="lineNum">    8117 </span><span class="lineCov">        504 :                         sctx-&gt;index_offset = evt-&gt;seg_size.idx_range_start;</span>
<span class="lineNum">    8118 </span>            : 
<span class="lineNum">    8119 </span><span class="lineCov">        504 :                         if (sctx-&gt;llhls_mode) {</span>
<span class="lineNum">    8120 </span><span class="lineCov">         51 :                                 sctx-&gt;llhls_done = GF_TRUE;</span>
<span class="lineNum">    8121 </span>            :                                 //reset frags of past segments
<span class="lineNum">    8122 </span><span class="lineCov">         51 :                                 s32 idx, reset_until = gf_list_find(ds-&gt;rep-&gt;state_seg_list, sctx);</span>
<span class="lineNum">    8123 </span><span class="lineCov">         63 :                                 for (idx=reset_until-4; idx&gt;=0; idx--) {</span>
<span class="lineNum">    8124 </span><span class="lineCov">         18 :                                         GF_DASH_SegmentContext *prev_sctx = gf_list_get(ds-&gt;rep-&gt;state_seg_list, idx);</span>
<span class="lineNum">    8125 </span><span class="lineCov">         18 :                                         if (!prev_sctx-&gt;llhls_mode)</span>
<span class="lineNum">    8126 </span>            :                                                 break;
<span class="lineNum">    8127 </span>            : 
<span class="lineNum">    8128 </span>            :                                         //send file delete events
<span class="lineNum">    8129 </span><span class="lineCov">         12 :                                         if (prev_sctx-&gt;llhls_mode&gt;1) {</span>
<span class="lineNum">    8130 </span>            :                                                 u32 k;
<span class="lineNum">    8131 </span><span class="lineCov">         24 :                                                 for (k=0; k&lt;prev_sctx-&gt;nb_frags; k++) {</span>
<span class="lineNum">    8132 </span>            :                                                         GF_FilterEvent anevt;
<span class="lineNum">    8133 </span>            :                                                         char szPath[GF_MAX_PATH];
<span class="lineNum">    8134 </span><span class="lineCov">         20 :                                                         sprintf(szPath, &quot;%s.%d&quot;, prev_sctx-&gt;filepath, k+1);</span>
<span class="lineNum">    8135 </span><span class="lineCov">         20 :                                                         GF_FEVT_INIT(anevt, GF_FEVT_FILE_DELETE, ds-&gt;opid);</span>
<span class="lineNum">    8136 </span><span class="lineCov">         20 :                                                         anevt.file_del.url = szPath;</span>
<span class="lineNum">    8137 </span><span class="lineCov">         20 :                                                         gf_filter_pid_send_event(ds-&gt;opid, &amp;anevt);</span>
<span class="lineNum">    8138 </span>            :                                                 }
<span class="lineNum">    8139 </span>            :                                         }
<span class="lineNum">    8140 </span><span class="lineCov">         12 :                                         prev_sctx-&gt;llhls_mode = 0;</span>
<span class="lineNum">    8141 </span>            :                                 }
<span class="lineNum">    8142 </span>            :                         }
<span class="lineNum">    8143 </span>            :                 }
<span class="lineNum">    8144 </span>            : 
<span class="lineNum">    8145 </span>            :                 //in state mode we store everything
<span class="lineNum">    8146 </span>            :                 //don't set segment sizes in template mode
<span class="lineNum">    8147 </span><span class="lineCov">       3540 :                 if (ctx-&gt;tpl) continue;</span>
<span class="lineNum">    8148 </span>            :                 //only set size/index size for init segment when doing onDemand/single index
<span class="lineNum">    8149 </span><span class="lineCov">        719 :                 if (ctx-&gt;sseg &amp;&amp; !evt-&gt;seg_size.is_init) continue;</span>
<span class="lineNum">    8150 </span>            : 
<span class="lineNum">    8151 </span><span class="lineCov">        410 :                 if (evt-&gt;seg_size.media_range_end) {</span>
<span class="lineNum">    8152 </span><span class="lineCov">        387 :                         r_start = evt-&gt;seg_size.media_range_start;</span>
<span class="lineNum">    8153 </span>            :                         r_end = evt-&gt;seg_size.media_range_end;
<span class="lineNum">    8154 </span>            :                 } else {
<span class="lineNum">    8155 </span><span class="lineCov">         23 :                         r_start = evt-&gt;seg_size.idx_range_start;</span>
<span class="lineNum">    8156 </span><span class="lineCov">         23 :                         r_end = evt-&gt;seg_size.idx_range_end;</span>
<span class="lineNum">    8157 </span>            :                 }
<span class="lineNum">    8158 </span>            :                 //init segment or representation index, set it in on demand and main single source
<span class="lineNum">    8159 </span><span class="lineCov">        454 :                 if ((ctx-&gt;sfile || ctx-&gt;sseg) &amp;&amp; (evt-&gt;seg_size.is_init==1))  {</span>
<span class="lineNum">    8160 </span>            :                         GF_MPD_URL *url, **s_url;
<span class="lineNum">    8161 </span>            : 
<span class="lineNum">    8162 </span><span class="lineCov">         66 :                         if (ds-&gt;rep-&gt;segment_list) {</span>
<span class="lineNum">    8163 </span><span class="lineCov">         29 :                                 if (!evt-&gt;seg_size.media_range_start &amp;&amp; !evt-&gt;seg_size.media_range_end) {</span>
<span class="lineNum">    8164 </span><span class="lineCov">          2 :                                         if (ds-&gt;rep-&gt;segment_list-&gt;initialization_segment) {</span>
<span class="lineNum">    8165 </span><span class="lineCov">          2 :                                                 gf_mpd_url_free(ds-&gt;rep-&gt;segment_list-&gt;initialization_segment);</span>
<span class="lineNum">    8166 </span><span class="lineCov">          2 :                                                 ds-&gt;rep-&gt;segment_list-&gt;initialization_segment = NULL;</span>
<span class="lineNum">    8167 </span>            :                                         }
<span class="lineNum">    8168 </span><span class="lineCov">          2 :                                         continue;</span>
<span class="lineNum">    8169 </span>            :                                 }
<span class="lineNum">    8170 </span>            :                         }
<span class="lineNum">    8171 </span>            : 
<span class="lineNum">    8172 </span><span class="lineCov">         64 :                         if (ds-&gt;rep-&gt;segment_base &amp;&amp; !evt-&gt;seg_size.media_range_end) {</span>
<span class="lineNum">    8173 </span><span class="lineCov">         20 :                                 if (! ds-&gt;rep-&gt;segment_base-&gt;index_range) {</span>
<span class="lineNum">    8174 </span><span class="lineCov">         20 :                                         GF_SAFEALLOC(ds-&gt;rep-&gt;segment_base-&gt;index_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    8175 </span>            :                                 }
<span class="lineNum">    8176 </span><span class="lineCov">         20 :                                 if (ds-&gt;rep-&gt;segment_base-&gt;index_range) {</span>
<span class="lineNum">    8177 </span><span class="lineCov">         20 :                                         ds-&gt;rep-&gt;segment_base-&gt;index_range-&gt;start_range = r_start;</span>
<span class="lineNum">    8178 </span><span class="lineCov">         20 :                                         ds-&gt;rep-&gt;segment_base-&gt;index_range-&gt;end_range = r_end;</span>
<span class="lineNum">    8179 </span><span class="lineCov">         20 :                                         ds-&gt;rep-&gt;segment_base-&gt;index_range_exact = GF_TRUE;</span>
<span class="lineNum">    8180 </span>            :                                 }
<span class="lineNum">    8181 </span>            :                                 flush_mpd = GF_TRUE;
<span class="lineNum">    8182 </span><span class="lineCov">         20 :                                 continue;</span>
<span class="lineNum">    8183 </span>            :                         }
<span class="lineNum">    8184 </span>            : 
<span class="lineNum">    8185 </span><span class="lineCov">         44 :                         GF_SAFEALLOC(url, GF_MPD_URL);</span>
<span class="lineNum">    8186 </span><span class="lineCov">         44 :                         if (!url) return GF_TRUE;</span>
<span class="lineNum">    8187 </span>            : 
<span class="lineNum">    8188 </span><span class="lineCov">         44 :                         GF_SAFEALLOC(url-&gt;byte_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    8189 </span><span class="lineCov">         44 :                         if (!url-&gt;byte_range) return GF_TRUE;</span>
<span class="lineNum">    8190 </span><span class="lineCov">         44 :                         url-&gt;byte_range-&gt;start_range = r_start;</span>
<span class="lineNum">    8191 </span><span class="lineCov">         44 :                         url-&gt;byte_range-&gt;end_range = r_end;</span>
<span class="lineNum">    8192 </span>            : 
<span class="lineNum">    8193 </span>            :                         s_url = NULL;
<span class="lineNum">    8194 </span><span class="lineCov">         44 :                         if (ds-&gt;rep-&gt;segment_base) {</span>
<span class="lineNum">    8195 </span><span class="lineCov">         17 :                                 if (evt-&gt;seg_size.media_range_end) s_url = &amp;ds-&gt;rep-&gt;segment_base-&gt;initialization_segment;</span>
<span class="lineNum">    8196 </span>            :                         } else {
<span class="lineNum">    8197 </span>            :                                 assert(ds-&gt;rep-&gt;segment_list);
<span class="lineNum">    8198 </span><span class="lineCov">         27 :                                 if (evt-&gt;seg_size.media_range_end) s_url = &amp;ds-&gt;rep-&gt;segment_list-&gt;initialization_segment;</span>
<span class="lineNum">    8199 </span><span class="lineNoCov">          0 :                                 else s_url = &amp;ds-&gt;rep-&gt;segment_list-&gt;representation_index;</span>
<span class="lineNum">    8200 </span>            :                         }
<span class="lineNum">    8201 </span>            :                         assert(s_url);
<span class="lineNum">    8202 </span><span class="lineCov">         44 :                         if (*s_url) gf_mpd_url_free(*s_url);</span>
<span class="lineNum">    8203 </span><span class="lineCov">         44 :                         *s_url = url;</span>
<span class="lineNum">    8204 </span><span class="lineCov">        344 :                 } else if (ds-&gt;rep-&gt;segment_list &amp;&amp; !evt-&gt;seg_size.is_init) {</span>
<span class="lineNum">    8205 </span><span class="lineCov">        342 :                         GF_MPD_SegmentURL *url = gf_list_pop_front(ds-&gt;pending_segment_urls);</span>
<span class="lineNum">    8206 </span><span class="lineCov">        342 :                         if (!url || !ctx-&gt;nb_seg_url_pending) {</span>
<span class="lineNum">    8207 </span><span class="lineNoCov">          0 :                                 if (!ds-&gt;done) {</span>
<span class="lineNum">    8208 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (&quot;[Dasher] Broken muxer, received segment size info event but no pending segments\n&quot;));</span>
<span class="lineNum">    8209 </span>            :                                 }
<span class="lineNum">    8210 </span>            :                                 return GF_TRUE;
<span class="lineNum">    8211 </span>            :                         }
<span class="lineNum">    8212 </span><span class="lineCov">        342 :                         ctx-&gt;nb_seg_url_pending--;</span>
<span class="lineNum">    8213 </span>            : 
<span class="lineNum">    8214 </span><span class="lineCov">        342 :                         if (!url-&gt;media &amp;&amp; ctx-&gt;sfile) {</span>
<span class="lineNum">    8215 </span><span class="lineCov">        301 :                                 GF_SAFEALLOC(url-&gt;media_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    8216 </span><span class="lineCov">        301 :                                 if (url-&gt;media_range) {</span>
<span class="lineNum">    8217 </span><span class="lineCov">        301 :                                         url-&gt;media_range-&gt;start_range = evt-&gt;seg_size.media_range_start;</span>
<span class="lineNum">    8218 </span><span class="lineCov">        301 :                                         url-&gt;media_range-&gt;end_range = evt-&gt;seg_size.media_range_end;</span>
<span class="lineNum">    8219 </span>            :                                 }
<span class="lineNum">    8220 </span>            :                         }
<span class="lineNum">    8221 </span>            :                         //patch in test mode, old arch was not generating the index size for segment lists
<span class="lineNum">    8222 </span><span class="lineCov">        342 :                         if (evt-&gt;seg_size.idx_range_end &amp;&amp; (!gf_sys_old_arch_compat() || ctx-&gt;sfile) ) {</span>
<span class="lineNum">    8223 </span><span class="lineCov">        263 :                                 GF_SAFEALLOC(url-&gt;index_range, GF_MPD_ByteRange);</span>
<span class="lineNum">    8224 </span><span class="lineCov">        263 :                                 if (url-&gt;index_range) {</span>
<span class="lineNum">    8225 </span><span class="lineCov">        263 :                                         url-&gt;index_range-&gt;start_range = evt-&gt;seg_size.idx_range_start;</span>
<span class="lineNum">    8226 </span><span class="lineCov">        263 :                                         url-&gt;index_range-&gt;end_range = evt-&gt;seg_size.idx_range_end;</span>
<span class="lineNum">    8227 </span>            :                                 }
<span class="lineNum">    8228 </span>            :                         }
<span class="lineNum">    8229 </span>            :                 }
<span class="lineNum">    8230 </span>            :         }
<span class="lineNum">    8231 </span><span class="lineCov">       3541 :         if (!ctx-&gt;sseg || !flush_mpd) return GF_TRUE;</span>
<span class="lineNum">    8232 </span>            : 
<span class="lineNum">    8233 </span>            :         flush_mpd = GF_TRUE;
<span class="lineNum">    8234 </span><span class="lineCov">         23 :         for (i=0; i&lt;count; i++) {</span>
<span class="lineNum">    8235 </span><span class="lineCov">         26 :                 GF_DashStream *ds = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    8236 </span><span class="lineCov">         26 :                 if (!ds-&gt;rep) continue;</span>
<span class="lineNum">    8237 </span><span class="lineCov">         25 :                 if (! ds-&gt;rep-&gt;segment_base) continue;</span>
<span class="lineNum">    8238 </span><span class="lineCov">         25 :                 if (ds-&gt;rep-&gt;segment_base-&gt;index_range) continue;</span>
<span class="lineNum">    8239 </span>            :                 flush_mpd = GF_FALSE;
<span class="lineNum">    8240 </span>            :                 break;
<span class="lineNum">    8241 </span>            :         }
<span class="lineNum">    8242 </span><span class="lineCov">         20 :         if (flush_mpd) {</span>
<span class="lineNum">    8243 </span><span class="lineCov">         17 :                 ctx-&gt;on_demand_done = GF_TRUE;</span>
<span class="lineNum">    8244 </span><span class="lineCov">         17 :                 gf_filter_post_process_task(filter);</span>
<span class="lineNum">    8245 </span>            :         }
<span class="lineNum">    8246 </span>            :         return GF_TRUE;
<a name="8247"><span class="lineNum">    8247 </span>            : }</a>
<span class="lineNum">    8248 </span>            : 
<span class="lineNum">    8249 </span><span class="lineCov">        247 : static GF_Err dasher_setup_profile(GF_DasherCtx *ctx)</span>
<span class="lineNum">    8250 </span>            : {
<span class="lineNum">    8251 </span><span class="lineCov">        247 :         switch (ctx-&gt;profile) {</span>
<span class="lineNum">    8252 </span><span class="lineCov">          5 :         case GF_DASH_PROFILE_AVC264_LIVE:</span>
<span class="lineNum">    8253 </span>            :         case GF_DASH_PROFILE_AVC264_ONDEMAND:
<span class="lineNum">    8254 </span>            :         case GF_DASH_PROFILE_DASHIF_LL:
<span class="lineNum">    8255 </span><span class="lineCov">          5 :                 if (ctx-&gt;cp == GF_DASH_CPMODE_REPRESENTATION) {</span>
<span class="lineNum">    8256 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] ERROR! The selected DASH profile (DASH-IF IOP) requires the ContentProtection element to be present in the AdaptationSet element, updating.\n&quot;));</span>
<span class="lineNum">    8257 </span><span class="lineNoCov">          0 :                         ctx-&gt;cp = GF_DASH_CPMODE_ADAPTATION_SET;</span>
<span class="lineNum">    8258 </span>            :                 }
<span class="lineNum">    8259 </span>            :         default:
<span class="lineNum">    8260 </span>            :                 break;
<span class="lineNum">    8261 </span>            :         }
<span class="lineNum">    8262 </span><span class="lineCov">        247 :         if (ctx-&gt;m2ts) {</span>
<span class="lineNum">    8263 </span><span class="lineCov">          5 :                 switch (ctx-&gt;profile) {</span>
<span class="lineNum">    8264 </span><span class="lineNoCov">          0 :                 case GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:</span>
<span class="lineNum">    8265 </span>            :                 case GF_DASH_PROFILE_AVC264_LIVE:
<span class="lineNum">    8266 </span>            :                 case GF_DASH_PROFILE_DASHIF_LL:
<span class="lineNum">    8267 </span><span class="lineNoCov">          0 :                         ctx-&gt;profile = GF_DASH_PROFILE_LIVE;</span>
<span class="lineNum">    8268 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    8269 </span><span class="lineCov">          1 :                 case GF_DASH_PROFILE_ONDEMAND:</span>
<span class="lineNum">    8270 </span>            :                 case GF_DASH_PROFILE_AVC264_ONDEMAND:
<span class="lineNum">    8271 </span><span class="lineCov">          1 :                         ctx-&gt;profile = GF_DASH_PROFILE_ONDEMAND;</span>
<span class="lineNum">    8272 </span><span class="lineCov">          1 :                         break;</span>
<span class="lineNum">    8273 </span>            :                 }
<span class="lineNum">    8274 </span>            :         }
<span class="lineNum">    8275 </span>            : 
<span class="lineNum">    8276 </span>            :         /*adjust params based on profiles*/
<span class="lineNum">    8277 </span><span class="lineCov">        247 :         switch (ctx-&gt;profile) {</span>
<span class="lineNum">    8278 </span><span class="lineCov">        146 :         case GF_DASH_PROFILE_LIVE:</span>
<span class="lineNum">    8279 </span><span class="lineCov">        146 :                 ctx-&gt;sseg = ctx-&gt;sfile = GF_FALSE;</span>
<span class="lineNum">    8280 </span><span class="lineCov">        146 :                 ctx-&gt;tpl = ctx-&gt;align = ctx-&gt;sap = GF_TRUE;</span>
<span class="lineNum">    8281 </span><span class="lineCov">        146 :                 break;</span>
<span class="lineNum">    8282 </span><span class="lineNoCov">          0 :         case GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:</span>
<span class="lineNum">    8283 </span><span class="lineNoCov">          0 :                 ctx-&gt;check_main_role = GF_TRUE;</span>
<span class="lineNum">    8284 </span><span class="lineNoCov">          0 :                 ctx-&gt;bs_switch = DASHER_BS_SWITCH_MULTI;</span>
<span class="lineNum">    8285 </span>            :                 //FALLTHROUGH
<span class="lineNum">    8286 </span><span class="lineCov">          3 :         case GF_DASH_PROFILE_AVC264_LIVE:</span>
<span class="lineNum">    8287 </span><span class="lineCov">          3 :                 ctx-&gt;sseg = ctx-&gt;sfile = GF_FALSE;</span>
<span class="lineNum">    8288 </span><span class="lineCov">          3 :                 ctx-&gt;no_fragments_defaults = ctx-&gt;align = ctx-&gt;tpl = ctx-&gt;sap = GF_TRUE;</span>
<span class="lineNum">    8289 </span><span class="lineCov">          3 :                 break;</span>
<span class="lineNum">    8290 </span><span class="lineCov">          2 :         case GF_DASH_PROFILE_AVC264_ONDEMAND:</span>
<span class="lineNum">    8291 </span><span class="lineCov">          2 :                 ctx-&gt;tpl = GF_FALSE;</span>
<span class="lineNum">    8292 </span><span class="lineCov">          2 :                 ctx-&gt;no_fragments_defaults = ctx-&gt;align = ctx-&gt;sseg = ctx-&gt;sap = GF_TRUE;</span>
<span class="lineNum">    8293 </span><span class="lineCov">          2 :                 break;</span>
<span class="lineNum">    8294 </span><span class="lineCov">         17 :         case GF_DASH_PROFILE_ONDEMAND:</span>
<span class="lineNum">    8295 </span><span class="lineCov">         17 :                 ctx-&gt;sseg = ctx-&gt;align = ctx-&gt;sap = ctx-&gt;sfile = GF_TRUE;</span>
<span class="lineNum">    8296 </span><span class="lineCov">         17 :                 ctx-&gt;tpl = GF_FALSE;</span>
<span class="lineNum">    8297 </span>            : 
<span class="lineNum">    8298 </span><span class="lineCov">         17 :                 if (ctx-&gt;m2ts) {</span>
<span class="lineNum">    8299 </span><span class="lineCov">          1 :                         ctx-&gt;sseg = GF_FALSE;</span>
<span class="lineNum">    8300 </span><span class="lineCov">          1 :                         ctx-&gt;tpl = GF_TRUE;</span>
<span class="lineNum">    8301 </span><span class="lineCov">          1 :                         ctx-&gt;profile = GF_DASH_PROFILE_MAIN;</span>
<span class="lineNum">    8302 </span>            :                 } else {
<span class="lineNum">    8303 </span><span class="lineCov">         16 :                         if ((ctx-&gt;bs_switch != DASHER_BS_SWITCH_DEF) &amp;&amp; (ctx-&gt;bs_switch != DASHER_BS_SWITCH_OFF)) {</span>
<span class="lineNum">    8304 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] onDemand profile, bitstream switching mode cannot be used, defaulting to off.\n&quot;));</span>
<span class="lineNum">    8305 </span>            :                         }
<span class="lineNum">    8306 </span>            :                 }
<span class="lineNum">    8307 </span>            :                 /*BS switching is meaningless in onDemand profile*/
<span class="lineNum">    8308 </span><span class="lineCov">         17 :                 ctx-&gt;bs_switch = DASHER_BS_SWITCH_OFF;</span>
<span class="lineNum">    8309 </span><span class="lineCov">         17 :                 break;</span>
<span class="lineNum">    8310 </span><span class="lineCov">         10 :         case GF_DASH_PROFILE_MAIN:</span>
<span class="lineNum">    8311 </span><span class="lineCov">         10 :                 ctx-&gt;align = ctx-&gt;sap = GF_TRUE;</span>
<span class="lineNum">    8312 </span><span class="lineCov">         10 :                 ctx-&gt;sseg = ctx-&gt;tpl = GF_FALSE;</span>
<span class="lineNum">    8313 </span><span class="lineCov">         10 :                 break;</span>
<span class="lineNum">    8314 </span><span class="lineNoCov">          0 :         case GF_DASH_PROFILE_DASHIF_LL:</span>
<span class="lineNum">    8315 </span><span class="lineNoCov">          0 :                 ctx-&gt;sseg = ctx-&gt;sfile = GF_FALSE;</span>
<span class="lineNum">    8316 </span><span class="lineNoCov">          0 :                 ctx-&gt;no_fragments_defaults = ctx-&gt;align = ctx-&gt;tpl = ctx-&gt;sap = GF_TRUE;</span>
<span class="lineNum">    8317 </span><span class="lineNoCov">          0 :                 if (!ctx-&gt;utcs) {</span>
<span class="lineNum">    8318 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] DASH-IF LL requires UTCTiming but none specified, using http://time.akamai.com/?iso \n&quot;));</span>
<span class="lineNum">    8319 </span><span class="lineNoCov">          0 :                         ctx-&gt;utcs = gf_strdup(&quot;http://time.akamai.com/?iso&quot;);</span>
<span class="lineNum">    8320 </span>            :                 }
<span class="lineNum">    8321 </span>            :                 break;
<span class="lineNum">    8322 </span>            :         default:
<span class="lineNum">    8323 </span>            :                 break;
<span class="lineNum">    8324 </span>            :         }
<span class="lineNum">    8325 </span>            : 
<span class="lineNum">    8326 </span><span class="lineCov">        247 :         if (ctx-&gt;sseg)</span>
<span class="lineNum">    8327 </span><span class="lineCov">         18 :                 ctx-&gt;tpl = GF_FALSE;</span>
<span class="lineNum">    8328 </span>            : 
<span class="lineNum">    8329 </span><span class="lineCov">        247 :         if (ctx-&gt;bs_switch == DASHER_BS_SWITCH_DEF) {</span>
<span class="lineNum">    8330 </span><span class="lineCov">        224 :                 ctx-&gt;bs_switch = DASHER_BS_SWITCH_ON;</span>
<span class="lineNum">    8331 </span>            :         }
<span class="lineNum">    8332 </span>            : 
<span class="lineNum">    8333 </span><span class="lineCov">        247 :         if (ctx-&gt;cmaf) {</span>
<span class="lineNum">    8334 </span><span class="lineNoCov">          0 :                 ctx-&gt;align = GF_TRUE;</span>
<span class="lineNum">    8335 </span><span class="lineNoCov">          0 :                 ctx-&gt;sap = GF_TRUE;</span>
<span class="lineNum">    8336 </span>            :         }
<span class="lineNum">    8337 </span>            : 
<span class="lineNum">    8338 </span><span class="lineCov">        247 :         if (! ctx-&gt;align) {</span>
<span class="lineNum">    8339 </span><span class="lineNoCov">          0 :                 if (ctx-&gt;profile != GF_DASH_PROFILE_FULL) {</span>
<span class="lineNum">    8340 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Segments are not time-aligned in each representation of each period\n\tswitching to FULL profile\n&quot;));</span>
<span class="lineNum">    8341 </span><span class="lineNoCov">          0 :                         ctx-&gt;profile = GF_DASH_PROFILE_FULL;</span>
<span class="lineNum">    8342 </span>            :                 }
<span class="lineNum">    8343 </span>            :                 //commented out, this does not seem correct since BS switching is orthogonal to segment alignment
<span class="lineNum">    8344 </span>            :                 //one could have inband params working even in non time-aligned setup
<span class="lineNum">    8345 </span>            : #if 0
<span class="lineNum">    8346 </span>            :                 if (ctx-&gt;bs_switch != DASHER_BS_SWITCH_OFF) {
<span class="lineNum">    8347 </span>            :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Segments are not time-aligned in each representation of each period\n\tdisabling bitstream switching\n&quot;));
<span class="lineNum">    8348 </span>            :                         ctx-&gt;bs_switch = DASHER_BS_SWITCH_OFF;
<span class="lineNum">    8349 </span>            :                 }
<span class="lineNum">    8350 </span>            : #endif
<span class="lineNum">    8351 </span>            : 
<span class="lineNum">    8352 </span>            :         }
<span class="lineNum">    8353 </span>            : 
<span class="lineNum">    8354 </span>            :         //check we have a segment template
<span class="lineNum">    8355 </span><span class="lineCov">        247 :         if (!ctx-&gt;template) {</span>
<span class="lineNum">    8356 </span><span class="lineCov">        235 :                 if (!ctx-&gt;sigfrag) {</span>
<span class="lineNum">    8357 </span><span class="lineCov">        227 :                         ctx-&gt;template = gf_strdup( ctx-&gt;sfile ? &quot;$File$$FS$_dash&quot; : (ctx-&gt;stl ? &quot;$File$_dash$FS$$Time$&quot; : &quot;$File$_dash$FS$$Number$&quot;) );</span>
<span class="lineNum">    8358 </span><span class="lineCov">        227 :                         GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (&quot;[Dasher] No template assigned, using %s\n&quot;, ctx-&gt;template));</span>
<span class="lineNum">    8359 </span>            :                 }
<span class="lineNum">    8360 </span>            : 
<span class="lineNum">    8361 </span><span class="lineCov">        235 :                 if (ctx-&gt;profile == GF_DASH_PROFILE_FULL) {</span>
<span class="lineNum">    8362 </span><span class="lineCov">         19 :                         ctx-&gt;sfile = GF_TRUE;</span>
<span class="lineNum">    8363 </span>            :                 }
<span class="lineNum">    8364 </span>            :         }
<span class="lineNum">    8365 </span>            :         //backward compatibility with old arch using %s
<span class="lineNum">    8366 </span>            :         else {
<span class="lineNum">    8367 </span><span class="lineCov">         12 :                 char *sep = strstr(ctx-&gt;template, &quot;%s&quot;);</span>
<span class="lineNum">    8368 </span><span class="lineCov">         12 :                 if (sep) {</span>
<span class="lineNum">    8369 </span><span class="lineNoCov">          0 :                         char *new_template = NULL;</span>
<span class="lineNum">    8370 </span><span class="lineNoCov">          0 :                         sep[0] = 0;</span>
<span class="lineNum">    8371 </span><span class="lineNoCov">          0 :                         gf_dynstrcat(&amp;new_template, ctx-&gt;template, NULL);</span>
<span class="lineNum">    8372 </span><span class="lineNoCov">          0 :                         gf_dynstrcat(&amp;new_template, &quot;$File$&quot;, NULL);</span>
<span class="lineNum">    8373 </span><span class="lineNoCov">          0 :                         gf_dynstrcat(&amp;new_template, sep+2, NULL);</span>
<span class="lineNum">    8374 </span><span class="lineNoCov">          0 :                         gf_free(ctx-&gt;template);</span>
<span class="lineNum">    8375 </span><span class="lineNoCov">          0 :                         ctx-&gt;template = new_template;</span>
<span class="lineNum">    8376 </span>            :                 }
<span class="lineNum">    8377 </span>            : 
<span class="lineNum">    8378 </span>            :         }
<span class="lineNum">    8379 </span><span class="lineCov">        247 :         return GF_OK;</span>
<a name="8380"><span class="lineNum">    8380 </span>            : }</a>
<span class="lineNum">    8381 </span>            : 
<span class="lineNum">    8382 </span><span class="lineCov">        244 : static GF_Err dasher_initialize(GF_Filter *filter)</span>
<span class="lineNum">    8383 </span>            : {
<span class="lineNum">    8384 </span>            :         GF_Err e;
<span class="lineNum">    8385 </span><span class="lineCov">        244 :         GF_DasherCtx *ctx = gf_filter_get_udta(filter);</span>
<span class="lineNum">    8386 </span><span class="lineCov">        244 :         gf_filter_set_max_extra_input_pids(filter, -1);</span>
<span class="lineNum">    8387 </span>            : 
<span class="lineNum">    8388 </span><span class="lineCov">        244 :         ctx-&gt;pids = gf_list_new();</span>
<span class="lineNum">    8389 </span><span class="lineCov">        244 :         ctx-&gt;postponed_pids = gf_list_new();</span>
<span class="lineNum">    8390 </span><span class="lineCov">        244 :         ctx-&gt;tpl_records = gf_list_new();</span>
<span class="lineNum">    8391 </span>            : 
<span class="lineNum">    8392 </span><span class="lineCov">        244 :         if (!ctx-&gt;initext &amp;&amp; (ctx-&gt;muxtype==DASHER_MUX_AUTO))</span>
<span class="lineNum">    8393 </span><span class="lineCov">        234 :                 ctx-&gt;muxtype = DASHER_MUX_ISOM;</span>
<span class="lineNum">    8394 </span>            : 
<span class="lineNum">    8395 </span><span class="lineCov">        244 :         if ((ctx-&gt;segdur.num &lt;= 0) || !ctx-&gt;segdur.den) {</span>
<span class="lineNum">    8396 </span><span class="lineCov">         54 :                 ctx-&gt;segdur.num = 1;</span>
<span class="lineNum">    8397 </span><span class="lineCov">         54 :                 ctx-&gt;segdur.den = 1;</span>
<span class="lineNum">    8398 </span><span class="lineCov">         54 :                 ctx-&gt;no_seg_dur = GF_TRUE;</span>
<span class="lineNum">    8399 </span>            :         }
<span class="lineNum">    8400 </span>            : 
<span class="lineNum">    8401 </span><span class="lineCov">        244 :         e = dasher_setup_profile(ctx);</span>
<span class="lineNum">    8402 </span><span class="lineCov">        244 :         if (e) return e;</span>
<span class="lineNum">    8403 </span>            : 
<span class="lineNum">    8404 </span><span class="lineCov">        244 :         if (ctx-&gt;sfile &amp;&amp; ctx-&gt;tpl)</span>
<span class="lineNum">    8405 </span><span class="lineCov">         21 :                 ctx-&gt;tpl = GF_FALSE;</span>
<span class="lineNum">    8406 </span>            : 
<span class="lineNum">    8407 </span><span class="lineCov">        244 :         ctx-&gt;current_period = dasher_new_period();</span>
<span class="lineNum">    8408 </span><span class="lineCov">        244 :         ctx-&gt;next_period = dasher_new_period();</span>
<span class="lineNum">    8409 </span><span class="lineCov">        244 :         ctx-&gt;on_demand_done = GF_TRUE;</span>
<span class="lineNum">    8410 </span>            : 
<span class="lineNum">    8411 </span><span class="lineCov">        244 :         if (ctx-&gt;state) {</span>
<span class="lineNum">    8412 </span><span class="lineCov">         14 :                 ctx-&gt;first_context_load = GF_TRUE;</span>
<span class="lineNum">    8413 </span>            :         }
<span class="lineNum">    8414 </span><span class="lineCov">        244 :         if (ctx-&gt;subdur &amp;&amp; !ctx-&gt;state) {</span>
<span class="lineNum">    8415 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] subdur mode specified but no context set, will only dash %g seconds of media\n&quot;, ctx-&gt;subdur));</span>
<span class="lineNum">    8416 </span>            :         }
<span class="lineNum">    8417 </span>            :         //we build manifest from input frag/seg, always use single frag
<span class="lineNum">    8418 </span><span class="lineCov">        244 :         if (ctx-&gt;sigfrag) {</span>
<span class="lineNum">    8419 </span><span class="lineCov">          6 :                 if (ctx-&gt;tpl) {</span>
<span class="lineNum">    8420 </span><span class="lineCov">          4 :                         if (!ctx-&gt;template) {</span>
<span class="lineNum">    8421 </span><span class="lineCov">          3 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] Warning, manifest generation only mode requested for live-based profile but no template provided, switching to main profile.\n&quot;));</span>
<span class="lineNum">    8422 </span><span class="lineCov">          3 :                                 ctx-&gt;profile = GF_DASH_PROFILE_MAIN;</span>
<span class="lineNum">    8423 </span><span class="lineCov">          3 :                                 ctx-&gt;tpl = GF_FALSE;</span>
<span class="lineNum">    8424 </span><span class="lineCov">          3 :                                 dasher_setup_profile(ctx);</span>
<span class="lineNum">    8425 </span>            :                                 //we force single file in this mode, but we will replace byte ranges by source URL
<span class="lineNum">    8426 </span><span class="lineCov">          3 :                                 ctx-&gt;sfile = GF_TRUE;</span>
<span class="lineNum">    8427 </span>            :                         } else {
<span class="lineNum">    8428 </span><span class="lineCov">          1 :                                 ctx-&gt;sseg = GF_FALSE;</span>
<span class="lineNum">    8429 </span><span class="lineCov">          1 :                                 ctx-&gt;sfile = GF_FALSE;</span>
<span class="lineNum">    8430 </span>            :                         }
<span class="lineNum">    8431 </span>            :                 } else {
<span class="lineNum">    8432 </span><span class="lineCov">          2 :                         if (!ctx-&gt;sseg)</span>
<span class="lineNum">    8433 </span><span class="lineCov">          1 :                                 ctx-&gt;sfile = GF_TRUE;</span>
<span class="lineNum">    8434 </span>            :                 }
<span class="lineNum">    8435 </span>            :         }
<span class="lineNum">    8436 </span>            : 
<span class="lineNum">    8437 </span><span class="lineCov">        244 :         if (!ctx-&gt;sap || ctx-&gt;sigfrag || ctx-&gt;cues)</span>
<span class="lineNum">    8438 </span><span class="lineCov">         19 :                 ctx-&gt;sbound = DASHER_BOUNDS_OUT;</span>
<span class="lineNum">    8439 </span>            : 
<span class="lineNum">    8440 </span><span class="lineCov">        244 :         if ((ctx-&gt;tsb&gt;=0) &amp;&amp; (ctx-&gt;dmode!=GF_DASH_STATIC))</span>
<span class="lineNum">    8441 </span><span class="lineCov">         20 :                 ctx-&gt;purge_segments = GF_TRUE;</span>
<span class="lineNum">    8442 </span>            : 
<span class="lineNum">    8443 </span><span class="lineCov">        244 :         if (ctx-&gt;state &amp;&amp; ctx-&gt;sreg) {</span>
<span class="lineNum">    8444 </span>            :                 u32 diff;
<span class="lineNum">    8445 </span>            :                 u64 next_gen_ntp;
<span class="lineNum">    8446 </span>            :                 GF_Err dash_state_check_timing(const char *dash_state, u64 *next_gen_ntp_ms, u32 *next_time_ms);
<span class="lineNum">    8447 </span>            : 
<span class="lineNum">    8448 </span><span class="lineNoCov">          0 :                 e = dash_state_check_timing(ctx-&gt;state, &amp;next_gen_ntp, &amp;diff);</span>
<span class="lineNum">    8449 </span><span class="lineNoCov">          0 :                 if (e&lt;0) return e;</span>
<span class="lineNum">    8450 </span><span class="lineNoCov">          0 :                 if (e==GF_EOS) {</span>
<span class="lineNum">    8451 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (&quot;[Dasher] generation called too early by %d ms\n&quot;, (s32) diff));</span>
<span class="lineNum">    8452 </span>            :                         return e;
<span class="lineNum">    8453 </span>            :                 }
<span class="lineNum">    8454 </span>            :         }
<span class="lineNum">    8455 </span>            :         return GF_OK;
<span class="lineNum">    8456 </span>            : }
<a name="8457"><span class="lineNum">    8457 </span>            : </a>
<span class="lineNum">    8458 </span>            : 
<span class="lineNum">    8459 </span><span class="lineCov">        244 : static void dasher_finalize(GF_Filter *filter)</span>
<span class="lineNum">    8460 </span>            : {
<span class="lineNum">    8461 </span><span class="lineCov">        244 :         GF_DasherCtx *ctx = gf_filter_get_udta(filter);</span>
<span class="lineNum">    8462 </span>            : 
<span class="lineNum">    8463 </span><span class="lineCov">        845 :         while (gf_list_count(ctx-&gt;pids)) {</span>
<span class="lineNum">    8464 </span><span class="lineCov">        357 :                 GF_DashStream *ds = gf_list_pop_back(ctx-&gt;pids);</span>
<span class="lineNum">    8465 </span><span class="lineCov">        357 :                 dasher_reset_stream(filter, ds, GF_TRUE);</span>
<span class="lineNum">    8466 </span><span class="lineCov">        357 :                 if (ds-&gt;packet_queue) gf_list_del(ds-&gt;packet_queue);</span>
<span class="lineNum">    8467 </span><span class="lineCov">        357 :                 if (ds-&gt;cinfo) gf_crypt_info_del(ds-&gt;cinfo);</span>
<span class="lineNum">    8468 </span><span class="lineCov">        357 :                 gf_free(ds);</span>
<span class="lineNum">    8469 </span>            :         }
<span class="lineNum">    8470 </span><span class="lineCov">        244 :         gf_list_del(ctx-&gt;pids);</span>
<span class="lineNum">    8471 </span><span class="lineCov">        244 :         if (ctx-&gt;mpd) gf_mpd_del(ctx-&gt;mpd);</span>
<span class="lineNum">    8472 </span>            : 
<span class="lineNum">    8473 </span><span class="lineCov">        590 :         while (gf_list_count(ctx-&gt;tpl_records)) {</span>
<span class="lineNum">    8474 </span><span class="lineCov">        346 :                 DashTemplateRecord *tr = gf_list_pop_back(ctx-&gt;tpl_records);</span>
<span class="lineNum">    8475 </span><span class="lineCov">        346 :                 gf_free(tr-&gt;tpl);</span>
<span class="lineNum">    8476 </span><span class="lineCov">        346 :                 gf_free(tr);</span>
<span class="lineNum">    8477 </span>            :         }
<span class="lineNum">    8478 </span><span class="lineCov">        244 :         gf_list_del(ctx-&gt;tpl_records);</span>
<span class="lineNum">    8479 </span>            : 
<span class="lineNum">    8480 </span><span class="lineCov">        244 :         if (ctx-&gt;next_period-&gt;period) gf_mpd_period_free(ctx-&gt;next_period-&gt;period);</span>
<span class="lineNum">    8481 </span><span class="lineCov">        244 :         gf_list_del(ctx-&gt;current_period-&gt;streams);</span>
<span class="lineNum">    8482 </span><span class="lineCov">        244 :         gf_free(ctx-&gt;current_period);</span>
<span class="lineNum">    8483 </span><span class="lineCov">        244 :         gf_list_del(ctx-&gt;next_period-&gt;streams);</span>
<span class="lineNum">    8484 </span><span class="lineCov">        244 :         gf_free(ctx-&gt;next_period);</span>
<span class="lineNum">    8485 </span><span class="lineCov">        244 :         if (ctx-&gt;out_path) gf_free(ctx-&gt;out_path);</span>
<span class="lineNum">    8486 </span><span class="lineCov">        244 :         gf_list_del(ctx-&gt;postponed_pids);</span>
<span class="lineNum">    8487 </span><span class="lineCov">        244 :         if (ctx-&gt;cinfo) gf_crypt_info_del(ctx-&gt;cinfo);</span>
<span class="lineNum">    8488 </span><span class="lineCov">        244 : }</span>
<span class="lineNum">    8489 </span>            : 
<span class="lineNum">    8490 </span>            : #define MPD_EXTS &quot;mpd|m3u8|3gm|ism&quot;
<span class="lineNum">    8491 </span>            : #define MPD_MIMES &quot;application/dash+xml|video/vnd.3gpp.mpd|audio/vnd.3gpp.mpd|video/vnd.mpeg.dash.mpd|audio/vnd.mpeg.dash.mpd|audio/mpegurl|video/mpegurl|application/vnd.ms-sstr+xml&quot;
<span class="lineNum">    8492 </span>            : 
<span class="lineNum">    8493 </span>            : static const GF_FilterCapability DasherCaps[] =
<span class="lineNum">    8494 </span>            : {
<span class="lineNum">    8495 </span>            :         //we accept files as input, but only for NULL file (no source)
<span class="lineNum">    8496 </span>            :         CAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    8497 </span>            :         //only with no source
<span class="lineNum">    8498 </span>            :         CAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_URL, &quot;*&quot;),
<span class="lineNum">    8499 </span>            :         CAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FILEPATH, &quot;*&quot;),
<span class="lineNum">    8500 </span>            : 
<span class="lineNum">    8501 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    8502 </span>            :         CAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),
<span class="lineNum">    8503 </span>            :         CAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),
<span class="lineNum">    8504 </span>            :         {0},
<span class="lineNum">    8505 </span>            :         //anything AV pid framed result in manifest PID
<span class="lineNum">    8506 </span>            :         CAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),
<span class="lineNum">    8507 </span>            :         CAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),
<span class="lineNum">    8508 </span>            :         CAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_NONE),
<span class="lineNum">    8509 </span>            :         CAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),
<span class="lineNum">    8510 </span>            : 
<span class="lineNum">    8511 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    8512 </span>            :         CAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),
<span class="lineNum">    8513 </span>            :         CAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),
<span class="lineNum">    8514 </span>            :         {0},
<span class="lineNum">    8515 </span>            :         //anything else (not file, not AV and framed) in compressed format result in manifest PID
<span class="lineNum">    8516 </span>            :         //we cannot handle RAW format for such streams as these are in-memory data (scene graph, decoded text, etc ..)
<span class="lineNum">    8517 </span>            :         CAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    8518 </span>            :         CAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),
<span class="lineNum">    8519 </span>            :         CAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),
<span class="lineNum">    8520 </span>            :         CAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),
<span class="lineNum">    8521 </span>            :         CAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),
<span class="lineNum">    8522 </span>            : 
<span class="lineNum">    8523 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    8524 </span>            :         CAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),
<span class="lineNum">    8525 </span>            :         CAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),
<span class="lineNum">    8526 </span>            :         {0},
<span class="lineNum">    8527 </span>            :         //anything else (not file and framed) result in media pids not file
<span class="lineNum">    8528 </span>            :         CAP_UINT(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    8529 </span>            :         CAP_UINT(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_CODECID, GF_CODECID_NONE),
<span class="lineNum">    8530 </span>            :         CAP_BOOL(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_UNFRAMED, GF_TRUE),
<span class="lineNum">    8531 </span>            :         CAP_UINT(GF_CAPS_OUTPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),
<span class="lineNum">    8532 </span>            : 
<span class="lineNum">    8533 </span>            : };
<span class="lineNum">    8534 </span>            : 
<span class="lineNum">    8535 </span>            : 
<span class="lineNum">    8536 </span>            : #define OFFS(_n)        #_n, offsetof(GF_DasherCtx, _n)
<span class="lineNum">    8537 </span>            : static const GF_FilterArgs DasherArgs[] =
<span class="lineNum">    8538 </span>            : {
<span class="lineNum">    8539 </span>            :         { OFFS(segdur), &quot;target segment duration in seconds. A value less than or equal to 0 means to 1.0 second&quot;, GF_PROP_FRACTION, &quot;0/0&quot;, NULL, 0},
<span class="lineNum">    8540 </span>            :         { OFFS(tpl), &quot;use template mode (multiple segment, template URLs)&quot;, GF_PROP_BOOL, &quot;true&quot;, NULL, 0},
<span class="lineNum">    8541 </span>            :         { OFFS(stl), &quot;use segment timeline (ignored in on_demand mode)&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, 0},
<span class="lineNum">    8542 </span>            :         { OFFS(dmode), &quot;dash content mode\n&quot;
<span class="lineNum">    8543 </span>            :                 &quot;- static: static content\n&quot;
<span class="lineNum">    8544 </span>            :                 &quot;- dynamic: live generation\n&quot;
<span class="lineNum">    8545 </span>            :                 &quot;- dynlast: last call for live, will turn the MPD into static&quot;
<span class="lineNum">    8546 </span>            :                 &quot;&quot;, GF_PROP_UINT, &quot;static&quot;, &quot;static|dynamic|dynlast&quot;, GF_FS_ARG_UPDATE},
<span class="lineNum">    8547 </span>            :         { OFFS(sseg), &quot;single segment is used&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8548 </span>            :         { OFFS(sfile), &quot;use a single file for all segments (default in on_demand)&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8549 </span>            :         { OFFS(align), &quot;enable segment time alignment between representations&quot;, GF_PROP_BOOL, &quot;true&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8550 </span>            :         { OFFS(sap), &quot;enable splitting segments at SAP boundaries&quot;, GF_PROP_BOOL, &quot;true&quot;, NULL, 0},
<span class="lineNum">    8551 </span>            :         { OFFS(mix_codecs), &quot;enable mixing different codecs in an adaptation set&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8552 </span>            :         { OFFS(ntp), &quot;insert/override NTP clock at the beginning of each segment\n&quot;
<span class="lineNum">    8553 </span>            :         &quot;- rem: removes NTP from all input packets\n&quot;
<span class="lineNum">    8554 </span>            :         &quot;- yes: inserts NTP at each segment start\n&quot;
<span class="lineNum">    8555 </span>            :         &quot;- keep: leaves input packet NTP untouched&quot;, GF_PROP_UINT, &quot;rem&quot;, &quot;rem|yes|keep&quot;, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8556 </span>            :         { OFFS(no_sar), &quot;do not check for identical sample aspect ratio for adaptation sets&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8557 </span>            :         { OFFS(m2ts), &quot;generate MPEG-2 TS output&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, 0},
<span class="lineNum">    8558 </span>            :         { OFFS(bs_switch), &quot;bitstream switching mode (single init segment)\n&quot;
<span class="lineNum">    8559 </span>            :         &quot;- def: resolves to off for onDemand and inband for live\n&quot;
<span class="lineNum">    8560 </span>            :         &quot;- off: disables BS switching\n&quot;
<span class="lineNum">    8561 </span>            :         &quot;- on: enables it if same decoder configuration is possible\n&quot;
<span class="lineNum">    8562 </span>            :         &quot;- inband: moves decoder config inband if possible\n&quot;
<span class="lineNum">    8563 </span>            :         &quot;- force: enables it even if only one representation\n&quot;
<span class="lineNum">    8564 </span>            :         &quot;- multi: uses multiple stsd entries in ISOBMFF&quot;, GF_PROP_UINT, &quot;def&quot;, &quot;def|off|on|inband|force|multi&quot;, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8565 </span>            :         { OFFS(template), &quot;template string to use to generate segment name - see filter help&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8566 </span>            :         { OFFS(segext), &quot;file extension to use for segments&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8567 </span>            :         { OFFS(initext), &quot;file extension to use for the init segment&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8568 </span>            :         { OFFS(muxtype), &quot;muxtype to use for the segments\n&quot;
<span class="lineNum">    8569 </span>            :                 &quot;- mp4: uses ISOBMFF format\n&quot;
<span class="lineNum">    8570 </span>            :                 &quot;- ts: uses MPEG-2 TS format\n&quot;
<span class="lineNum">    8571 </span>            :                 &quot;- mkv: uses Matroska format\n&quot;
<span class="lineNum">    8572 </span>            :                 &quot;- webm: uses WebM format\n&quot;
<span class="lineNum">    8573 </span>            :                 &quot;- ogg: uses OGG format\n&quot;
<span class="lineNum">    8574 </span>            :                 &quot;- raw: uses raw media format (disables muxed representations)\n&quot;
<span class="lineNum">    8575 </span>            :                 &quot;- auto: guess format based on extension, default to mp4 if no extension&quot;, GF_PROP_UINT, &quot;auto&quot;, &quot;mp4|ts|mkv|webm|ogg|raw|auto&quot;, 0},
<span class="lineNum">    8576 </span>            :         { OFFS(asto), &quot;availabilityStartTimeOffset to use in seconds. A negative value simply increases the AST, a positive value sets the ASToffset to representations&quot;, GF_PROP_DOUBLE, &quot;0&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8577 </span>            :         { OFFS(profile), &quot;target DASH profile. This will set default option values to ensure conformance to the desired profile. For MPEG-2 TS, only main and live are used, others default to main\n&quot;
<span class="lineNum">    8578 </span>            :                 &quot;- auto: turns profile to live for dynamic and full for non-dynamic\n&quot;
<span class="lineNum">    8579 </span>            :                 &quot;- live: DASH live profile, using segment template\n&quot;
<span class="lineNum">    8580 </span>            :                 &quot;- onDemand: MPEG-DASH live profile\n&quot;
<span class="lineNum">    8581 </span>            :                 &quot;- main: MPEG-DASH main profile, using segment list\n&quot;
<span class="lineNum">    8582 </span>            :                 &quot;- full: MPEG-DASH full profile\n&quot;
<span class="lineNum">    8583 </span>            :                 &quot;- hbbtv1.5.live: HBBTV 1.5 DASH profile\n&quot;
<span class="lineNum">    8584 </span>            :                 &quot;- dashavc264.live: DASH-IF live profile\n&quot;
<span class="lineNum">    8585 </span>            :                 &quot;- dashavc264.onDemand: DASH-IF onDemand profile\n&quot;
<span class="lineNum">    8586 </span>            :                 &quot;- dashif.ll: DASH IF low-latency profile (set UTC server to time.akamai.com if none set)&quot;
<span class="lineNum">    8587 </span>            :                 &quot;&quot;, GF_PROP_UINT, &quot;auto&quot;, &quot;auto|live|onDemand|main|full|hbbtv1.5.live|dashavc264.live|dashavc264.onDemand|dashif.ll&quot;, 0 },
<span class="lineNum">    8588 </span>            :         { OFFS(profX), &quot;list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED },
<span class="lineNum">    8589 </span>            :         { OFFS(cp), &quot;content protection element location\n&quot;
<span class="lineNum">    8590 </span>            :         &quot;- set: in adaptation set element\n&quot;
<span class="lineNum">    8591 </span>            :         &quot;- rep: in representation element\n&quot;
<span class="lineNum">    8592 </span>            :         &quot;- both: in both adaptation set and representation elements&quot;
<span class="lineNum">    8593 </span>            :         &quot;&quot;, GF_PROP_UINT, &quot;set&quot;, &quot;set|rep|both&quot;, GF_FS_ARG_HINT_ADVANCED },
<span class="lineNum">    8594 </span>            :         { OFFS(pssh), &quot;storage mode for PSSH box\n&quot;
<span class="lineNum">    8595 </span>            :         &quot;- f: stores in movie fragment only\n&quot;
<span class="lineNum">    8596 </span>            :         &quot;- v: stores in movie only\n&quot;
<span class="lineNum">    8597 </span>            :         &quot;- m: stores in mpd only\n&quot;
<span class="lineNum">    8598 </span>            :         &quot;- mf: stores in mpd and movie fragment\n&quot;
<span class="lineNum">    8599 </span>            :         &quot;- mv: stores in mpd and movie\n&quot;
<span class="lineNum">    8600 </span>            :         &quot;- n: discard pssh from mpd and segments&quot;, GF_PROP_UINT, &quot;v&quot;, &quot;v|f|mv|mf|m|n&quot;, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8601 </span>            :         { OFFS(buf), &quot;min buffer duration in ms. negative value means percent of segment duration (eg -150 = 1.5*seg_dur)&quot;, GF_PROP_SINT, &quot;-100&quot;, NULL, 0},
<span class="lineNum">    8602 </span>            :         { OFFS(timescale), &quot;set timescale for timeline and segment list/template. A value of 0 picks up the first timescale of the first stream in an adaptation set. A negative value forces using stream timescales for each timed element (multiplication of segment list/template/timelines). A positive value enforces the MPD timescale&quot;, GF_PROP_SINT, &quot;0&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8603 </span>            :         { OFFS(check_dur), &quot;check duration of sources in period, trying to have roughly equal duration. Enforced whenever period start times are used&quot;, GF_PROP_BOOL, &quot;true&quot;, NULL, 0},
<span class="lineNum">    8604 </span>            :         { OFFS(skip_seg), &quot;increment segment number whenever an empty segment would be produced - NOT DASH COMPLIANT&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8605 </span>            :         { OFFS(title), &quot;MPD title&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8606 </span>            :         { OFFS(source), &quot;MPD Source&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8607 </span>            :         { OFFS(info), &quot;MPD info url&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8608 </span>            :         { OFFS(cprt), &quot;MPD copyright string&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8609 </span>            :         { OFFS(lang), &quot;language of MPD Info&quot;, GF_PROP_STRING, NULL, NULL, 0},
<span class="lineNum">    8610 </span>            :         { OFFS(location), &quot;set MPD locations to given URL&quot;, GF_PROP_STRING_LIST, NULL, NULL, 0},
<span class="lineNum">    8611 </span>            :         { OFFS(base), &quot;set base URLs of MPD&quot;, GF_PROP_STRING_LIST, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8612 </span>            :         { OFFS(refresh), &quot;refresh rate for dynamic manifests, in seconds. A negative value sets the MPD duration. If 0, uses dash duration&quot;, GF_PROP_DOUBLE, &quot;0&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8613 </span>            :         { OFFS(tsb), &quot;time-shift buffer depth in seconds. A negative value means infinity&quot;, GF_PROP_DOUBLE, &quot;30&quot;, NULL, 0},
<span class="lineNum">    8614 </span>            :         { OFFS(subdur), &quot;maximum duration of the input file to be segmented. This does not change the segment duration, segmentation stops once segments produced exceeded the duration&quot;, GF_PROP_DOUBLE, &quot;0&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8615 </span>            :         { OFFS(ast), &quot;set start date (as xs:date, eg YYYY-MM-DDTHH:MM:SSZ) for live mode. Default is now. !! Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size !!&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8616 </span>            :         { OFFS(state), &quot;path to file used to store/reload state info when simulating live. This is stored as a valid MPD with GPAC XML extensions&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8617 </span>            :         { OFFS(loop), &quot;loop sources when dashing with subdur and state. If not set, a new period is created once the sources are over&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8618 </span>            :         { OFFS(split), &quot;enable cloning samples for text/metadata/scene description streams, marking further clones as redundant&quot;, GF_PROP_BOOL, &quot;true&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8619 </span>            :         { OFFS(hlsc), &quot;insert clock reference in variant playlist in live HLS&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8620 </span>            :         { OFFS(cues), &quot;set cue file - see filter help&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8621 </span>            :         { OFFS(strict_cues), &quot;strict mode for cues, complains if splitting is not on SAP type 1/2/3 or if unused cue is found&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8622 </span>            :         { OFFS(strict_sap), &quot;strict mode for sap\n&quot;
<span class="lineNum">    8623 </span>            :         &quot;- off: ignore SAP types for PID other than video, enforcing _startsWithSAP=1_\n&quot;
<span class="lineNum">    8624 </span>            :         &quot;- sig: same as [-off]() but keep _startsWithSAP_ to the true SAP value\n&quot;
<span class="lineNum">    8625 </span>            :         &quot;- on: warn if any PID uses SAP 3 or 4 and switch to FULL profile&quot;, GF_PROP_UINT, &quot;off&quot;, &quot;off|sig|on&quot;, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8626 </span>            : 
<span class="lineNum">    8627 </span>            :         { OFFS(subs_sidx), &quot;number of subsegments per sidx. negative value disables sidx. Only used to inherit sidx option of destination&quot;, GF_PROP_SINT, &quot;-1&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8628 </span>            :         { OFFS(cmpd), &quot;skip line feed and spaces in MPD XML for compactness&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8629 </span>            :         { OFFS(styp), &quot;indicate the 4CC to use for styp boxes when using ISOBMFF output&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8630 </span>            :         { OFFS(dual), &quot;indicate to produce both MPD and M3U files&quot;, GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8631 </span>            :         { OFFS(sigfrag), &quot;use manifest generation only mode - see filter help&quot;, GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8632 </span>            :         { OFFS(_p_gentime), &quot;pointer to u64 holding the ntp clock in ms of next DASH generation in live mode&quot;, GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},
<span class="lineNum">    8633 </span>            :         { OFFS(_p_mpdtime), &quot;pointer to u64 holding the mpd time in ms of the last generated segment&quot;, GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},
<span class="lineNum">    8634 </span>            :         { OFFS(sbound), &quot;indicate how the theoretical segment start `TSS (= segment_number * duration)` should be handled\n&quot;
<span class="lineNum">    8635 </span>            :                                 &quot;- out: segment split as soon as `TSS` is exceeded (`TSS` &lt;= segment_start)\n&quot;
<span class="lineNum">    8636 </span>            :                                 &quot;- closest: segment split at closest SAP to theoretical bound\n&quot;
<span class="lineNum">    8637 </span>            :                                 &quot;- in: `TSS` is always in segment (`TSS` &gt;= segment_start)&quot;, GF_PROP_UINT, &quot;out&quot;, &quot;out|closest|in&quot;, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8638 </span>            :         { OFFS(reschedule), &quot;reschedule sources with no period ID assigned once done (dynamic mode only)&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8639 </span>            :         { OFFS(sreg), &quot;regulate the session\n&quot;
<span class="lineNum">    8640 </span>            :         &quot;- when using subdur and context, only generate segments from the past up to live edge\n&quot;
<span class="lineNum">    8641 </span>            :         &quot;- otherwise in dynamic mode without context, do not generate segments ahead of time&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8642 </span>            :         { OFFS(scope_deps), &quot;scope PID dependencies to be within source. If disabled, PID dependencies will be checked across all input PIDs regardless of their sources&quot;, GF_PROP_BOOL, &quot;true&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8643 </span>            :         { OFFS(utcs), &quot;URL to use as time server / UTCTiming source. Special value `inband` enables inband UTC (same as publishTime), special prefix `xsd@` uses xsDateTime schemeURI rather than ISO&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8644 </span>            :         { OFFS(force_flush), &quot;force generating a single segment for each input. This can be useful in batch mode when average source duration is known and used as segment duration but actual duration may sometimes be greater&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8645 </span>            :         { OFFS(last_seg_merge), &quot;force merging last segment if less than half the target duration&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8646 </span>            :         { OFFS(mha_compat), &quot;adaptation set generation mode for compatible MPEG-H Audio profile\n&quot;
<span class="lineNum">    8647 </span>            :                 &quot;- no: only generate the adaptation set for the main profile\n&quot;
<span class="lineNum">    8648 </span>            :                 &quot;- comp: only generate the adaptation sets for all compatible profiles\n&quot;
<span class="lineNum">    8649 </span>            :                 &quot;- all: generate the adaptation set for the main profile and all compatible profiles&quot;
<span class="lineNum">    8650 </span>            :                 , GF_PROP_UINT, &quot;no&quot;, &quot;no|comp|all&quot;, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8651 </span>            :         { OFFS(mname), &quot;output manifest name for ATSC3 muxing&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8652 </span>            :         { OFFS(llhls), &quot;HLS low latency type\n&quot;
<span class="lineNum">    8653 </span>            :                 &quot;- off: do not use LL-HLS\n&quot;
<span class="lineNum">    8654 </span>            :                 &quot;- br: use LL-HLS with byte-range for segment parts, pointing to full segment (DASH-LL compatible)\n&quot;
<span class="lineNum">    8655 </span>            :                 &quot;- sf: use separated files for segment parts\n&quot;
<span class="lineNum">    8656 </span>            :                 &quot;- brsf: generate two sets of manifest, one for byte-range and one for files (`_IF` added before extension of manifest)&quot;, GF_PROP_UINT, &quot;off&quot;, &quot;off|br|sf|brsf&quot;, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8657 </span>            :         { OFFS(cdur), &quot;chunk duration for fragmentation modes&quot;, GF_PROP_FRACTION, &quot;-1/1&quot;, NULL, GF_FS_ARG_HINT_HIDE},
<span class="lineNum">    8658 </span>            :         { OFFS(hlsdrm), &quot;cryp file info for HLS full segment encryption&quot;, GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},
<span class="lineNum">    8659 </span>            :         { OFFS(cmaf), &quot;use cmaf guidelines\n&quot;
<span class="lineNum">    8660 </span>            :                 &quot;- no: CMAF not enforced\n&quot;
<span class="lineNum">    8661 </span>            :                 &quot;- cmfc: use CMAF `cmfc` guidelines\n&quot;
<span class="lineNum">    8662 </span>            :                 &quot;- cmf2: use CMAF `cmf2` guidelines&quot;
<span class="lineNum">    8663 </span>            :                 , GF_PROP_UINT, &quot;no&quot;, &quot;no|cmfc|cmf2&quot;, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    8664 </span>            :         { OFFS(pswitch), &quot;force period switch instead of absorbing PID reconfiguration (for splicing or add insertion not using periodID)&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_HIDE},
<span class="lineNum">    8665 </span>            :         {0}
<span class="lineNum">    8666 </span>            : };
<span class="lineNum">    8667 </span>            : 
<span class="lineNum">    8668 </span>            : 
<span class="lineNum">    8669 </span>            : GF_FilterRegister DasherRegister = {
<span class="lineNum">    8670 </span>            :         .name = &quot;dasher&quot;,
<span class="lineNum">    8671 </span>            :         GF_FS_SET_DESCRIPTION(&quot;DASH and HLS segmenter&quot;)
<span class="lineNum">    8672 </span>            :         GF_FS_SET_HELP(
<span class="lineNum">    8673 </span>            : &quot;# GPAC DASH and HLS segmenter\n&quot;
<span class="lineNum">    8674 </span>            : &quot;This filter provides segmentation and manifest generation for MPEG-DASH and HLS formats.\n&quot;
<span class="lineNum">    8675 </span>            : &quot;The segmenter currently supports:\n&quot;
<span class="lineNum">    8676 </span>            : &quot;- MPD and m3u8 generation (potentially in parallel)\n&quot;
<span class="lineNum">    8677 </span>            : &quot;- ISOBMFF, MPEG-2 TS, MKV and raw bitstream segment formats\n&quot;
<span class="lineNum">    8678 </span>            : &quot;- override of profiles and levels in manifest for codecs\n&quot;
<span class="lineNum">    8679 </span>            : &quot;- most MPEG-DASH profiles\n&quot;
<span class="lineNum">    8680 </span>            : &quot;- static and dynamic (live) manifest offering\n&quot;
<span class="lineNum">    8681 </span>            : &quot;- context store and reload for batch processing of live/dynamic sessions\n&quot;
<span class="lineNum">    8682 </span>            : &quot;\n&quot;
<span class="lineNum">    8683 </span>            : &quot;The filter does perform per-segment real-time regulation using [-sreg]().\n&quot;
<span class="lineNum">    8684 </span>            : &quot;If you need per-frame real-time regulation on non-real-time inputs, insert a [reframer](reframer) before to perform real-time regulation.\n&quot;
<span class="lineNum">    8685 </span>            : &quot;EX src=file.mp4 reframer:rt=on @ -o live.mpd:dmode=dynamic\n&quot;
<span class="lineNum">    8686 </span>            : &quot;## Template strings\n&quot;
<span class="lineNum">    8687 </span>            : &quot;The segmenter uses templates to derive output file names, regardless of the DASH mode (even when templates are not used). &quot;
<span class="lineNum">    8688 </span>            : &quot;The default one is `$File$_dash` for ondemand and single file modes, and `$File$_$Number$` for separate segment files\n&quot;
<span class="lineNum">    8689 </span>            : &quot;EX template=Great_$File$_$Width$_$Number$\n&quot;
<span class="lineNum">    8690 </span>            : &quot;If input is foo.mp4 with 640x360 video, this will resolve in Great_foo_640_$Number$ for the DASH template.\n&quot;
<span class="lineNum">    8691 </span>            : &quot;EX template=Great_$File$_$Width$\n&quot;
<span class="lineNum">    8692 </span>            : &quot;If input is foo.mp4 with 640x360 video, this will resolve in Great_foo_640.mp4 for onDemand case.\n&quot;
<span class="lineNum">    8693 </span>            : &quot;\n&quot;
<span class="lineNum">    8694 </span>            : &quot;Standard DASH replacement strings: \n&quot;
<span class="lineNum">    8695 </span>            : &quot;- $Number[%%0Nd]$: replaced by the segment number, possibly prefixed with 0\n&quot;
<span class="lineNum">    8696 </span>            : &quot;- $RepresentationID$: replaced by representation name\n&quot;
<span class="lineNum">    8697 </span>            : &quot;- $Time$: replaced by segment start time\n&quot;
<span class="lineNum">    8698 </span>            : &quot;- $Bandwidth$: replaced by representation bandwidth.\n&quot;
<span class="lineNum">    8699 </span>            : &quot;Note: these strings are not replaced in the manifest templates elements.\n&quot;
<span class="lineNum">    8700 </span>            : &quot;\n&quot;
<span class="lineNum">    8701 </span>            : &quot;Additional replacement strings (not DASH, not generic GPAC replacements but may occur multiple times in template):\n&quot;
<span class="lineNum">    8702 </span>            : &quot;- $Init=NAME$: replaced by NAME for init segment, ignored otherwise\n&quot;
<span class="lineNum">    8703 </span>            : &quot;- $XInit=NAME$: complete replace by NAME for init segment, ignored otherwise\n&quot;
<span class="lineNum">    8704 </span>            : &quot;- $Index=NAME$: replaced by NAME for index segments, ignored otherwise\n&quot;
<span class="lineNum">    8705 </span>            : &quot;- $Path=PATH$: replaced by PATH when creating segments, ignored otherwise\n&quot;
<span class="lineNum">    8706 </span>            : &quot;- $Segment=NAME$: replaced by NAME for media segments, ignored for init segments\n&quot;
<span class="lineNum">    8707 </span>            : &quot;- $FS$ (FileSuffix): replaced by `_trackN` in case the input is an AV multiplex, or kept empty otherwise\n&quot;
<span class="lineNum">    8708 </span>            : &quot;Note: these strings are replaced in the manifest templates elements.\n&quot;
<span class="lineNum">    8709 </span>            : &quot;\n&quot;
<span class="lineNum">    8710 </span>            : &quot;## PID assignment and configuration\n&quot;
<span class="lineNum">    8711 </span>            : &quot;To assign PIDs into periods and adaptation sets and configure the session, the segmenter looks for the following properties on each input pid:\n&quot;
<span class="lineNum">    8712 </span>            : &quot;- Representation: assigns representation ID to input pid. If not set, the default behavior is to have each media component in different adaptation sets. Setting the RepresentationID allows explicit multiplexing of the source(s)\n&quot;
<span class="lineNum">    8713 </span>            : &quot;- Period: assigns period ID to input pid. If not set, the default behavior is to have all media in the same period with the same start time\n&quot;
<span class="lineNum">    8714 </span>            : &quot;- PStart: assigns period start. If not set, 0 is assumed, and periods appear in the Period ID declaration order. If negative, this gives the period order (-1 first, then -2 ...). If positive, this gives the true start time and will abort DASHing at period end\n&quot;
<span class="lineNum">    8715 </span>            : &quot;Note: When both positive and negative values are found, the by-order periods (negative) will be inserted AFTER the timed period (positive)\n&quot;
<span class="lineNum">    8716 </span>            : &quot;- ASID: assigns parent adaptation set ID. If not 0, only sources with same AS ID will be in the same adaptation set\n&quot;
<span class="lineNum">    8717 </span>            : &quot;Note: If multiple streams in source, only the first stream will have an AS ID assigned\n&quot;
<span class="lineNum">    8718 </span>            : &quot;- xlink: for remote periods, only checked for null pid\n&quot;
<span class="lineNum">    8719 </span>            : &quot;- Role, PDesc, ASDesc, ASCDesc, RDesc: various descriptors to set for period, AS or representation\n&quot;
<span class="lineNum">    8720 </span>            : &quot;- BUrl: overrides segmenter [-base] with a set of BaseURLs to use for the pid (per representation)\n&quot;
<span class="lineNum">    8721 </span>            : &quot;- Template: overrides segmenter [-template]() for this PID\n&quot;
<span class="lineNum">    8722 </span>            : &quot;- DashDur: overrides segmenter segment duration for this PID\n&quot;
<span class="lineNum">    8723 </span>            : &quot;- StartNumber: sets the start number for the first segment in the PID, default is 1\n&quot;
<span class="lineNum">    8724 </span>            : &quot;- IntraOnly: indicates input pid follows HLS EXT-X-I-FRAMES-ONLY guidelines\n&quot;
<span class="lineNum">    8725 </span>            : &quot;- Non-dash properties: Bitrate, SAR, Language, Width, Height, SampleRate, NumChannels, Language, ID, DependencyID, FPS, Interlaced, Codec. These properties are used to setup each representation and can be overridden on input PIDs using the general PID property settings (cf global help).\n&quot;
<span class="lineNum">    8726 </span>            : &quot;  \n&quot;
<span class="lineNum">    8727 </span>            : &quot;EX src=test.mp4:#Bitrate=1M dst=test.mpd\n&quot;
<span class="lineNum">    8728 </span>            : &quot;This will force declaring a bitrate of 1M for the representation, regardless of actual input bitrate.\n&quot;
<span class="lineNum">    8729 </span>            : &quot;EX src=muxav.mp4 dst=test.mpd\n&quot;
<span class="lineNum">    8730 </span>            : &quot;This will create unmuxed DASH segments.\n&quot;
<span class="lineNum">    8731 </span>            : &quot;EX src=muxav.mp4:#Representation=1 dst=test.mpd\n&quot;
<span class="lineNum">    8732 </span>            : &quot;This will create muxed DASH segments.\n&quot;
<span class="lineNum">    8733 </span>            : &quot;EX src=m1.mp4 src=m2.mp4:#Period=Yep dst=test.mpd\n&quot;
<span class="lineNum">    8734 </span>            : &quot;This will put src m1.mp4 in first period, m2.mp4 in second period.\n&quot;
<span class="lineNum">    8735 </span>            : &quot;EX src=m1.mp4:#BUrl=http://foo/bar dst=test.mpd\n&quot;
<span class="lineNum">    8736 </span>            : &quot;This will assign a baseURL to src m1.mp4.\n&quot;
<span class="lineNum">    8737 </span>            : &quot;EX src=m1.mp4:#ASCDesc=&lt;ElemName val=\&quot;attval\&quot;&gt;text&lt;/ElemName&gt; dst=test.mpd\n&quot;
<span class="lineNum">    8738 </span>            : &quot;This will assign the specified XML descriptor to the adaptation set.\n&quot;
<span class="lineNum">    8739 </span>            : &quot;Note:  this can be used to inject most DASH descriptors not natively handled by the segmenter.\n&quot;
<span class="lineNum">    8740 </span>            : &quot;The segmenter handles the XML descriptor as a string and does not attempt to validate it. Descriptors, as well as some segmenter filter arguments, are string lists (comma-separated by default), so that multiple descriptors can be added:\n&quot;
<span class="lineNum">    8741 </span>            : &quot;EX src=m1.mp4:#RDesc=&lt;Elem attribute=\&quot;1\&quot;/&gt;,&lt;Elem2&gt;text&lt;/Elem2&gt; dst=test.mpd\n&quot;
<span class="lineNum">    8742 </span>            : &quot;This will insert two descriptors in the representation(s) of m1.mp4.\n&quot;
<span class="lineNum">    8743 </span>            : &quot;EX src=video.mp4:#Template=foo$Number$ src=audio.mp4:#Template=bar$Number$ dst=test.mpd\n&quot;
<span class="lineNum">    8744 </span>            : &quot;This will assign different templates to the audio and video sources.\n&quot;
<span class="lineNum">    8745 </span>            : &quot;EX src=null:#xlink=http://foo/bar.xml:#PDur=4 src=m.mp4:#PStart=-1\n&quot;
<span class="lineNum">    8746 </span>            : &quot;This will insert an create an MPD with first a remote period then a regular one.\n&quot;
<span class="lineNum">    8747 </span>            : &quot;EX src=null:#xlink=http://foo/bar.xml:#PStart=6 src=m.mp4\n&quot;
<span class="lineNum">    8748 </span>            : &quot;This will create an MPD with first a regular period, dashing ony 6s of content, then a remote one.\n&quot;
<span class="lineNum">    8749 </span>            : &quot;\n&quot;
<span class="lineNum">    8750 </span>            : &quot;The segmenter will create muxing filter chains for each representation and will reassign PID IDs so that each media component (video, audio, ...) in an adaptation set has the same ID.\n&quot;
<span class="lineNum">    8751 </span>            : &quot;\n&quot;
<span class="lineNum">    8752 </span>            : &quot;For HLS, the output pid will deliver the master playlist **and** the variant playlists.\n&quot;
<span class="lineNum">    8753 </span>            : &quot;The default variant playlist are $NAME_$N.m3u8, where $NAME is the radical of the output file name and $N is the 1-based index of the variant.\n&quot;
<span class="lineNum">    8754 </span>            : &quot;\n&quot;
<span class="lineNum">    8755 </span>            : &quot;## Segmentation\n&quot;
<span class="lineNum">    8756 </span>            : &quot;The default behavior of the segmenter is to estimate the theoretical start time of each segment based on target segment duration, and start a new segment when a packet with SAP type 1,2,3 or 4 with time greater than the theoretical time is found.\n&quot;
<span class="lineNum">    8757 </span>            : &quot;This behavior can be changed to find the best SAP packet around a segment theoretical boundary using [-sbound]():\n&quot;
<span class="lineNum">    8758 </span>            : &quot;- closest mode: the segment will start at the closest SAP of the theoretical boundary\n&quot;
<span class="lineNum">    8759 </span>            : &quot;- in mode: the segment will start at or before the theoretical boundary\n&quot;
<span class="lineNum">    8760 </span>            : &quot;Warning: These modes will introduce delay in the segmenter (typically buffering of one GOP) and should not be used for low-latency modes.\n&quot;
<span class="lineNum">    8761 </span>            : &quot;The segmenter can also be configured to:\n&quot;
<span class="lineNum">    8762 </span>            : &quot;- completely ignore SAP when segmenting using [-sap]().\n&quot;
<span class="lineNum">    8763 </span>            : &quot;- ignore SAP on non-video streams when segmenting using [-strict_sap]().\n&quot;
<span class="lineNum">    8764 </span>            : &quot;\n&quot;
<span class="lineNum">    8765 </span>            : &quot;## Dynamic (real-time live) Mode\n&quot;
<span class="lineNum">    8766 </span>            : &quot;The dasher does not perform real-time regulation by default.\n&quot;
<span class="lineNum">    8767 </span>            : &quot;For regular segmentation, you should enable segment regulation [-sreg]() if your sources are not real-time.\n&quot;
<span class="lineNum">    8768 </span>            : &quot;EX gpac -i source.mp4 -o live.mpd:segdur=2:profile=live:dmode=dynamic:sreg\n&quot;
<span class="lineNum">    8769 </span>            : &quot;\n&quot;
<span class="lineNum">    8770 </span>            : &quot;For low latency segmentation with fMP4, you will need to specify the following options:\n&quot;
<span class="lineNum">    8771 </span>            : &quot;- cdur: set the fMP4 fragment duration\n&quot;
<span class="lineNum">    8772 </span>            : &quot;- asto: set the availability time offset for DASH. This value should be equal or slightly greater than segment duration minus cdur\n&quot;
<span class="lineNum">    8773 </span>            : &quot;- llhls: enable low latency for HLS\n&quot;
<span class="lineNum">    8774 </span>            : &quot;If your sources are not real-time, insert a reframer filter with real-time regulation\n&quot;
<span class="lineNum">    8775 </span>            : &quot;EX gpac -i source.mp4 reframer:rt=on @ -o live.mpd:segdur=2:cdur=0.2:asto=1.8:profile=live:dmode=dynamic\n&quot;
<span class="lineNum">    8776 </span>            : &quot;This will create DASH segments of 2 seconds made of fragments of 200 ms and indicate to the client that requests can be made 1.8 seconds earlier than segment complete availability on server.\n&quot;
<span class="lineNum">    8777 </span>            : &quot;EX gpac -i source.mp4 reframer:rt=on @ -o live.m3u8:segdur=2:cdur=0.2:llhls=br:dmode=dynamic\n&quot;
<span class="lineNum">    8778 </span>            : &quot;This will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using byte ranges in the final segment.\n&quot;
<span class="lineNum">    8779 </span>            : &quot;EX gpac -i source.mp4 reframer:rt=on @ -o live.m3u8:segdur=2:cdur=0.2:llhls=sf:dmode=dynamic\n&quot;
<span class="lineNum">    8780 </span>            : &quot;This will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using dedicated files.\n&quot;
<span class="lineNum">    8781 </span>            : &quot;\n&quot;
<span class="lineNum">    8782 </span>            : &quot;You can combine LL-HLS and DASH-LL generation:\n&quot;
<span class="lineNum">    8783 </span>            : &quot;EX gpac -i source.mp4 reframer:rt=on @ -o live.mpd:dual:segdur=2:cdur=0.2:asto=1.8:llhls=br:profile=live:dmode=dynamic\n&quot;
<span class="lineNum">    8784 </span>            : &quot;\n&quot;
<span class="lineNum">    8785 </span>            : &quot;For DASH, the filter will use the local clock for UTC anchor points in DASH.\n&quot;
<span class="lineNum">    8786 </span>            : &quot;The filter can fetch and signal clock in other ways using [-utcs]().\n&quot;
<span class="lineNum">    8787 </span>            : &quot;EX [opts]:utcs=inband\n&quot;
<span class="lineNum">    8788 </span>            : &quot;This will use the local clock and insert in the MPD a UTCTiming descriptor containing the local clock.\n&quot;
<span class="lineNum">    8789 </span>            : &quot;EX [opts]::utcs=http://time.akamai.com[::opts]\n&quot;
<span class="lineNum">    8790 </span>            : &quot;This will fetch time from `http://time.akamai.com`, use it as the UTC reference for segment generation and insert in the MPD a UTCTiming descriptor containing the time server URL.\n&quot;
<span class="lineNum">    8791 </span>            : &quot;Note: if not set as a global option using `--utcs=`, you must escape the url using double `::` or use other separators.\n&quot;
<span class="lineNum">    8792 </span>            : &quot;\n&quot;
<span class="lineNum">    8793 </span>            : &quot;## Cue-driven segmentation\n&quot;
<span class="lineNum">    8794 </span>            : &quot;The segmenter can take a list of instructions, or Cues, to use for the segmentation process, in which case only these are used to derive segment boundaries. Cues can be set through XML files or injected in input packets.\n&quot;
<span class="lineNum">    8795 </span>            : &quot;\n&quot;
<span class="lineNum">    8796 </span>            : &quot;Cue files can be specified for the entire segmenter, or per PID using `DashCue` property.\n&quot;
<span class="lineNum">    8797 </span>            : &quot;Cues are given in an XML file with a root element called &lt;DASHCues&gt;, with currently no attribute specified. The children are one or more &lt;Stream&gt; elements, with attributes:\n&quot;
<span class="lineNum">    8798 </span>            : &quot;- id: integer for stream/track/pid ID\n&quot;
<span class="lineNum">    8799 </span>            : &quot;- timescale: integer giving the units of following timestamps\n&quot;
<span class="lineNum">    8800 </span>            : &quot;- mode: if present and value is `edit`, the timestamp are in presentation time (edit list applied) otherwise they are in media time\n&quot;
<span class="lineNum">    8801 </span>            : &quot;- ts_offset: integer giving a value (in timescale) to subtract to the DTS/CTS values listed\n&quot;
<span class="lineNum">    8802 </span>            : &quot;\nThe children of &lt;Stream&gt; are one or more &lt;Cue&gt; elements, with attributes:\n&quot;
<span class="lineNum">    8803 </span>            : &quot;- sample: integer giving the sample/frame number of a sample at which splitting shall happen\n&quot;
<span class="lineNum">    8804 </span>            : &quot;- dts: long integer giving the decoding time stamp of a sample at which splitting shall happen\n&quot;
<span class="lineNum">    8805 </span>            : &quot;- cts: long integer giving the composition / presentation time stamp of a sample at which splitting shall happen\n&quot;
<span class="lineNum">    8806 </span>            : &quot;Warning: Cues shall be listed in decoding order.\n&quot;
<span class="lineNum">    8807 </span>            : &quot;\n&quot;
<span class="lineNum">    8808 </span>            : &quot;If the `DashCue` property of a PID equals `inband`, the PID will be segmented according to the `CueStart` property of input packets.\n&quot;
<span class="lineNum">    8809 </span>            : &quot;This feature is typically combined with a list of files as input:\n&quot;
<span class="lineNum">    8810 </span>            : &quot;EX -i list.m3u:sigcues -o res/live.mpd&quot;
<span class="lineNum">    8811 </span>            : &quot;This will load the `flist` filter in cue mode, generating continuous timelines from the sources and injecting a `CueStart` property at each new file.&quot;
<span class="lineNum">    8812 </span>            : &quot;\n&quot;
<span class="lineNum">    8813 </span>            : &quot;## Manifest Generation only mode\n&quot;
<span class="lineNum">    8814 </span>            : &quot;The segmenter can be used to generate manifests from already fragmented ISOBMFF inputs using [-sigfrag]().\n&quot;
<span class="lineNum">    8815 </span>            : &quot;In this case, segment boundaries are attached to each packet starting a segment and used to drive the segmentation.\n&quot;
<span class="lineNum">    8816 </span>            : &quot;This can be used with single-track ISOBMFF sources, either single file or multi file.\n&quot;
<span class="lineNum">    8817 </span>            : &quot;For single file source:\n&quot;
<span class="lineNum">    8818 </span>            : &quot;- if onDemand [-profile]() is requested, sources have to be formatted as a DASH self-initializing media segment with the proper sidx.\n&quot;
<span class="lineNum">    8819 </span>            : &quot;- templates are disabled.\n&quot;
<span class="lineNum">    8820 </span>            : &quot;- [-sseg]() is forced for all profiles except onDemand ones.\n&quot;
<span class="lineNum">    8821 </span>            : &quot;For multi files source:\n&quot;
<span class="lineNum">    8822 </span>            : &quot;- input shall be a playlist containing the initial file followed by the ordered list of segments.\n&quot;
<span class="lineNum">    8823 </span>            : &quot;- if no [-template]() is provided, the full or main [-profile]() will be used\n&quot;
<span class="lineNum">    8824 </span>            : &quot;- if [-template]() is provided, it shall be correct: the filter will not try to guess one from the input file names and will not validate it either.\n&quot;
<span class="lineNum">    8825 </span>            : &quot;\n&quot;
<span class="lineNum">    8826 </span>            : &quot;The manifest generation-only mode supports both MPD and HLS generation.\n&quot;
<span class="lineNum">    8827 </span>            : &quot;\n&quot;
<span class="lineNum">    8828 </span>            : &quot;EX -i ondemand_src.mp4 -o dash.mpd:sigfrag:profile=onDemand\n&quot;
<span class="lineNum">    8829 </span>            : &quot;This will generate a DASH manifest for onDemand Profile based on the input file.\n&quot;
<span class="lineNum">    8830 </span>            : &quot;EX -i ondemand_src.mp4 -o dash.m3u8:sigfrag\n&quot;
<span class="lineNum">    8831 </span>            : &quot;This will generate a HLS manifest based on the input file.\n&quot;
<span class="lineNum">    8832 </span>            : &quot;EX -i seglist.txt -o dash.mpd:sigfrag\n&quot;
<span class="lineNum">    8833 </span>            : &quot;This will generate a DASH manifest in Main Profile based on the input files.\n&quot;
<span class="lineNum">    8834 </span>            : &quot;EX -i seglist.txt:Template=$XInit=init$$q1/$Number$ -o dash.mpd:sigfrag:profile=live\n&quot;
<span class="lineNum">    8835 </span>            : &quot;This will generate a DASH manifest in live Profile based on the input files. The input file will contain `init.mp4`, `q1/1.m4s`, `q1/2.m4s`...\n&quot;
<span class="lineNum">    8836 </span>            : &quot;\n&quot;
<span class="lineNum">    8837 </span>            : &quot;## Muxer development considerations\n&quot;
<span class="lineNum">    8838 </span>            : &quot;Output muxers allowing segmented output must obey the following:\n&quot;
<span class="lineNum">    8839 </span>            : &quot;- inspect packet properties\n&quot;
<span class="lineNum">    8840 </span>            : &quot; - FileNumber: if set, indicate the start of a new DASH segment\n&quot;
<span class="lineNum">    8841 </span>            : &quot; - FileName: if set, indicate the file name. If not present, output shall be a single file. This is only set for packet carrying the `FileNumber` property, and only on one PID (usually the first) for multiplexed outputs\n&quot;
<span class="lineNum">    8842 </span>            : &quot; - IDXName: gives the optional index name (if not present, index shall be in the same file as dash segment). Only used for MPEG-2 TS for now\n&quot;
<span class="lineNum">    8843 </span>            : &quot; - EODS: property is set on packets with no payload and no timestamp to signal the end of a DASH segment. This is only used when stopping/resuming the segmentation process, in order to flush segments without dispatching an EOS (see [-subdur]() )\n&quot;
<span class="lineNum">    8844 </span>            : &quot;- for each segment done, send a downstream event on the first connected PID signaling the size of the segment and the size of its index if any\n&quot;
<span class="lineNum">    8845 </span>            : &quot;- for muxers with init data, send a downstream event signaling the size of the init and the size of the global index if any\n&quot;
<span class="lineNum">    8846 </span>            : &quot;- the following filter options are passed to muxers, which should declare them as arguments:\n&quot;
<span class="lineNum">    8847 </span>            : &quot; - noinit: disables output of init segment for the muxer (used to handle bitstream switching with single init in DASH)\n&quot;
<span class="lineNum">    8848 </span>            : &quot; - frag: indicates muxer shall use fragmented format (used for ISOBMFF mostly)\n&quot;
<span class="lineNum">    8849 </span>            : &quot; - subs_sidx=0: indicates an SIDX shall be generated - only added if not already specified by user\n&quot;
<span class="lineNum">    8850 </span>            : &quot; - xps_inband=all|no: indicates AVC/HEVC/... parameter sets shall be sent inband or out of band\n&quot;
<span class="lineNum">    8851 </span>            : &quot; - nofragdef: indicates fragment defaults should be set in each segment rather than in init segment\n&quot;
<span class="lineNum">    8852 </span>            : &quot;\n&quot;
<span class="lineNum">    8853 </span>            : &quot;The segmenter will add the following properties to the output PIDs:\n&quot;
<span class="lineNum">    8854 </span>            : &quot;- DashMode: identifies VoD (single file with global index) or regular DASH mode used by segmenter\n&quot;
<span class="lineNum">    8855 </span>            : &quot;- DashDur: identifies target DASH segment duration - this can be used to estimate the SIDX size for example\n&quot;
<span class="lineNum">    8856 </span>            :                         )
<span class="lineNum">    8857 </span>            :         .private_size = sizeof(GF_DasherCtx),
<span class="lineNum">    8858 </span>            :         .args = DasherArgs,
<span class="lineNum">    8859 </span>            :         .initialize = dasher_initialize,
<span class="lineNum">    8860 </span>            :         .finalize = dasher_finalize,
<span class="lineNum">    8861 </span>            :         SETCAPS(DasherCaps),
<span class="lineNum">    8862 </span>            :         .flags = GF_FS_REG_REQUIRES_RESOLVER,
<span class="lineNum">    8863 </span>            :         .configure_pid = dasher_configure_pid,
<span class="lineNum">    8864 </span>            :         .process = dasher_process,
<span class="lineNum">    8865 </span>            :         .process_event = dasher_process_event,
<span class="lineNum">    8866 </span>            : };
<a name="8867"><span class="lineNum">    8867 </span>            : </a>
<span class="lineNum">    8868 </span>            : 
<span class="lineNum">    8869 </span><span class="lineCov">       2877 : const GF_FilterRegister *dasher_register(GF_FilterSession *session)</span>
<span class="lineNum">    8870 </span>            : {
<span class="lineNum">    8871 </span><span class="lineCov">       2877 :         return &amp;DasherRegister;</span>
<span class="lineNum">    8872 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
