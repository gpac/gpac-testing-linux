<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - filters/hevcmerge.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">filters</a> - hevcmerge.c<span style="font-size: 80%;"> (source / <a href="hevcmerge.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">630</td>
            <td class="headerCovTableEntry">760</td>
            <td class="headerCovTableEntryMed">82.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-04-29 23:48:07</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *                      GPAC - Multimedia Framework C SDK
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *                      Authors: Jean Le Feuvre
<span class="lineNum">       5 </span>            :  *                                       Yacine Mathurin Boubacar Aziakou
<span class="lineNum">       6 </span>            :  *                                       Samir Mustapha
<span class="lineNum">       7 </span>            :  *                      Copyright (c) Telecom ParisTech 2019-2021
<span class="lineNum">       8 </span>            :  *                                      All rights reserved
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *  This file is part of GPAC / HEVC tile merger filter
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  *  GPAC is free software; you can redistribute it and/or modify
<span class="lineNum">      13 </span>            :  *  it under the terms of the GNU Lesser General Public License as published by
<span class="lineNum">      14 </span>            :  *  the Free Software Foundation; either version 2, or (at your option)
<span class="lineNum">      15 </span>            :  *  any later version.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  *  GPAC is distributed in the hope that it will be useful,
<span class="lineNum">      18 </span>            :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      19 </span>            :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      20 </span>            :  *  GNU Lesser General Public License for more details.
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  *  You should have received a copy of the GNU Lesser General Public
<span class="lineNum">      23 </span>            :  *  License along with this library; see the file COPYING.  If not, write to
<span class="lineNum">      24 </span>            :  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &lt;gpac/bitstream.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;gpac/filters.h&gt;
<span class="lineNum">      30 </span>            : #include &lt;gpac/avparse.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;gpac/constants.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;gpac/internal/media_dev.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #if !defined(GPAC_DISABLE_HEVC) &amp;&amp; !defined(GPAC_DISABLE_AV_PARSERS)
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : typedef struct
<span class="lineNum">      38 </span>            : {
<span class="lineNum">      39 </span>            :         GF_FilterPid *pid;
<span class="lineNum">      40 </span>            :         u32 slice_segment_address, width, height;
<span class="lineNum">      41 </span>            :         Bool in_error;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :         u32 nalu_size_length;
<span class="lineNum">      44 </span>            :         u32 dsi_crc;
<span class="lineNum">      45 </span>            :         HEVCState hevc_state;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :         //final position in grid - the row index is only used to push non multiple of CU height at the bottom of the grid
<span class="lineNum">      48 </span>            :         u32 pos_row, pos_col;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :         //timescale of source pid
<span class="lineNum">      51 </span>            :         //number of packets processed
<span class="lineNum">      52 </span>            :         u32 timescale;
<span class="lineNum">      53 </span>            :         u32 nb_pck;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :         //true if positioning in pixel is given
<span class="lineNum">      56 </span>            :         Bool has_pos;
<span class="lineNum">      57 </span>            :         // &gt;=0: positioning in pixel in the Y plane as given by CropOrigin
<span class="lineNum">      58 </span>            :         // &lt;=0: positioning relative to top-left tile
<span class="lineNum">      59 </span>            :         s32 pos_x, pos_y;
<span class="lineNum">      60 </span>            : } HEVCTilePidCtx;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : typedef struct {
<span class="lineNum">      64 </span>            :         //width of column
<span class="lineNum">      65 </span>            :         u32 width;
<span class="lineNum">      66 </span>            :         //cumulated height of all slices in column
<span class="lineNum">      67 </span>            :         u32 height;
<span class="lineNum">      68 </span>            :         //only used while computing the grid, current position in rows in the column
<span class="lineNum">      69 </span>            :         u32 row_pos, max_row_pos;
<span class="lineNum">      70 </span>            :         u32 last_row_idx;
<span class="lineNum">      71 </span>            :         u32 pos_x;
<span class="lineNum">      72 </span>            : } HEVCGridInfo;
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : typedef struct
<span class="lineNum">      75 </span>            : {
<span class="lineNum">      76 </span>            :         //options
<span class="lineNum">      77 </span>            :         Bool strict, mrows;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :         GF_FilterPid *opid;
<span class="lineNum">      80 </span>            :         s32 base_pps_init_qp_delta_minus26;
<span class="lineNum">      81 </span>            :         u32 nb_bits_per_address_dst;
<span class="lineNum">      82 </span>            :         u32 out_width, out_height;
<span class="lineNum">      83 </span>            :         u8 *buffer_nal, *buffer_nal_no_epb, *buffer_nal_in_no_epb;
<span class="lineNum">      84 </span>            :         u32 buffer_nal_alloc, buffer_nal_no_epb_alloc, buffer_nal_in_no_epb_alloc;
<span class="lineNum">      85 </span>            :         GF_BitStream *bs_au_in;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :         GF_BitStream *bs_nal_in;
<span class="lineNum">      88 </span>            :         GF_BitStream *bs_nal_out;
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :         HEVCGridInfo *grid;
<span class="lineNum">      91 </span>            :         u32 nb_cols;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :         u8 *sei_suffix_buf;
<span class="lineNum">      94 </span>            :         u32 sei_suffix_len, sei_suffix_alloc;
<span class="lineNum">      95 </span>            :         u32 hevc_nalu_size_length;
<span class="lineNum">      96 </span>            :         u32 max_CU_width, max_CU_height;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :         GF_List *pids, *ordered_pids;
<span class="lineNum">      99 </span>            :         Bool in_error;
<span class="lineNum">     100 </span>            :         Bool enable_multi_rows;
<span class="lineNum">     101 </span>            :         u32 nb_rows;
<span class="lineNum">     102 </span>            : } GF_HEVCMergeCtx;
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : //in src/filters/hevcsplit.c
<span class="lineNum">     105 </span>            : void hevc_rewrite_sps(char *in_SPS, u32 in_SPS_length, u32 width, u32 height, char **out_SPS, u32 *out_SPS_length);
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : #if 0 //todo
<span class="lineNum">     108 </span>            : //rewrite the profile and level
<span class="lineNum">     109 </span>            : static void write_profile_tier_level(GF_BitStream *ctx-&gt;bs_nal_in, GF_BitStream *ctx-&gt;bs_nal_out, Bool ProfilePresentFlag, u8 MaxNumSubLayersMinus1)
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span>            :         u8 j;
<span class="lineNum">     112 </span>            :         Bool sub_layer_profile_present_flag[8], sub_layer_level_present_flag[8];
<span class="lineNum">     113 </span>            :         if (ProfilePresentFlag) {
<span class="lineNum">     114 </span>            :                 gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 8), 8);
<span class="lineNum">     115 </span>            :                 gf_bs_write_long_int(ctx-&gt;bs_nal_out, gf_bs_read_long_int(ctx-&gt;bs_nal_in, 32), 32);
<span class="lineNum">     116 </span>            :                 gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 4), 4);
<span class="lineNum">     117 </span>            :                 gf_bs_write_long_int(ctx-&gt;bs_nal_out, gf_bs_read_long_int(ctx-&gt;bs_nal_in, 44), 44);
<span class="lineNum">     118 </span>            :         }
<span class="lineNum">     119 </span>            :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 8), 8);
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :         for (j = 0; j &lt; MaxNumSubLayersMinus1; j++) {
<span class="lineNum">     122 </span>            :                 sub_layer_profile_present_flag[j] = gf_bs_read_int(ctx-&gt;bs_nal_in, 1);
<span class="lineNum">     123 </span>            :                 gf_bs_write_int(ctx-&gt;bs_nal_out, sub_layer_profile_present_flag[j], 1);
<span class="lineNum">     124 </span>            :                 sub_layer_level_present_flag[j] = gf_bs_read_int(ctx-&gt;bs_nal_in, 1);
<span class="lineNum">     125 </span>            :                 gf_bs_write_int(ctx-&gt;bs_nal_out, sub_layer_level_present_flag[j], 1);
<span class="lineNum">     126 </span>            :         }
<span class="lineNum">     127 </span>            :         if (MaxNumSubLayersMinus1 &gt; 0)
<span class="lineNum">     128 </span>            :                 for (j = MaxNumSubLayersMinus1; j &lt; 8; j++)
<span class="lineNum">     129 </span>            :                         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 2), 2);
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :         for (j = 0; j &lt; MaxNumSubLayersMinus1; j++) {
<span class="lineNum">     133 </span>            :                 if (sub_layer_profile_present_flag[j]) {
<span class="lineNum">     134 </span>            :                         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 8), 8);
<span class="lineNum">     135 </span>            :                         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 32), 32);
<span class="lineNum">     136 </span>            :                         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 4), 4);
<span class="lineNum">     137 </span>            :                         gf_bs_write_long_int(ctx-&gt;bs_nal_out, gf_bs_read_long_int(ctx-&gt;bs_nal_in, 44), 44);
<span class="lineNum">     138 </span>            :                 }
<span class="lineNum">     139 </span>            :                 if (sub_layer_level_present_flag[j])
<span class="lineNum">     140 </span>            :                         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 8), 8);
<span class="lineNum">     141 </span>            :         }
<span class="lineNum">     142 </span>            : }
<a name="143"><span class="lineNum">     143 </span>            : #endif</a>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineCov">         25 : static void hevcmerge_rewrite_pps(GF_HEVCMergeCtx *ctx, char *in_PPS, u32 in_PPS_length, char **out_PPS, u32 *out_PPS_length)</span>
<span class="lineNum">     146 </span>            : {
<span class="lineNum">     147 </span>            :         u8 cu_qp_delta_enabled_flag;
<span class="lineNum">     148 </span>            :         u32 loop_filter_flag;
<span class="lineNum">     149 </span>            :         u32 pps_size_no_epb;
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineCov">         25 :         gf_bs_reassign_buffer(ctx-&gt;bs_nal_in, in_PPS, in_PPS_length);</span>
<span class="lineNum">     152 </span><span class="lineCov">         25 :         gf_bs_enable_emulation_byte_removal(ctx-&gt;bs_nal_in, GF_TRUE);</span>
<span class="lineNum">     153 </span><span class="lineCov">         25 :         if (!ctx-&gt;bs_nal_out) ctx-&gt;bs_nal_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);</span>
<span class="lineNum">     154 </span><span class="lineCov">         20 :         else gf_bs_reassign_buffer(ctx-&gt;bs_nal_out, ctx-&gt;buffer_nal_no_epb, ctx-&gt;buffer_nal_no_epb_alloc);</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :         //Read and write NAL header bits
<span class="lineNum">     157 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 16), 16);</span>
<span class="lineNum">     158 </span><span class="lineCov">         25 :         gf_bs_write_ue(ctx-&gt;bs_nal_out, gf_bs_read_ue(ctx-&gt;bs_nal_in)); //pps_pic_parameter_set_id</span>
<span class="lineNum">     159 </span><span class="lineCov">         25 :         gf_bs_write_ue(ctx-&gt;bs_nal_out, gf_bs_read_ue(ctx-&gt;bs_nal_in)); //pps_seq_parameter_set_id</span>
<span class="lineNum">     160 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 7), 7); //from dependent_slice_segments_enabled_flag to cabac_init_present_flag</span>
<span class="lineNum">     161 </span><span class="lineCov">         25 :         gf_bs_write_ue(ctx-&gt;bs_nal_out, gf_bs_read_ue(ctx-&gt;bs_nal_in)); //num_ref_idx_l0_default_active_minus1</span>
<span class="lineNum">     162 </span><span class="lineCov">         25 :         gf_bs_write_ue(ctx-&gt;bs_nal_out, gf_bs_read_ue(ctx-&gt;bs_nal_in)); //num_ref_idx_l1_default_active_minus1</span>
<span class="lineNum">     163 </span><span class="lineCov">         25 :         gf_bs_write_se(ctx-&gt;bs_nal_out, gf_bs_read_se(ctx-&gt;bs_nal_in)); //init_qp_minus26</span>
<span class="lineNum">     164 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 2), 2); //from constrained_intra_pred_flag to transform_skip_enabled_flag</span>
<span class="lineNum">     165 </span><span class="lineCov">         25 :         cu_qp_delta_enabled_flag = gf_bs_read_int(ctx-&gt;bs_nal_in, 1); //cu_qp_delta_enabled_flag</span>
<span class="lineNum">     166 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, cu_qp_delta_enabled_flag, 1); //</span>
<span class="lineNum">     167 </span><span class="lineCov">         25 :         if (cu_qp_delta_enabled_flag)</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :                 gf_bs_write_ue(ctx-&gt;bs_nal_out, gf_bs_read_ue(ctx-&gt;bs_nal_in)); // diff_cu_qp_delta_depth</span>
<span class="lineNum">     169 </span><span class="lineCov">         25 :         gf_bs_write_se(ctx-&gt;bs_nal_out, gf_bs_read_se(ctx-&gt;bs_nal_in)); // pps_cb_qp_offset</span>
<span class="lineNum">     170 </span><span class="lineCov">         25 :         gf_bs_write_se(ctx-&gt;bs_nal_out, gf_bs_read_se(ctx-&gt;bs_nal_in)); // pps_cr_qp_offset</span>
<span class="lineNum">     171 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 4), 4); // from pps_slice_chroma_qp_offsets_present_flag to transquant_bypass_enabled_flag</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineCov">         25 :         gf_bs_read_int(ctx-&gt;bs_nal_in, 1);</span>
<span class="lineNum">     175 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, 1, 1);</span>
<span class="lineNum">     176 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 1), 1);//entropy_coding_sync_enabled_flag</span>
<span class="lineNum">     177 </span><span class="lineCov">         25 :         gf_bs_write_ue(ctx-&gt;bs_nal_out, ctx-&gt;nb_cols-1);//write num_tile_columns_minus1</span>
<span class="lineNum">     178 </span>            :         //num_tile_rows_minus1
<span class="lineNum">     179 </span><span class="lineCov">         25 :         if (ctx-&gt;enable_multi_rows) {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :                 u32 nb_rows = ctx-&gt;nb_rows - 1;</span>
<span class="lineNum">     181 </span>            :                 assert(ctx-&gt;nb_rows);
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :                 gf_bs_write_ue(ctx-&gt;bs_nal_out, nb_rows);</span>
<span class="lineNum">     183 </span>            :         } else {
<span class="lineNum">     184 </span><span class="lineCov">         25 :                 gf_bs_write_ue(ctx-&gt;bs_nal_out, 0);//num_tile_rows_minus1</span>
<span class="lineNum">     185 </span>            :         }
<span class="lineNum">     186 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, 0, 1);  //uniform_spacing_flag</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : //      if (!uniform_spacing_flag) //always 0
<span class="lineNum">     189 </span>            :         {
<span class="lineNum">     190 </span>            :                 u32 i;
<span class="lineNum">     191 </span><span class="lineCov">         49 :                 for (i = 0; i &lt; ctx-&gt;nb_cols-1; i++)</span>
<span class="lineNum">     192 </span><span class="lineCov">         24 :                         gf_bs_write_ue(ctx-&gt;bs_nal_out, (ctx-&gt;grid[i].width / ctx-&gt;max_CU_width - 1));</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :                 //if multi row is possible, declare the row height
<span class="lineNum">     195 </span><span class="lineCov">         25 :                 if (ctx-&gt;enable_multi_rows &amp;&amp; (ctx-&gt;nb_rows&gt;1))  {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                         u32 nb_rows = ctx-&gt;nb_rows - 1;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                         u32 nb_pids = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                         for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     200 </span>            :                                 //get pid in their final order
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                                 HEVCTilePidCtx *tile = gf_list_get(ctx-&gt;ordered_pids, i);</span>
<span class="lineNum">     202 </span>            :                                 //only check height in the first column
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :                                 if (tile-&gt;pos_col) continue;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :                                 gf_bs_write_ue(ctx-&gt;bs_nal_out, (tile-&gt;height / ctx-&gt;max_CU_width - 1)); // row_height_minus1[i]</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :                                 nb_rows--;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :                                 if (!nb_rows) break;</span>
<span class="lineNum">     207 </span>            :                         }
<span class="lineNum">     208 </span>            :                 }
<span class="lineNum">     209 </span>            :                 //otherwise nothing to declare since we use a single row
<span class="lineNum">     210 </span>            :         }
<span class="lineNum">     211 </span>            :         loop_filter_flag = 1;
<span class="lineNum">     212 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, loop_filter_flag, 1);</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span><span class="lineCov">         25 :         loop_filter_flag = gf_bs_read_int(ctx-&gt;bs_nal_in, 1);</span>
<span class="lineNum">     215 </span><span class="lineCov">         25 :         gf_bs_write_int(ctx-&gt;bs_nal_out, loop_filter_flag, 1);</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :         // copy and write the rest of the bits in the byte
<span class="lineNum">     218 </span><span class="lineCov">        100 :         while (gf_bs_get_bit_position(ctx-&gt;bs_nal_in) != 8) {</span>
<span class="lineNum">     219 </span><span class="lineCov">         50 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 1), 1);</span>
<span class="lineNum">     220 </span>            :         }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :         //copy and write the rest of the bytes
<span class="lineNum">     223 </span><span class="lineCov">         75 :         while (gf_bs_get_size(ctx-&gt;bs_nal_in) != gf_bs_get_position(ctx-&gt;bs_nal_in)) {</span>
<span class="lineNum">     224 </span><span class="lineCov">         50 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_u8(ctx-&gt;bs_nal_in), 8); //watchout, not aligned in destination bitstream</span>
<span class="lineNum">     225 </span>            :         }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineCov">         25 :         gf_bs_align(ctx-&gt;bs_nal_out);</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineCov">         25 :         gf_bs_get_content_no_truncate(ctx-&gt;bs_nal_out, &amp;ctx-&gt;buffer_nal_no_epb, &amp;pps_size_no_epb, &amp;ctx-&gt;buffer_nal_no_epb_alloc);</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineCov">         25 :         *out_PPS_length = pps_size_no_epb + gf_media_nalu_emulation_bytes_add_count(ctx-&gt;buffer_nal_no_epb, pps_size_no_epb);</span>
<span class="lineNum">     232 </span><span class="lineCov">         25 :         *out_PPS = gf_malloc(*out_PPS_length);</span>
<span class="lineNum">     233 </span><span class="lineCov">         25 :         gf_media_nalu_add_emulation_bytes(ctx-&gt;buffer_nal_no_epb, *out_PPS, pps_size_no_epb);</span>
<a name="234"><span class="lineNum">     234 </span><span class="lineCov">         25 : }</span></a>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineCov">      18750 : u32 hevcmerge_rewrite_slice(GF_HEVCMergeCtx *ctx, HEVCTilePidCtx *tile_pid, char *in_slice, u32 in_slice_length)</span>
<span class="lineNum">     237 </span>            : {
<span class="lineNum">     238 </span>            :         u64 header_end;
<span class="lineNum">     239 </span><span class="lineCov">      18750 :         u32 out_slice_size_no_epb = 0, out_slice_length;</span>
<span class="lineNum">     240 </span>            :         u32 num_entry_point_start;
<span class="lineNum">     241 </span>            :         u32 pps_id;
<span class="lineNum">     242 </span>            :         Bool RapPicFlag = GF_FALSE;
<span class="lineNum">     243 </span>            :         u32 slice_qp_delta_start;
<span class="lineNum">     244 </span>            :         HEVC_PPS *pps;
<span class="lineNum">     245 </span>            :         HEVC_SPS *sps;
<span class="lineNum">     246 </span>            :         u32 al, slice_size, in_slice_size_no_epb, slice_offset_orig, slice_offset_dst;
<span class="lineNum">     247 </span>            :         u32 first_slice_segment_in_pic_flag;
<span class="lineNum">     248 </span>            :         u32 dependent_slice_segment_flag;
<span class="lineNum">     249 </span>            :         u8 nal_unit_type;
<span class="lineNum">     250 </span>            :         s32 new_slice_qp_delta;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :         HEVCState *hevc = &amp;tile_pid-&gt;hevc_state;
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :         //we remove EPB directly rather than from bs reader, since we will have to copy the entire payload without EPB
<span class="lineNum">     255 </span>            :         //and gf_bs_read_data does not check for EPB
<span class="lineNum">     256 </span><span class="lineCov">      18750 :         if (ctx-&gt;buffer_nal_in_no_epb_alloc&lt;in_slice_length) {</span>
<span class="lineNum">     257 </span><span class="lineCov">         26 :                 ctx-&gt;buffer_nal_in_no_epb_alloc = in_slice_length;</span>
<span class="lineNum">     258 </span><span class="lineCov">         26 :                 ctx-&gt;buffer_nal_in_no_epb = gf_realloc(ctx-&gt;buffer_nal_in_no_epb, in_slice_length);</span>
<span class="lineNum">     259 </span>            :         }
<span class="lineNum">     260 </span><span class="lineCov">      18750 :         in_slice_size_no_epb = gf_media_nalu_remove_emulation_bytes(in_slice, ctx-&gt;buffer_nal_in_no_epb, in_slice_length);</span>
<span class="lineNum">     261 </span><span class="lineCov">      18750 :         gf_bs_reassign_buffer(ctx-&gt;bs_nal_in, ctx-&gt;buffer_nal_in_no_epb, in_slice_size_no_epb);</span>
<span class="lineNum">     262 </span>            :         //disable EPB removal
<span class="lineNum">     263 </span><span class="lineCov">      18750 :         gf_bs_enable_emulation_byte_removal(ctx-&gt;bs_nal_in, GF_FALSE);</span>
<span class="lineNum">     264 </span><span class="lineCov">      18750 :         if (!ctx-&gt;bs_nal_out) ctx-&gt;bs_nal_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);</span>
<span class="lineNum">     265 </span><span class="lineCov">      18750 :         else gf_bs_reassign_buffer(ctx-&gt;bs_nal_out, ctx-&gt;buffer_nal_no_epb, ctx-&gt;buffer_nal_no_epb_alloc);</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :         assert(hevc-&gt;s_info.header_size_bits &gt;= 0);
<span class="lineNum">     268 </span>            :         assert(hevc-&gt;s_info.entry_point_start_bits &gt;= 0);
<span class="lineNum">     269 </span><span class="lineCov">      18750 :         header_end = (u64)hevc-&gt;s_info.header_size_bits;</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span><span class="lineCov">      18750 :         num_entry_point_start = (u32)hevc-&gt;s_info.entry_point_start_bits;</span>
<span class="lineNum">     272 </span><span class="lineCov">      18750 :         slice_qp_delta_start = (u32)hevc-&gt;s_info.slice_qp_delta_start_bits;</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :         // nal_unit_header                       
<span class="lineNum">     275 </span><span class="lineCov">      18750 :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 1), 1);</span>
<span class="lineNum">     276 </span><span class="lineCov">      18750 :         nal_unit_type = gf_bs_read_int(ctx-&gt;bs_nal_in, 6);</span>
<span class="lineNum">     277 </span><span class="lineCov">      18750 :         gf_bs_write_int(ctx-&gt;bs_nal_out, nal_unit_type, 6);</span>
<span class="lineNum">     278 </span><span class="lineCov">      18750 :         gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 9), 9);</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineCov">      18750 :         first_slice_segment_in_pic_flag = gf_bs_read_int(ctx-&gt;bs_nal_in, 1);    //first_slice_segment_in_pic_flag</span>
<span class="lineNum">     281 </span><span class="lineCov">      18750 :         if (tile_pid-&gt;slice_segment_address == 0)</span>
<span class="lineNum">     282 </span><span class="lineCov">       3750 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, 1, 1);</span>
<span class="lineNum">     283 </span>            :         else
<span class="lineNum">     284 </span><span class="lineCov">      15000 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, 0, 1);</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineCov">      18750 :         switch (nal_unit_type) {</span>
<span class="lineNum">     287 </span>            :         case GF_HEVC_NALU_SLICE_IDR_W_DLP:
<span class="lineNum">     288 </span>            :         case GF_HEVC_NALU_SLICE_IDR_N_LP:
<span class="lineNum">     289 </span>            :                 RapPicFlag = GF_TRUE;
<span class="lineNum">     290 </span>            :                 break;
<span class="lineNum">     291 </span>            :         case GF_HEVC_NALU_SLICE_BLA_W_LP:
<span class="lineNum">     292 </span>            :         case GF_HEVC_NALU_SLICE_BLA_W_DLP:
<span class="lineNum">     293 </span>            :         case GF_HEVC_NALU_SLICE_BLA_N_LP:
<span class="lineNum">     294 </span>            :         case GF_HEVC_NALU_SLICE_CRA:
<span class="lineNum">     295 </span>            :                 RapPicFlag = GF_TRUE;
<span class="lineNum">     296 </span>            :                 break;
<span class="lineNum">     297 </span>            :         }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :         if (RapPicFlag) {
<span class="lineNum">     300 </span>            :                 //no_output_of_prior_pics_flag
<span class="lineNum">     301 </span><span class="lineCov">        750 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 1), 1);</span>
<span class="lineNum">     302 </span>            :         }
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineCov">      18750 :         pps_id = gf_bs_read_ue(ctx-&gt;bs_nal_in);</span>
<span class="lineNum">     305 </span><span class="lineCov">      18750 :         gf_bs_write_ue(ctx-&gt;bs_nal_out, pps_id);</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :         pps = &amp;hevc-&gt;pps[pps_id];
<span class="lineNum">     308 </span><span class="lineCov">      18750 :         sps = &amp;hevc-&gt;sps[pps-&gt;sps_id];</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineCov">      18750 :         if (!first_slice_segment_in_pic_flag &amp;&amp; pps-&gt;dependent_slice_segments_enabled_flag) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                 dependent_slice_segment_flag = gf_bs_read_int(ctx-&gt;bs_nal_in, 1);</span>
<span class="lineNum">     312 </span>            :         } else {
<span class="lineNum">     313 </span>            :                 dependent_slice_segment_flag = GF_FALSE;
<span class="lineNum">     314 </span>            :         }
<span class="lineNum">     315 </span><span class="lineCov">      18750 :         if (!first_slice_segment_in_pic_flag) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                 /*address_ori = */gf_bs_read_int(ctx-&gt;bs_nal_in, sps-&gt;bitsSliceSegmentAddress);</span>
<span class="lineNum">     317 </span>            :         }
<span class="lineNum">     318 </span>            :         //else original slice segment address = 0
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineCov">      18750 :         if (tile_pid-&gt;slice_segment_address &gt; 0) {</span>
<span class="lineNum">     321 </span><span class="lineCov">      15000 :                 if (pps-&gt;dependent_slice_segments_enabled_flag) {</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :                         gf_bs_write_int(ctx-&gt;bs_nal_out, dependent_slice_segment_flag, 1);</span>
<span class="lineNum">     323 </span>            :                 }
<span class="lineNum">     324 </span><span class="lineCov">      15000 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, tile_pid-&gt;slice_segment_address, ctx-&gt;nb_bits_per_address_dst);</span>
<span class="lineNum">     325 </span>            :         }
<span class="lineNum">     326 </span>            :         //else first slice in pic, no address
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :         //copy over bits until start of slice_qp_delta
<span class="lineNum">     329 </span><span class="lineCov">     364500 :         while (slice_qp_delta_start != (gf_bs_get_position(ctx-&gt;bs_nal_in) - 1) * 8 + gf_bs_get_bit_position(ctx-&gt;bs_nal_in)) {</span>
<span class="lineNum">     330 </span><span class="lineCov">     345750 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 1), 1);</span>
<span class="lineNum">     331 </span>            :         }
<span class="lineNum">     332 </span>            :         //compute new qp delta
<span class="lineNum">     333 </span><span class="lineCov">      18750 :         new_slice_qp_delta = hevc-&gt;s_info.pps-&gt;pic_init_qp_minus26 + hevc-&gt;s_info.slice_qp_delta - ctx-&gt;base_pps_init_qp_delta_minus26;</span>
<span class="lineNum">     334 </span><span class="lineCov">      18750 :         gf_bs_write_se(ctx-&gt;bs_nal_out, new_slice_qp_delta);</span>
<span class="lineNum">     335 </span><span class="lineCov">      18750 :         gf_bs_read_se(ctx-&gt;bs_nal_in);</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :         //copy over until num_entry_points
<span class="lineNum">     338 </span><span class="lineCov">      37500 :         while (num_entry_point_start != (gf_bs_get_position(ctx-&gt;bs_nal_in) - 1) * 8 + gf_bs_get_bit_position(ctx-&gt;bs_nal_in)) {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, gf_bs_read_int(ctx-&gt;bs_nal_in, 1), 1);</span>
<span class="lineNum">     340 </span>            :         }
<span class="lineNum">     341 </span>            :         //write num_entry_points to 0 (always present since we use tiling)
<span class="lineNum">     342 </span><span class="lineCov">      18750 :         gf_bs_write_ue(ctx-&gt;bs_nal_out, 0);</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :         //write slice extension to 0
<span class="lineNum">     345 </span><span class="lineCov">      18750 :         if (pps-&gt;slice_segment_header_extension_present_flag)</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                 gf_bs_write_int(ctx-&gt;bs_nal_out, 0, 1);</span>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :         //we may have unparsed data in the source bitstream (slice header) due to entry points or slice segment extensions
<span class="lineNum">     350 </span>            :         //TODO: we might want to copy over the slice extension header bits
<span class="lineNum">     351 </span><span class="lineCov">      18750 :         while (header_end != (gf_bs_get_position(ctx-&gt;bs_nal_in) - 1) * 8 + gf_bs_get_bit_position(ctx-&gt;bs_nal_in))</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :                 gf_bs_read_int(ctx-&gt;bs_nal_in, 1);</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :         //read byte_alignment() is bit=1 + x bit=0
<span class="lineNum">     355 </span><span class="lineCov">      18750 :         al = gf_bs_read_int(ctx-&gt;bs_nal_in, 1);</span>
<span class="lineNum">     356 </span><span class="lineCov">      18750 :         if (al != 1) {</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] source slice header not properly aligned\n&quot;));</span>
<span class="lineNum">     358 </span>            :         }
<span class="lineNum">     359 </span><span class="lineCov">      18750 :         gf_bs_align(ctx-&gt;bs_nal_in);</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :         //write byte_alignment() is bit=1 + x bit=0
<span class="lineNum">     362 </span><span class="lineCov">      18750 :         gf_bs_write_int(ctx-&gt;bs_nal_out, 1, 1);</span>
<span class="lineNum">     363 </span><span class="lineCov">      18750 :         gf_bs_align(ctx-&gt;bs_nal_out);        // align</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :         //get the final slice header
<span class="lineNum">     366 </span><span class="lineCov">      18750 :         gf_bs_get_content_no_truncate(ctx-&gt;bs_nal_out, &amp;ctx-&gt;buffer_nal_no_epb, &amp;out_slice_size_no_epb, &amp;ctx-&gt;buffer_nal_no_epb_alloc);</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :         //get the slice payload size (no EPB in it) and offset in payload
<span class="lineNum">     369 </span><span class="lineCov">      18750 :         slice_size = (u32) gf_bs_available(ctx-&gt;bs_nal_in);</span>
<span class="lineNum">     370 </span><span class="lineCov">      18750 :         slice_offset_orig = (u32) gf_bs_get_position(ctx-&gt;bs_nal_in);</span>
<span class="lineNum">     371 </span>            :         //slice data offset in output slice
<span class="lineNum">     372 </span><span class="lineCov">      18750 :         slice_offset_dst = out_slice_size_no_epb;</span>
<span class="lineNum">     373 </span>            :         //update output slice size
<span class="lineNum">     374 </span><span class="lineCov">      18750 :         out_slice_size_no_epb += slice_size;</span>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :         //copy slice data
<span class="lineNum">     377 </span><span class="lineCov">      18750 :         if (ctx-&gt;buffer_nal_no_epb_alloc &lt; out_slice_size_no_epb) {</span>
<span class="lineNum">     378 </span><span class="lineCov">         21 :                 ctx-&gt;buffer_nal_no_epb_alloc = out_slice_size_no_epb;</span>
<span class="lineNum">     379 </span><span class="lineCov">         21 :                 ctx-&gt;buffer_nal_no_epb = gf_realloc(ctx-&gt;buffer_nal_no_epb, out_slice_size_no_epb);</span>
<span class="lineNum">     380 </span>            :         }
<span class="lineNum">     381 </span><span class="lineCov">      18750 :         memcpy(ctx-&gt;buffer_nal_no_epb + slice_offset_dst, ctx-&gt;buffer_nal_in_no_epb + slice_offset_orig, sizeof(char) * slice_size);</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :         //insert epb
<span class="lineNum">     384 </span><span class="lineCov">      18750 :         out_slice_length = out_slice_size_no_epb + gf_media_nalu_emulation_bytes_add_count(ctx-&gt;buffer_nal_no_epb, out_slice_size_no_epb);</span>
<span class="lineNum">     385 </span><span class="lineCov">      18750 :         if (ctx-&gt;buffer_nal_alloc &lt; out_slice_length) {</span>
<span class="lineNum">     386 </span><span class="lineCov">         26 :                 ctx-&gt;buffer_nal_alloc = out_slice_length;</span>
<span class="lineNum">     387 </span><span class="lineCov">         26 :                 ctx-&gt;buffer_nal = gf_realloc(ctx-&gt;buffer_nal, out_slice_length);</span>
<span class="lineNum">     388 </span>            :         }
<span class="lineNum">     389 </span><span class="lineCov">      18750 :         gf_media_nalu_add_emulation_bytes(ctx-&gt;buffer_nal_no_epb, ctx-&gt;buffer_nal, out_slice_size_no_epb);</span>
<span class="lineNum">     390 </span><span class="lineCov">      18750 :         return out_slice_length;</span>
<a name="391"><span class="lineNum">     391 </span>            : }</a>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineCov">         25 : static GF_Err hevcmerge_rewrite_config(GF_HEVCMergeCtx *ctx, GF_FilterPid *opid, char *data, u32 size)</span>
<span class="lineNum">     394 </span>            : {
<span class="lineNum">     395 </span>            :         u32 i, j;
<span class="lineNum">     396 </span>            :         u8 *new_dsi;
<span class="lineNum">     397 </span>            :         u32 new_size;
<span class="lineNum">     398 </span><span class="lineCov">         25 :         GF_HEVCConfig *hvcc = gf_odf_hevc_cfg_read(data, size, GF_FALSE);</span>
<span class="lineNum">     399 </span><span class="lineCov">         25 :         if (!hvcc) return GF_NON_COMPLIANT_BITSTREAM;</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :         // for all the list objects in param_array
<span class="lineNum">     402 </span><span class="lineCov">         75 :         for (i = 0; i &lt; gf_list_count(hvcc-&gt;param_array); i++) { // hvcc-&gt;param_array:list object</span>
<span class="lineNum">     403 </span><span class="lineCov">         75 :                 GF_NALUFFParamArray *ar = (GF_NALUFFParamArray *) gf_list_get(hvcc-&gt;param_array, i); // ar contains the i-th item in param_array</span>
<span class="lineNum">     404 </span><span class="lineCov">        150 :                 for (j = 0; j &lt; gf_list_count(ar-&gt;nalus); j++) { // for all the nalus the i-th param got</span>
<span class="lineNum">     405 </span>            :                         /*! used for storing AVC sequenceParameterSetNALUnit and pictureParameterSetNALUnit*/
<span class="lineNum">     406 </span><span class="lineCov">         75 :                         GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar-&gt;nalus, j); // store j-th nalus in *sl</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineCov">         75 :                         if (ar-&gt;type == GF_HEVC_NALU_SEQ_PARAM) {</span>
<span class="lineNum">     409 </span><span class="lineCov">         25 :                                 char *outSPS=NULL;</span>
<span class="lineNum">     410 </span><span class="lineCov">         25 :                                 u32 outSize=0;</span>
<span class="lineNum">     411 </span><span class="lineCov">         25 :                                 hevc_rewrite_sps(sl-&gt;data, sl-&gt;size, ctx-&gt;out_width, ctx-&gt;out_height, &amp;outSPS, &amp;outSize);</span>
<span class="lineNum">     412 </span><span class="lineCov">         25 :                                 gf_free(sl-&gt;data);</span>
<span class="lineNum">     413 </span><span class="lineCov">         25 :                                 sl-&gt;data = outSPS;</span>
<span class="lineNum">     414 </span><span class="lineCov">         25 :                                 sl-&gt;size = outSize;</span>
<span class="lineNum">     415 </span>            :                         }
<span class="lineNum">     416 </span><span class="lineCov">         50 :                         else if (ar-&gt;type == GF_HEVC_NALU_VID_PARAM) {</span>
<span class="lineNum">     417 </span>            :                         }
<span class="lineNum">     418 </span><span class="lineCov">         25 :                         else if (ar-&gt;type == GF_HEVC_NALU_PIC_PARAM) {</span>
<span class="lineNum">     419 </span><span class="lineCov">         25 :                                 char *outPPS=NULL;</span>
<span class="lineNum">     420 </span><span class="lineCov">         25 :                                 u32 outSize=0;</span>
<span class="lineNum">     421 </span><span class="lineCov">         25 :                                 hevcmerge_rewrite_pps(ctx, sl-&gt;data, sl-&gt;size, &amp;outPPS, &amp;outSize);</span>
<span class="lineNum">     422 </span><span class="lineCov">         25 :                                 gf_free(sl-&gt;data);</span>
<span class="lineNum">     423 </span><span class="lineCov">         25 :                                 sl-&gt;data = outPPS;</span>
<span class="lineNum">     424 </span><span class="lineCov">         25 :                                 sl-&gt;size = outSize;</span>
<span class="lineNum">     425 </span>            :                         }
<span class="lineNum">     426 </span>            :                 }
<span class="lineNum">     427 </span>            :         }
<span class="lineNum">     428 </span><span class="lineCov">         25 :         gf_odf_hevc_cfg_write(hvcc, &amp;new_dsi, &amp;new_size);</span>
<span class="lineNum">     429 </span><span class="lineCov">         25 :         gf_odf_hevc_cfg_del(hvcc);</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineCov">         25 :         gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &amp;PROP_DATA_NO_COPY(new_dsi, new_size));</span>
<span class="lineNum">     432 </span><span class="lineCov">         25 :         return GF_OK;</span>
<span class="lineNum">     433 </span>            : }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : static void hevcmerge_write_nal(GF_HEVCMergeCtx *ctx, char *output_nal, char *rewritten_nal, u32 out_nal_size)
<span class="lineNum">     436 </span>            : {
<span class="lineNum">     437 </span><span class="lineCov">      22505 :         u32 n = 8*(ctx-&gt;hevc_nalu_size_length);</span>
<span class="lineNum">     438 </span><span class="lineCov">     112525 :         while (n) {</span>
<span class="lineNum">     439 </span><span class="lineCov">      90020 :                 u32 v = (out_nal_size &gt;&gt; (n-8)) &amp; 0xFF;</span>
<span class="lineNum">     440 </span><span class="lineCov">      90020 :                 *output_nal = v;</span>
<span class="lineNum">     441 </span><span class="lineCov">      90020 :                 output_nal++;</span>
<span class="lineNum">     442 </span>            :                 n-=8;
<span class="lineNum">     443 </span>            :         }
<span class="lineNum">     444 </span><span class="lineCov">      22505 :         memcpy(output_nal, rewritten_nal, out_nal_size);</span>
<a name="445"><span class="lineNum">     445 </span>            : }</a>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineCov">        102 : static u32 hevcmerge_compute_address(GF_HEVCMergeCtx *ctx, HEVCTilePidCtx *tile_pid, Bool use_y_coord)</span>
<span class="lineNum">     448 </span>            : {
<span class="lineNum">     449 </span>            :         u32 i, nb_pids, sum_height = 0, sum_width = 0;
<span class="lineNum">     450 </span><span class="lineCov">        163 :         for (i=0; i&lt;tile_pid-&gt;pos_col; i++) {</span>
<span class="lineNum">     451 </span><span class="lineCov">         61 :                 sum_width += ctx-&gt;grid[i].width / ctx-&gt;max_CU_width;</span>
<span class="lineNum">     452 </span>            :         }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">        102 :         if (use_y_coord) {</span>
<span class="lineNum">     455 </span><span class="lineCov">         96 :                 sum_height = tile_pid-&gt;pos_y / ctx-&gt;max_CU_height;</span>
<span class="lineNum">     456 </span>            :         } else {
<span class="lineNum">     457 </span><span class="lineCov">          6 :                 nb_pids = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">     458 </span><span class="lineCov">         14 :                 for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     459 </span><span class="lineCov">          8 :                         HEVCTilePidCtx *actx = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     460 </span><span class="lineCov">          8 :                         if (actx-&gt;pos_col == tile_pid-&gt;pos_col) {</span>
<span class="lineNum">     461 </span><span class="lineCov">          6 :                                 if (actx-&gt;pos_row&lt;tile_pid-&gt;pos_row) {</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                                         sum_height += actx-&gt;height / ctx-&gt;max_CU_height;</span>
<span class="lineNum">     463 </span>            :                                 }
<span class="lineNum">     464 </span>            :                         }
<span class="lineNum">     465 </span>            :                 }
<span class="lineNum">     466 </span>            :         }
<span class="lineNum">     467 </span><span class="lineCov">        102 :         return sum_height * (ctx-&gt;out_width / ctx-&gt;max_CU_width) + sum_width;</span>
<a name="468"><span class="lineNum">     468 </span>            : }</a>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">         25 : void hevcmerge_build_srdmap(GF_HEVCMergeCtx *ctx, Bool use_abs_pos)</span>
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span>            :         GF_PropertyValue srdmap;
<span class="lineNum">     473 </span>            :         u32 i, nb_pids;
<span class="lineNum">     474 </span>            :         Bool srd_map_valid = GF_TRUE;
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">         25 :         if (!ctx-&gt;out_width || !ctx-&gt;out_height) {</span>
<span class="lineNum">     477 </span><span class="lineCov">          1 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD_MAP, NULL);</span>
<span class="lineNum">     478 </span><span class="lineCov">          1 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD_REF, NULL);</span>
<span class="lineNum">     479 </span><span class="lineCov">          1 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD, NULL);</span>
<span class="lineNum">     480 </span><span class="lineCov">          1 :                 return;</span>
<span class="lineNum">     481 </span>            :         }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">         24 :         nb_pids = gf_list_count(ctx-&gt;ordered_pids);</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :         memset(&amp;srdmap, 0, sizeof(GF_PropertyValue));
<span class="lineNum">     487 </span><span class="lineCov">         24 :         srdmap.type = GF_PROP_UINT_LIST;</span>
<span class="lineNum">     488 </span>            :         //8 integers per PID
<span class="lineNum">     489 </span><span class="lineCov">         24 :         srdmap.value.uint_list.nb_items = nb_pids*8;</span>
<span class="lineNum">     490 </span><span class="lineCov">         24 :         srdmap.value.uint_list.vals = gf_malloc(sizeof(s32)*nb_pids*8);</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :         s32 *vals = srdmap.value.uint_list.vals;
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineCov">        125 :         for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     495 </span>            :                 s32 tile_x, tile_y;
<span class="lineNum">     496 </span>            :                 u32 width_in_CU, nb_cols, nb_rows;
<span class="lineNum">     497 </span>            :                 s32 x=0, y=0, w=0, h=0, srd_x, srd_y, srd_w, srd_h;
<span class="lineNum">     498 </span><span class="lineCov">        101 :                 HEVCTilePidCtx *tile = gf_list_get(ctx-&gt;ordered_pids, i);</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineCov">        101 :                 const GF_PropertyValue *srd = gf_filter_pid_get_property(tile-&gt;pid, GF_PROP_PID_SRD);</span>
<span class="lineNum">     501 </span><span class="lineCov">        101 :                 const GF_PropertyValue *srd_ref = gf_filter_pid_get_property(tile-&gt;pid, GF_PROP_PID_SRD_REF);</span>
<span class="lineNum">     502 </span><span class="lineCov">        101 :                 const GF_PropertyValue *crop_pos = gf_filter_pid_get_property(tile-&gt;pid, GF_PROP_PID_CROP_POS);</span>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :                 //get original SRD of the PID, translate into output referential {out_width,out_height}
<span class="lineNum">     505 </span><span class="lineCov">        101 :                 if (srd &amp;&amp; srd_ref) {</span>
<span class="lineNum">     506 </span><span class="lineCov">         96 :                         srd_x = srd-&gt;value.vec4i.x;</span>
<span class="lineNum">     507 </span><span class="lineCov">         96 :                         srd_y = srd-&gt;value.vec4i.y;</span>
<span class="lineNum">     508 </span><span class="lineCov">         96 :                         srd_w = srd-&gt;value.vec4i.z;</span>
<span class="lineNum">     509 </span><span class="lineCov">         96 :                         srd_h = srd-&gt;value.vec4i.w;</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">         96 :                         if (srd_ref-&gt;value.vec2i.x != 0) {</span>
<span class="lineNum">     512 </span><span class="lineCov">         96 :                                 x = (srd_x * ctx-&gt;out_width) / srd_ref-&gt;value.vec2i.x;</span>
<span class="lineNum">     513 </span><span class="lineCov">         96 :                                 w = (srd_w * ctx-&gt;out_width) / srd_ref-&gt;value.vec2i.x;</span>
<span class="lineNum">     514 </span>            :                         } else {
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (&quot;[HEVCMerge] width=0 in source pid SRD referential, cannot output SRD map\n&quot; ));</span>
<span class="lineNum">     516 </span>            :                                 srd_map_valid = GF_FALSE;
<span class="lineNum">     517 </span>            :                                 break;
<span class="lineNum">     518 </span>            :                         }
<span class="lineNum">     519 </span><span class="lineCov">         96 :                         if (srd_ref-&gt;value.vec2i.y != 0) {</span>
<span class="lineNum">     520 </span><span class="lineCov">         96 :                                 y = (srd_y * ctx-&gt;out_height) / srd_ref-&gt;value.vec2i.y;</span>
<span class="lineNum">     521 </span><span class="lineCov">         96 :                                 h = (srd_h * ctx-&gt;out_height) / srd_ref-&gt;value.vec2i.y;</span>
<span class="lineNum">     522 </span>            :                         } else {
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (&quot;[HEVCMerge] height=0 in source pid SRD referential, undefined results\n&quot; ));</span>
<span class="lineNum">     524 </span>            :                                 srd_map_valid = GF_FALSE;
<span class="lineNum">     525 </span>            :                                 break;
<span class="lineNum">     526 </span>            :                         }
<span class="lineNum">     527 </span><span class="lineCov">          5 :                 } else if (crop_pos) {</span>
<span class="lineNum">     528 </span><span class="lineCov">          5 :                         x = crop_pos-&gt;value.vec2i.x;</span>
<span class="lineNum">     529 </span><span class="lineCov">          5 :                         y = crop_pos-&gt;value.vec2i.y;</span>
<span class="lineNum">     530 </span><span class="lineCov">          5 :                         w = (s32)(tile-&gt;width);</span>
<span class="lineNum">     531 </span><span class="lineCov">          5 :                         h = (s32)(tile-&gt;height);</span>
<span class="lineNum">     532 </span>            :                 } else {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (&quot;[HEVCMerge] SRD, SRD_REF and CROP_POS are not defined for source pid, undefined results\n&quot; ));</span>
<span class="lineNum">     534 </span>            :                         srd_map_valid = GF_FALSE;
<span class="lineNum">     535 </span>            :                         break;
<span class="lineNum">     536 </span>            :                 }
<span class="lineNum">     537 </span><span class="lineCov">        101 :                 vals[8*i] = x;</span>
<span class="lineNum">     538 </span><span class="lineCov">        101 :                 vals[8*i+1] = y;</span>
<span class="lineNum">     539 </span><span class="lineCov">        101 :                 vals[8*i+2] = w;</span>
<span class="lineNum">     540 </span><span class="lineCov">        101 :                 vals[8*i+3] = h;</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            :                 //get final position in the recomputed video, expressed in output referential {out_width,out_height}
<span class="lineNum">     543 </span>            :                 //we recompute the position directly from the slice segment address
<span class="lineNum">     544 </span><span class="lineCov">        101 :                 width_in_CU = ctx-&gt;out_width / ctx-&gt;max_CU_width;</span>
<span class="lineNum">     545 </span><span class="lineCov">        101 :                 nb_cols = tile-&gt;slice_segment_address % width_in_CU;</span>
<span class="lineNum">     546 </span><span class="lineCov">        101 :                 nb_rows = (tile-&gt;slice_segment_address - nb_cols) / width_in_CU;</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :                 assert(tile-&gt;slice_segment_address == (nb_rows * width_in_CU + nb_cols));
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :                 //tile_x and tile_y should start at zero
<span class="lineNum">     551 </span><span class="lineCov">        101 :                 tile_x = use_abs_pos ? nb_cols * ctx-&gt;max_CU_width  : nb_cols;</span>
<span class="lineNum">     552 </span><span class="lineCov">        101 :                 tile_y = use_abs_pos ? nb_rows * ctx-&gt;max_CU_height : nb_rows;</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineCov">        101 :                 vals[8*i+4] = (tile_x * ctx-&gt;out_width) / ctx-&gt;out_width;</span>
<span class="lineNum">     555 </span><span class="lineCov">        101 :                 vals[8*i+5] = (tile_y * ctx-&gt;out_height) / ctx-&gt;out_height;</span>
<span class="lineNum">     556 </span><span class="lineCov">        101 :                 vals[8*i+6] = (tile-&gt;width * ctx-&gt;out_width) / ctx-&gt;out_width;</span>
<span class="lineNum">     557 </span><span class="lineCov">        101 :                 vals[8*i+7] = (tile-&gt;height * ctx-&gt;out_height) / ctx-&gt;out_height;</span>
<span class="lineNum">     558 </span>            :         }
<span class="lineNum">     559 </span>            :         if (srd_map_valid)
<span class="lineNum">     560 </span><span class="lineCov">         24 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD_MAP, &amp;srdmap);</span>
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineCov">         24 :         gf_free(srdmap.value.uint_list.vals);</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :         //assign reference space
<span class="lineNum">     565 </span><span class="lineCov">         24 :         gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD_REF, &amp;PROP_VEC2I_INT(ctx-&gt;out_width, ctx-&gt;out_height));</span>
<span class="lineNum">     566 </span>            :         //remove any SRD copied from inputs - we could also create an SRD {0,0,out_width,out_height}
<span class="lineNum">     567 </span><span class="lineCov">         24 :         gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD, NULL);</span>
<a name="568"><span class="lineNum">     568 </span>            : }</a>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">         25 : static GF_Err hevcmerge_rebuild_grid(GF_HEVCMergeCtx *ctx,  GF_FilterPid *pid)</span>
<span class="lineNum">     571 </span>            : {
<span class="lineNum">     572 </span>            :         u32 nb_cols=0;
<span class="lineNum">     573 </span>            :         u32 nb_rows=0;
<span class="lineNum">     574 </span>            :         Bool reorder_rows=GF_FALSE;
<span class="lineNum">     575 </span>            :         u32 force_last_col_plus_one=0;
<span class="lineNum">     576 </span>            :         u32 nb_has_pos=0, nb_no_pos=0, nb_rel_pos=0, nb_abs_pos=0;
<span class="lineNum">     577 </span>            :         u32 min_rel_pos_x = (u32) -1;
<span class="lineNum">     578 </span>            :         u32 min_rel_pos_y = (u32) -1;
<span class="lineNum">     579 </span><span class="lineCov">         25 :         u32 i, j, max_cols, nb_pids = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span><span class="lineCov">        102 :         for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     582 </span><span class="lineCov">        102 :                 HEVCTilePidCtx *apidctx = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     583 </span><span class="lineCov">        102 :                 if (apidctx-&gt;width % ctx-&gt;max_CU_width) nb_cols++;</span>
<span class="lineNum">     584 </span><span class="lineCov">        102 :                 if (apidctx-&gt;height % ctx-&gt;max_CU_height) nb_rows++;</span>
<span class="lineNum">     585 </span><span class="lineCov">        102 :                 if (apidctx-&gt;has_pos) {</span>
<span class="lineNum">     586 </span><span class="lineCov">        102 :                         nb_has_pos++;</span>
<span class="lineNum">     587 </span><span class="lineCov">        102 :                         if ((apidctx-&gt;pos_x&lt;0) || (apidctx-&gt;pos_y&lt;0)) {</span>
<span class="lineNum">     588 </span><span class="lineCov">          2 :                                 nb_rel_pos++;</span>
<span class="lineNum">     589 </span>            :                         }
<span class="lineNum">     590 </span><span class="lineCov">        100 :                         else if ((apidctx-&gt;pos_x&gt;0) || (apidctx-&gt;pos_y&gt;0)) nb_abs_pos++;</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineCov">        102 :                         if ((apidctx-&gt;pos_x&lt;=0) &amp;&amp; ((u32) (-apidctx-&gt;pos_x) &lt; min_rel_pos_x))</span>
<span class="lineNum">     593 </span>            :                                 min_rel_pos_x = -apidctx-&gt;pos_x;
<span class="lineNum">     594 </span><span class="lineCov">        102 :                         if ((apidctx-&gt;pos_y&lt;=0) &amp;&amp; ((u32) (-apidctx-&gt;pos_y) &lt; min_rel_pos_y))</span>
<span class="lineNum">     595 </span>            :                                 min_rel_pos_y = -apidctx-&gt;pos_y;
<span class="lineNum">     596 </span>            :                 } else {
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :                         nb_no_pos++;</span>
<span class="lineNum">     598 </span>            :                 }
<span class="lineNum">     599 </span>            :         }
<span class="lineNum">     600 </span><span class="lineCov">         25 :         if ((nb_cols&gt;1) &amp;&amp; (nb_rows&gt;1)) {</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Cannot merge more than one tile not a multiple of CTUs in both width and height, not possible in standard\n&quot;));</span>
<span class="lineNum">     602 </span>            :                 return GF_BAD_PARAM;
<span class="lineNum">     603 </span>            :         }
<span class="lineNum">     604 </span><span class="lineCov">         25 :         if (nb_has_pos &amp;&amp; nb_no_pos) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Cannot merge tiles with explicit positioning and tiles with implicit positioning, not supported\n&quot;));</span>
<span class="lineNum">     606 </span>            :                 return GF_BAD_PARAM;
<span class="lineNum">     607 </span>            :         }
<span class="lineNum">     608 </span><span class="lineCov">         25 :         if (nb_rel_pos &amp;&amp; nb_abs_pos) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Cannot merge tiles with both relative explicit positioning and absolute explicit positioning, not supported\n&quot;));</span>
<span class="lineNum">     610 </span>            :                 return GF_BAD_PARAM;
<span class="lineNum">     611 </span>            :         }
<span class="lineNum">     612 </span><span class="lineCov">         25 :         if (ctx-&gt;grid) gf_free(ctx-&gt;grid);</span>
<span class="lineNum">     613 </span><span class="lineCov">         25 :         ctx-&gt;grid = NULL;</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">         25 :         if (min_rel_pos_x == (u32)-1) min_rel_pos_x=0;</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineCov">         25 :         if (nb_has_pos) {</span>
<span class="lineNum">     618 </span>            :                 max_cols = 0;
<span class="lineNum">     619 </span><span class="lineCov">        102 :                 for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     620 </span><span class="lineCov">        102 :                         HEVCTilePidCtx *tile1 = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     621 </span><span class="lineCov">        102 :                         if (!tile1-&gt;has_pos) continue;</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineCov">        594 :                         for (j=0; j&lt;nb_pids; j++) {</span>
<span class="lineNum">     624 </span>            :                                 Bool overlap = GF_FALSE;
<span class="lineNum">     625 </span><span class="lineCov">        594 :                                 HEVCTilePidCtx *tile2 = gf_list_get(ctx-&gt;pids, j);</span>
<span class="lineNum">     626 </span><span class="lineCov">        594 :                                 if (tile2 == tile1) continue;</span>
<span class="lineNum">     627 </span><span class="lineCov">        492 :                                 if (!tile2-&gt;has_pos) continue;</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :                                 //for relative positioning, only check we don't have the same indexes
<span class="lineNum">     630 </span><span class="lineCov">        492 :                                 if (nb_rel_pos) {</span>
<span class="lineNum">     631 </span><span class="lineCov">          2 :                                         continue;</span>
<span class="lineNum">     632 </span>            :                                 }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :                                 //make sure we are aligned
<span class="lineNum">     635 </span><span class="lineCov">        490 :                                 if ((tile1-&gt;pos_x&lt;tile2-&gt;pos_x) &amp;&amp; (tile1-&gt;pos_x + (s32) tile1-&gt;width &gt; tile2-&gt;pos_x)) {</span>
<span class="lineNum">     636 </span>            :                                         overlap = GF_TRUE;
<span class="lineNum">     637 </span>            :                                 }
<span class="lineNum">     638 </span><span class="lineCov">        490 :                                 else if ((tile1-&gt;pos_x==tile2-&gt;pos_x) &amp;&amp; (tile1-&gt;width != tile2-&gt;width)) {</span>
<span class="lineNum">     639 </span>            :                                         overlap = GF_TRUE;
<span class="lineNum">     640 </span>            :                                 }
<span class="lineNum">     641 </span><span class="lineCov">        490 :                                 if (tile1-&gt;pos_x==tile2-&gt;pos_x) {</span>
<span class="lineNum">     642 </span><span class="lineCov">        156 :                                         if ((tile1-&gt;pos_y&lt;tile2-&gt;pos_y) &amp;&amp; (tile1-&gt;pos_y + (s32) tile1-&gt;height &gt; tile2-&gt;pos_y)) {</span>
<span class="lineNum">     643 </span>            :                                                 overlap = GF_TRUE;
<span class="lineNum">     644 </span>            :                                         }
<span class="lineNum">     645 </span><span class="lineCov">        156 :                                         else if ((tile1-&gt;pos_y==tile2-&gt;pos_y) &amp;&amp; (tile1-&gt;height != tile2-&gt;height)) {</span>
<span class="lineNum">     646 </span>            :                                                 overlap = GF_TRUE;
<span class="lineNum">     647 </span>            :                                         }
<span class="lineNum">     648 </span>            :                                 }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineCov">        490 :                                 if (overlap) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Overlapping tiles detected, cannot merge\n&quot;));</span>
<span class="lineNum">     652 </span>            :                                         return GF_BAD_PARAM;
<span class="lineNum">     653 </span>            :                                 }
<span class="lineNum">     654 </span>            :                         }
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span><span class="lineCov">        102 :                         if (!max_cols) {</span>
<span class="lineNum">     657 </span><span class="lineCov">         25 :                                 ctx-&gt;grid = gf_malloc(sizeof(HEVCGridInfo));</span>
<span class="lineNum">     658 </span>            :                                 memset(&amp;ctx-&gt;grid[0], 0, sizeof(HEVCGridInfo));
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineCov">         25 :                                 ctx-&gt;grid[0].width = tile1-&gt;width;</span>
<span class="lineNum">     661 </span><span class="lineCov">         25 :                                 if (nb_rel_pos) {</span>
<span class="lineNum">     662 </span><span class="lineCov">          2 :                                         ctx-&gt;grid[0].pos_x = -tile1-&gt;pos_x - min_rel_pos_x;</span>
<span class="lineNum">     663 </span>            :                                 } else {
<span class="lineNum">     664 </span><span class="lineCov">         23 :                                         ctx-&gt;grid[0].pos_x = tile1-&gt;pos_x;</span>
<span class="lineNum">     665 </span>            :                                 }
<span class="lineNum">     666 </span>            :                                 max_cols=1;
<span class="lineNum">     667 </span><span class="lineCov">         77 :                         } else if (ctx-&gt;grid[max_cols-1].pos_x != tile1-&gt;pos_x) {</span>
<span class="lineNum">     668 </span><span class="lineCov">         23 :                                 if (nb_rel_pos) {</span>
<span class="lineNum">     669 </span>            :                                         //append
<span class="lineNum">     670 </span><span class="lineCov">          1 :                                         if (ctx-&gt;grid[max_cols-1].pos_x &lt;(u32) -tile1-&gt;pos_x) {</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;grid = gf_realloc(ctx-&gt;grid, sizeof(HEVCGridInfo) * (max_cols+1) );</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :                                                 memset(&amp;ctx-&gt;grid[max_cols], 0, sizeof(HEVCGridInfo));</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;grid[max_cols].width = tile1-&gt;width;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :                                                 ctx-&gt;grid[max_cols].pos_x = -tile1-&gt;pos_x;</span>
<span class="lineNum">     675 </span>            :                                                 max_cols+=1;
<span class="lineNum">     676 </span>            :                                         }
<span class="lineNum">     677 </span>            :                                         //insert
<span class="lineNum">     678 </span>            :                                         else {
<span class="lineNum">     679 </span>            :                                                 Bool found=GF_FALSE;
<span class="lineNum">     680 </span><span class="lineCov">          1 :                                                 for (j=0; j&lt;max_cols; j++) {</span>
<span class="lineNum">     681 </span><span class="lineCov">          1 :                                                         if (ctx-&gt;grid[j].pos_x == -tile1-&gt;pos_x) {</span>
<span class="lineNum">     682 </span>            :                                                                 found=GF_TRUE;
<span class="lineNum">     683 </span>            :                                                                 break;
<span class="lineNum">     684 </span>            :                                                         }
<span class="lineNum">     685 </span>            :                                                 }
<span class="lineNum">     686 </span><span class="lineCov">          1 :                                                 if (!found) {</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                                                         for (j=0; j&lt;max_cols; j++) {</span>
<span class="lineNum">     688 </span><span class="lineCov">          1 :                                                                 if (ctx-&gt;grid[j].pos_x &gt; (u32) -tile1-&gt;pos_x) {</span>
<span class="lineNum">     689 </span><span class="lineCov">          1 :                                                                         ctx-&gt;grid = gf_realloc(ctx-&gt;grid, sizeof(HEVCGridInfo) * (max_cols+1) );</span>
<span class="lineNum">     690 </span><span class="lineCov">          1 :                                                                         memmove(&amp;ctx-&gt;grid[j+1], &amp;ctx-&gt;grid[j], sizeof(HEVCGridInfo) * (max_cols-j));</span>
<span class="lineNum">     691 </span><span class="lineCov">          1 :                                                                         memset(&amp;ctx-&gt;grid[j], 0, sizeof(HEVCGridInfo));</span>
<span class="lineNum">     692 </span><span class="lineCov">          1 :                                                                         ctx-&gt;grid[j].width = tile1-&gt;width;</span>
<span class="lineNum">     693 </span><span class="lineCov">          1 :                                                                         ctx-&gt;grid[j].pos_x = -tile1-&gt;pos_x;</span>
<span class="lineNum">     694 </span>            :                                                                         max_cols+=1;
<span class="lineNum">     695 </span>            :                                                                         break;
<span class="lineNum">     696 </span>            :                                                                 }
<span class="lineNum">     697 </span>            :                                                         }
<span class="lineNum">     698 </span>            :                                                 }
<span class="lineNum">     699 </span>            :                                         }
<span class="lineNum">     700 </span>            :                                 } else {
<span class="lineNum">     701 </span>            :                                         //append
<span class="lineNum">     702 </span><span class="lineCov">         22 :                                         if (ctx-&gt;grid[max_cols-1].pos_x + ctx-&gt;grid[max_cols-1].width &lt;= (u32) tile1-&gt;pos_x) {</span>
<span class="lineNum">     703 </span><span class="lineCov">         21 :                                                 ctx-&gt;grid = gf_realloc(ctx-&gt;grid, sizeof(HEVCGridInfo) * (max_cols+1) );</span>
<span class="lineNum">     704 </span><span class="lineCov">         21 :                                                 memset(&amp;ctx-&gt;grid[max_cols], 0, sizeof(HEVCGridInfo));</span>
<span class="lineNum">     705 </span><span class="lineCov">         21 :                                                 ctx-&gt;grid[max_cols].width = tile1-&gt;width;</span>
<span class="lineNum">     706 </span><span class="lineCov">         21 :                                                 ctx-&gt;grid[max_cols].pos_x = tile1-&gt;pos_x;</span>
<span class="lineNum">     707 </span>            :                                                 max_cols+=1;
<span class="lineNum">     708 </span>            :                                         }
<span class="lineNum">     709 </span>            :                                         //insert
<span class="lineNum">     710 </span>            :                                         else {
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :                                                 for (j=0; j&lt;max_cols; j++) {</span>
<span class="lineNum">     712 </span><span class="lineCov">          1 :                                                         if (ctx-&gt;grid[j].pos_x == (u32) tile1-&gt;pos_x) {</span>
<span class="lineNum">     713 </span>            :                                                                 break;
<span class="lineNum">     714 </span>            :                                                         }
<span class="lineNum">     715 </span><span class="lineCov">          1 :                                                         if (ctx-&gt;grid[j].pos_x &gt; (u32) tile1-&gt;pos_x) {</span>
<span class="lineNum">     716 </span><span class="lineCov">          1 :                                                                 ctx-&gt;grid = gf_realloc(ctx-&gt;grid, sizeof(HEVCGridInfo) * (max_cols+1) );</span>
<span class="lineNum">     717 </span><span class="lineCov">          1 :                                                                 memmove(&amp;ctx-&gt;grid[j+1], &amp;ctx-&gt;grid[j], sizeof(HEVCGridInfo) * (max_cols-j));</span>
<span class="lineNum">     718 </span><span class="lineCov">          1 :                                                                 memset(&amp;ctx-&gt;grid[j], 0, sizeof(HEVCGridInfo));</span>
<span class="lineNum">     719 </span><span class="lineCov">          1 :                                                                 ctx-&gt;grid[j].width = tile1-&gt;width;</span>
<span class="lineNum">     720 </span><span class="lineCov">          1 :                                                                 ctx-&gt;grid[j].pos_x = tile1-&gt;pos_x;</span>
<span class="lineNum">     721 </span>            :                                                                 max_cols+=1;
<span class="lineNum">     722 </span>            :                                                                 break;
<span class="lineNum">     723 </span>            :                                                         }
<span class="lineNum">     724 </span>            :                                                 }
<span class="lineNum">     725 </span>            :                                         }
<span class="lineNum">     726 </span>            :                                 }
<span class="lineNum">     727 </span>            :                         }
<span class="lineNum">     728 </span>            :                 }
<span class="lineNum">     729 </span><span class="lineCov">         25 :                 if (!ctx-&gt;grid) {</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Failed to create grid\n&quot;));</span>
<span class="lineNum">     731 </span>            :                         return GF_OUT_OF_MEM;
<span class="lineNum">     732 </span>            :                 }
<span class="lineNum">     733 </span>            :                 // pass on the grid to insert empty columns
<span class="lineNum">     734 </span><span class="lineCov">         25 :                 if (!nb_rel_pos &amp;&amp; ctx-&gt;grid) {</span>
<span class="lineNum">     735 </span><span class="lineCov">         22 :                         for (j=0; j&lt;max_cols-1; j++) {</span>
<span class="lineNum">     736 </span>            :                                 assert(ctx-&gt;grid[j].pos_x + ctx-&gt;grid[j].width &lt;= ctx-&gt;grid[j+1].pos_x);
<span class="lineNum">     737 </span><span class="lineCov">         22 :                                 if (ctx-&gt;grid[j].pos_x + ctx-&gt;grid[j].width != ctx-&gt;grid[j+1].pos_x) {</span>
<span class="lineNum">     738 </span><span class="lineCov">          1 :                                         u32 new_width = ctx-&gt;grid[j+1].pos_x - ctx-&gt;grid[j].pos_x - ctx-&gt;grid[j].width;</span>
<span class="lineNum">     739 </span>            :                                         u32 new_x = ctx-&gt;grid[j].pos_x + ctx-&gt;grid[j].width;
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineCov">          1 :                                         ctx-&gt;grid = gf_realloc(ctx-&gt;grid, sizeof(HEVCGridInfo) * (max_cols+1) );</span>
<span class="lineNum">     742 </span><span class="lineCov">          1 :                                         memmove(&amp;ctx-&gt;grid[j+2], &amp;ctx-&gt;grid[j+1], sizeof(HEVCGridInfo) * (max_cols-j-1));</span>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span><span class="lineCov">          1 :                                         memset(&amp;ctx-&gt;grid[j+1], 0, sizeof(HEVCGridInfo));</span>
<span class="lineNum">     745 </span><span class="lineCov">          1 :                                         ctx-&gt;grid[j+1].width = new_width;</span>
<span class="lineNum">     746 </span><span class="lineCov">          1 :                                         ctx-&gt;grid[j+1].pos_x = new_x;</span>
<span class="lineNum">     747 </span>            :                                         max_cols+=1;
<span class="lineNum">     748 </span>            :                                         j++;
<span class="lineNum">     749 </span>            :                                 }
<span class="lineNum">     750 </span>            :                         }
<span class="lineNum">     751 </span>            :                 }
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            :                 //assign cols and rows
<span class="lineNum">     754 </span><span class="lineCov">        102 :                 for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     755 </span><span class="lineCov">        102 :                         HEVCTilePidCtx *tile = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     756 </span><span class="lineCov">        102 :                         tile-&gt;pos_col=0;</span>
<span class="lineNum">     757 </span><span class="lineCov">        102 :                         tile-&gt;pos_row=0;</span>
<span class="lineNum">     758 </span>            :                 }
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineCov">         74 :                 for (j=0; j&lt;max_cols; j++) {</span>
<span class="lineNum">     761 </span><span class="lineCov">         49 :                         if (nb_rel_pos) {</span>
<span class="lineNum">     762 </span><span class="lineCov">          3 :                                 ctx-&gt;grid[j].height = 0;</span>
<span class="lineNum">     763 </span>            :                         }
<span class="lineNum">     764 </span>            :                         //check non-last columns are multiple of max CU width
<span class="lineNum">     765 </span><span class="lineCov">         49 :                         if ((j+1&lt;max_cols) &amp;&amp; (ctx-&gt;grid[j].width % ctx-&gt;max_CU_height) ) {</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Invalid grid specification, column %d width %d not a multiple of max CU width and not the last one\n&quot;, j+1, ctx-&gt;grid[j].width));</span>
<span class="lineNum">     767 </span>            :                                 return GF_BAD_PARAM;
<span class="lineNum">     768 </span>            :                         }
<span class="lineNum">     769 </span><span class="lineCov">        243 :                         for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     770 </span><span class="lineCov">        243 :                                 HEVCTilePidCtx *tile = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     771 </span><span class="lineCov">        243 :                                 if (nb_rel_pos) {</span>
<span class="lineNum">     772 </span><span class="lineCov">          5 :                                         if (-tile-&gt;pos_x != ctx-&gt;grid[j].pos_x) continue;</span>
<span class="lineNum">     773 </span><span class="lineCov">          2 :                                         if (ctx-&gt;grid[j].width != tile-&gt;width) {</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Invalid relative positioning in the same column of tiles with different width %d vs %d\n&quot;, tile-&gt;width, ctx-&gt;grid[j].width));</span>
<span class="lineNum">     775 </span>            :                                                 return GF_BAD_PARAM;
<span class="lineNum">     776 </span>            :                                         }
<span class="lineNum">     777 </span><span class="lineCov">          2 :                                         tile-&gt;pos_col = j;</span>
<span class="lineNum">     778 </span><span class="lineCov">          2 :                                         tile-&gt;pos_row = -tile-&gt;pos_y;</span>
<span class="lineNum">     779 </span><span class="lineCov">          2 :                                         ctx-&gt;grid[j].height += tile-&gt;height;</span>
<span class="lineNum">     780 </span>            :                                 } else {
<span class="lineNum">     781 </span><span class="lineCov">        238 :                                         if (tile-&gt;pos_x != ctx-&gt;grid[j].pos_x) continue;</span>
<span class="lineNum">     782 </span><span class="lineCov">         99 :                                         tile-&gt;pos_col = j;</span>
<span class="lineNum">     783 </span><span class="lineCov">         99 :                                         tile-&gt;pos_row = tile-&gt;pos_y / ctx-&gt;max_CU_height;</span>
<span class="lineNum">     784 </span><span class="lineCov">         99 :                                         if (tile-&gt;pos_row * ctx-&gt;max_CU_height != tile-&gt;pos_y) {</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] Tile y %d not a multiple of CU height %d, adjusting to next boundary\n&quot;, tile-&gt;pos_y, ctx-&gt;max_CU_height));</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                                                 tile-&gt;pos_row++;</span>
<span class="lineNum">     787 </span>            :                                         }
<span class="lineNum">     788 </span><span class="lineCov">         99 :                                         if (tile-&gt;pos_y + tile-&gt;height &gt; ctx-&gt;grid[j].height)</span>
<span class="lineNum">     789 </span><span class="lineCov">         99 :                                                 ctx-&gt;grid[j].height = tile-&gt;pos_y + tile-&gt;height;</span>
<span class="lineNum">     790 </span>            :                                 }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">        101 :                                 if (tile-&gt;pos_row &gt; ctx-&gt;grid[j].max_row_pos)</span>
<span class="lineNum">     793 </span><span class="lineCov">         59 :                                         ctx-&gt;grid[j].max_row_pos = tile-&gt;pos_row;</span>
<span class="lineNum">     794 </span>            :                         }
<span class="lineNum">     795 </span>            :                 }
<span class="lineNum">     796 </span>            :                 //check non-last rows are multiple of max CU height
<span class="lineNum">     797 </span><span class="lineCov">         49 :                 for (j=0; j&lt;max_cols; j++) {</span>
<span class="lineNum">     798 </span><span class="lineCov">        243 :                         for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     799 </span><span class="lineCov">        243 :                                 HEVCTilePidCtx *tile = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     800 </span><span class="lineCov">        243 :                                 if (tile-&gt;pos_col != j) continue;</span>
<span class="lineNum">     801 </span><span class="lineCov">        102 :                                 if ((tile-&gt;pos_row &lt; ctx-&gt;grid[j].max_row_pos) &amp;&amp; (tile-&gt;height % ctx-&gt;max_CU_height)) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Invalid grid specification, row %d in column %d height %d not a multiple of max CU height and not the last one\n&quot;, tile-&gt;pos_row, j+1, tile-&gt;height));</span>
<span class="lineNum">     803 </span>            :                                         return GF_BAD_PARAM;
<span class="lineNum">     804 </span>            :                                 }
<span class="lineNum">     805 </span>            :                         }
<span class="lineNum">     806 </span>            :                 }
<span class="lineNum">     807 </span>            :                 nb_cols = max_cols;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :         } else {
<span class="lineNum">     810 </span>            :                 //gather tiles per columns
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                 ctx-&gt;grid = gf_malloc(sizeof(HEVCGridInfo)*nb_pids);</span>
<span class="lineNum">     812 </span>            :                 memset(ctx-&gt;grid, 0, sizeof(HEVCGridInfo)*nb_pids);
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :                 nb_cols=0;
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :                 for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     816 </span>            :                         Bool found = GF_FALSE;
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :                         HEVCTilePidCtx *apidctx = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     818 </span>            :                         //do we fit on a col
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :                         for (j=0; j&lt;nb_cols; j++) {</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :                                 if (ctx-&gt;grid[j].width == apidctx-&gt;width) {</span>
<span class="lineNum">     821 </span>            :                                         found = GF_TRUE;
<span class="lineNum">     822 </span>            :                                         break;
<span class="lineNum">     823 </span>            :                                 }
<span class="lineNum">     824 </span>            :                         }
<span class="lineNum">     825 </span>            :                         //force new column
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                         if ((apidctx-&gt;height % ctx-&gt;max_CU_height) &amp;&amp; found &amp;&amp; ctx-&gt;grid[j].last_row_idx)</span>
<span class="lineNum">     827 </span>            :                                 found = GF_FALSE;
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :                         if (!found) {</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :                                 ctx-&gt;grid[nb_cols].width = apidctx-&gt;width;</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :                                 ctx-&gt;grid[nb_cols].height = apidctx-&gt;height;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :                                 if (apidctx-&gt;width % ctx-&gt;max_CU_width) {</span>
<span class="lineNum">     833 </span>            :                                         assert(!force_last_col_plus_one);
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                                         force_last_col_plus_one = nb_cols+1;</span>
<span class="lineNum">     835 </span>            :                                 }
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :                                 if (apidctx-&gt;height % ctx-&gt;max_CU_height) {</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :                                         ctx-&gt;grid[nb_cols].last_row_idx = ctx-&gt;grid[nb_cols].row_pos +1 ;</span>
<span class="lineNum">     838 </span>            :                                         reorder_rows=GF_TRUE;
<span class="lineNum">     839 </span>            :                                 }
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                                 ctx-&gt;grid[nb_cols].row_pos = 1;</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                                 nb_cols++;</span>
<span class="lineNum">     843 </span>            :                                 j=nb_cols-1;
<span class="lineNum">     844 </span>            :                         } else {
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                                 ctx-&gt;grid[j].height += apidctx-&gt;height;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :                                 if (apidctx-&gt;height % ctx-&gt;max_CU_height) {</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                                         ctx-&gt;grid[j].last_row_idx = ctx-&gt;grid[j].row_pos+1;</span>
<span class="lineNum">     848 </span>            :                                         reorder_rows=GF_TRUE;
<span class="lineNum">     849 </span>            :                                 }
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :                                 ctx-&gt;grid[j].row_pos ++;</span>
<span class="lineNum">     851 </span>            :                         }
<span class="lineNum">     852 </span>            :                         assert(ctx-&gt;grid[j].row_pos);
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :                         apidctx-&gt;pos_row = ctx-&gt;grid[j].row_pos - 1;</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :                         apidctx-&gt;pos_col = j;</span>
<span class="lineNum">     855 </span>            :                 }
<span class="lineNum">     856 </span>            :                 //move last column at end if not a multiple of CTU
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :                 if (force_last_col_plus_one) {</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                         for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                                 HEVCTilePidCtx *apidctx = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     860 </span>            :                                 //do we fit on a col
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                                 if (apidctx-&gt;pos_col == force_last_col_plus_one - 1) {</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                                         apidctx-&gt;pos_col = nb_cols-1;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                                 } else if (apidctx-&gt;pos_col &gt; force_last_col_plus_one - 1) {</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                                         apidctx-&gt;pos_col -= 1;</span>
<span class="lineNum">     865 </span>            :                                 }
<span class="lineNum">     866 </span>            :                         }
<span class="lineNum">     867 </span>            :                 }
<span class="lineNum">     868 </span>            :                 //in each column, push the last_row_idx if any to the bottom and move up other tiles accordingly
<span class="lineNum">     869 </span>            :                 //this ensures that slices with non multiple of maxCTU height are always at the bottom of the grid
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :                 if (reorder_rows) {</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :                         for (i=0; i&lt;nb_cols; i++) {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :                                 if (!ctx-&gt;grid[i].last_row_idx) continue;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :                                 for (j=0; j&lt;nb_pids; j++) {</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :                                         HEVCTilePidCtx *apidctx = gf_list_get(ctx-&gt;pids, j);</span>
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :                                         if (apidctx-&gt;pos_col != i) continue;</span>
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :                                         if (apidctx-&gt;pos_row==ctx-&gt;grid[i].last_row_idx-1) {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                                                 apidctx-&gt;pos_row = ctx-&gt;grid[i].row_pos;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :                                         } else if (apidctx-&gt;pos_row &gt; ctx-&gt;grid[i].last_row_idx-1) {</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :                                                 apidctx-&gt;pos_row -= 1;</span>
<span class="lineNum">     883 </span>            :                                         }
<span class="lineNum">     884 </span>            :                                 }
<span class="lineNum">     885 </span>            :                         }
<span class="lineNum">     886 </span>            :                 }
<span class="lineNum">     887 </span>            :         }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :         //update final pos
<span class="lineNum">     890 </span><span class="lineCov">         25 :         ctx-&gt;out_width = 0;</span>
<span class="lineNum">     891 </span><span class="lineCov">         25 :         ctx-&gt;out_height = 0;</span>
<span class="lineNum">     892 </span><span class="lineCov">         49 :         for (i=0; i&lt;nb_cols; i++) {</span>
<span class="lineNum">     893 </span><span class="lineCov">         49 :                 ctx-&gt;out_width += ctx-&gt;grid[i].width;</span>
<span class="lineNum">     894 </span><span class="lineCov">         49 :                 if (ctx-&gt;grid[i].height &gt; ctx-&gt;out_height)</span>
<span class="lineNum">     895 </span><span class="lineCov">         29 :                         ctx-&gt;out_height = ctx-&gt;grid[i].height;</span>
<span class="lineNum">     896 </span>            :         }
<span class="lineNum">     897 </span><span class="lineCov">         25 :         ctx-&gt;nb_cols = nb_cols;</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :         //recompute slice addresses
<span class="lineNum">     900 </span><span class="lineCov">         25 :         GF_LOG(GF_LOG_INFO, GF_LOG_CODEC, (&quot;[HEVCMerge] Grid reconfigured, output size %dx%d, %d input pids:\n&quot;, ctx-&gt;out_width, ctx-&gt;out_height, nb_pids));</span>
<span class="lineNum">     901 </span><span class="lineCov">        102 :         for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     902 </span><span class="lineCov">        102 :                 HEVCTilePidCtx *pidctx = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     903 </span><span class="lineCov">        102 :                 pidctx-&gt;slice_segment_address = hevcmerge_compute_address(ctx, pidctx, nb_abs_pos ? GF_TRUE : GF_FALSE);</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineCov">        102 :                 GF_LOG(GF_LOG_INFO, GF_LOG_CODEC, (&quot;- pid %s (pos %dx%d) size %dx%d new address %d\n&quot;,</span>
<span class="lineNum">     906 </span>            :                                 gf_filter_pid_get_name(pidctx-&gt;pid),
<span class="lineNum">     907 </span>            :                                 nb_has_pos ? pidctx-&gt;pos_x : pidctx-&gt;pos_col,
<span class="lineNum">     908 </span>            :                                 nb_has_pos ? pidctx-&gt;pos_y : pidctx-&gt;pos_row,
<span class="lineNum">     909 </span>            :                                 pidctx-&gt;width, pidctx-&gt;height, pidctx-&gt;slice_segment_address));
<span class="lineNum">     910 </span>            :         }
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            :         //check if we can use a multi-row grid
<span class="lineNum">     913 </span><span class="lineCov">         25 :         ctx-&gt;enable_multi_rows = GF_FALSE;</span>
<span class="lineNum">     914 </span><span class="lineCov">         25 :         if (ctx-&gt;mrows) {</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :                 ctx-&gt;enable_multi_rows = GF_TRUE;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                 ctx-&gt;nb_rows=0;</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                 for (i=0; i&lt;nb_pids; i++) {</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                         HEVCTilePidCtx *tile = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                         s32 pos_y = nb_has_pos ? tile-&gt;pos_y : tile-&gt;pos_row;</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :                         if (!tile-&gt;pos_col)</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :                                 ctx-&gt;nb_rows++;</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :                         for (j=0; j&lt;nb_pids; j++) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :                                 if (i==j) continue;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :                                 HEVCTilePidCtx *atile = gf_list_get(ctx-&gt;pids, j);</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :                                 s32 apos_y = nb_has_pos ? atile-&gt;pos_y : atile-&gt;pos_row;</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :                                 if (apos_y != pos_y) continue;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :                                 if (atile-&gt;height != tile-&gt;height) {</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                                         ctx-&gt;enable_multi_rows = GF_FALSE;</span>
<span class="lineNum">     931 </span>            :                                         break;
<span class="lineNum">     932 </span>            :                                 }
<span class="lineNum">     933 </span>            :                         }
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :                         if (!ctx-&gt;enable_multi_rows) {</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :                                 ctx-&gt;nb_rows = 0;</span>
<span class="lineNum">     936 </span>            :                                 break;
<span class="lineNum">     937 </span>            :                         }
<span class="lineNum">     938 </span>            :                 }
<span class="lineNum">     939 </span>            :         }
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :         //sort pids according to columns (tiles) and slice addresses to be conformant with spec
<span class="lineNum">     942 </span><span class="lineCov">         25 :         gf_list_reset(ctx-&gt;ordered_pids);</span>
<span class="lineNum">     943 </span><span class="lineCov">         49 :         for (i=0; i&lt;nb_cols; i++) {</span>
<span class="lineNum">     944 </span><span class="lineCov">        243 :                 for (j=0; j&lt;nb_pids; j++) {</span>
<span class="lineNum">     945 </span>            :                         u32 k;
<span class="lineNum">     946 </span>            :                         Bool inserted = GF_FALSE;
<span class="lineNum">     947 </span><span class="lineCov">        243 :                         HEVCTilePidCtx *tile = gf_list_get(ctx-&gt;pids, j);</span>
<span class="lineNum">     948 </span>            :                         //
<span class="lineNum">     949 </span><span class="lineCov">        243 :                         if (!ctx-&gt;enable_multi_rows &amp;&amp; (tile-&gt;pos_col != i))</span>
<span class="lineNum">     950 </span><span class="lineCov">        141 :                                 continue;</span>
<span class="lineNum">     951 </span><span class="lineCov">        246 :                         for (k=0; k&lt;gf_list_count(ctx-&gt;ordered_pids); k++) {</span>
<span class="lineNum">     952 </span><span class="lineCov">        246 :                                 HEVCTilePidCtx *tile2 = gf_list_get(ctx-&gt;ordered_pids, k);</span>
<span class="lineNum">     953 </span><span class="lineCov">        246 :                                 if (!ctx-&gt;enable_multi_rows &amp;&amp; (tile2-&gt;pos_col != i))</span>
<span class="lineNum">     954 </span><span class="lineCov">        168 :                                         continue;</span>
<span class="lineNum">     955 </span><span class="lineCov">         78 :                                 if (tile2-&gt;slice_segment_address &gt; tile-&gt;slice_segment_address) {</span>
<span class="lineNum">     956 </span>            :                                         inserted = GF_TRUE;
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :                                         gf_list_insert(ctx-&gt;ordered_pids, tile, k);</span>
<span class="lineNum">     958 </span>            :                                         break;
<span class="lineNum">     959 </span>            :                                 }
<span class="lineNum">     960 </span>            :                         }
<span class="lineNum">     961 </span>            :                         if (!inserted) {
<span class="lineNum">     962 </span><span class="lineCov">        246 :                                 for (k=0; k&lt;gf_list_count(ctx-&gt;ordered_pids); k++) {</span>
<span class="lineNum">     963 </span><span class="lineCov">        246 :                                         HEVCTilePidCtx *tile2 = gf_list_get(ctx-&gt;ordered_pids, k);</span>
<span class="lineNum">     964 </span><span class="lineCov">        246 :                                         if (!ctx-&gt;enable_multi_rows) {</span>
<span class="lineNum">     965 </span><span class="lineCov">        246 :                                                 if (tile2-&gt;pos_col &gt; tile-&gt;pos_col) {</span>
<span class="lineNum">     966 </span>            :                                                         inserted = GF_TRUE;
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :                                                         gf_list_insert(ctx-&gt;ordered_pids, tile, k);</span>
<span class="lineNum">     968 </span>            :                                                         break;
<span class="lineNum">     969 </span>            :                                                 }
<span class="lineNum">     970 </span>            :                                         } else {
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :                                                 if (tile2-&gt;slice_segment_address &gt; tile-&gt;slice_segment_address) {</span>
<span class="lineNum">     972 </span>            :                                                         inserted = GF_TRUE;
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :                                                         gf_list_insert(ctx-&gt;ordered_pids, tile, k);</span>
<span class="lineNum">     974 </span>            :                                                         break;
<span class="lineNum">     975 </span>            :                                                 }
<span class="lineNum">     976 </span>            :                                         }
<span class="lineNum">     977 </span>            :                                 }
<span class="lineNum">     978 </span>            :                                 if (!inserted)
<span class="lineNum">     979 </span><span class="lineCov">        102 :                                         gf_list_add(ctx-&gt;ordered_pids, tile);</span>
<span class="lineNum">     980 </span>            :                         }
<span class="lineNum">     981 </span>            :                 }
<span class="lineNum">     982 </span><span class="lineCov">         49 :                 if (ctx-&gt;enable_multi_rows)</span>
<span class="lineNum">     983 </span>            :                         break;
<span class="lineNum">     984 </span>            :         }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :         assert(gf_list_count(ctx-&gt;ordered_pids) == gf_list_count(ctx-&gt;pids));
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span>            :         //build SRD map
<span class="lineNum">     989 </span><span class="lineCov">         25 :         hevcmerge_build_srdmap(ctx, nb_abs_pos ? GF_TRUE : GF_FALSE);</span>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :         return GF_OK;
<a name="992"><span class="lineNum">     992 </span>            : }</a>
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineCov">         77 : static GF_Err hevcmerge_check_sps_pps(GF_HEVCMergeCtx *ctx, HEVCTilePidCtx *pid_base, HEVCTilePidCtx *pid_o)</span>
<span class="lineNum">     995 </span>            : {
<span class="lineNum">     996 </span>            :         Bool all_ok = GF_TRUE;
<span class="lineNum">     997 </span>            :         u32 i;
<span class="lineNum">     998 </span>            :         HEVCState *state_base = &amp;pid_base-&gt;hevc_state;
<span class="lineNum">     999 </span>            :         HEVCState *state_o = &amp;pid_o-&gt;hevc_state;
<span class="lineNum">    1000 </span><span class="lineCov">         77 :         char *src_base = gf_filter_pid_get_source(pid_base-&gt;pid);</span>
<span class="lineNum">    1001 </span><span class="lineCov">         77 :         char *src_o = gf_filter_pid_get_source(pid_o-&gt;pid);</span>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineCov">       1232 :         for (i=0; i&lt;16; i++) {</span>
<span class="lineNum">    1004 </span>            :                 HEVC_SPS *sps_base = &amp;state_base-&gt;sps[i];
<span class="lineNum">    1005 </span>            :                 HEVC_SPS *sps_o = &amp;state_o-&gt;sps[i];
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            : #define CHECK_SPS_VAL(__name)   \
<span class="lineNum">    1008 </span>            :                         if (sps_base-&gt;__name != sps_o-&gt;__name ) { \
<span class="lineNum">    1009 </span>            :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] &quot;#__name&quot; differs in SPS between %s and %s, undefined results\n&quot;, src_base, src_o));\
<span class="lineNum">    1010 </span>            :                                 all_ok = GF_FALSE;\
<span class="lineNum">    1011 </span>            :                         }\
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineCov">       1232 :                 if (!sps_base-&gt;state &amp;&amp; !sps_o-&gt;state) continue;</span>
<span class="lineNum">    1014 </span><span class="lineCov">         77 :                 if (!sps_base-&gt;state &amp;&amp; sps_o-&gt;state) {</span>
<span class="lineNum">    1015 </span>            :                         all_ok = GF_FALSE;
<span class="lineNum">    1016 </span>            :                         break;
<span class="lineNum">    1017 </span>            :                 }
<span class="lineNum">    1018 </span><span class="lineCov">         77 :                 if (sps_base-&gt;state &amp;&amp; !sps_o-&gt;state) {</span>
<span class="lineNum">    1019 </span>            :                         all_ok = GF_FALSE;
<span class="lineNum">    1020 </span>            :                         break;
<span class="lineNum">    1021 </span>            :                 }
<span class="lineNum">    1022 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(aspect_ratio_info_present_flag)</span>
<span class="lineNum">    1023 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(chroma_format_idc)</span>
<span class="lineNum">    1024 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(cw_flag)</span>
<span class="lineNum">    1025 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(cw_flag)</span>
<span class="lineNum">    1026 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(cw_left)</span>
<span class="lineNum">    1027 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(cw_right)</span>
<span class="lineNum">    1028 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(cw_top)</span>
<span class="lineNum">    1029 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(cw_bottom)</span>
<span class="lineNum">    1030 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(bit_depth_luma)</span>
<span class="lineNum">    1031 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(bit_depth_chroma)</span>
<span class="lineNum">    1032 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(log2_max_pic_order_cnt_lsb)</span>
<span class="lineNum">    1033 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(separate_colour_plane_flag)</span>
<span class="lineNum">    1034 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(max_CU_depth)</span>
<span class="lineNum">    1035 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(num_short_term_ref_pic_sets)</span>
<span class="lineNum">    1036 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(num_long_term_ref_pic_sps)</span>
<span class="lineNum">    1037 </span>            :                 //HEVC_ReferencePictureSets rps[64];
<span class="lineNum">    1038 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(aspect_ratio_info_present_flag)</span>
<span class="lineNum">    1039 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(long_term_ref_pics_present_flag)</span>
<span class="lineNum">    1040 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(temporal_mvp_enable_flag)</span>
<span class="lineNum">    1041 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(sample_adaptive_offset_enabled_flag)</span>
<span class="lineNum">    1042 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(sar_idc)</span>
<span class="lineNum">    1043 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(sar_width)</span>
<span class="lineNum">    1044 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(sar_height)</span>
<span class="lineNum">    1045 </span>            : //              CHECK_SPS_VAL(has_timing_info)
<span class="lineNum">    1046 </span>            : //              CHECK_SPS_VAL(num_units_in_tick)
<span class="lineNum">    1047 </span>            : //              CHECK_SPS_VAL(time_scale)
<span class="lineNum">    1048 </span>            : //              CHECK_SPS_VAL(poc_proportional_to_timing_flag)
<span class="lineNum">    1049 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(num_ticks_poc_diff_one_minus1)</span>
<span class="lineNum">    1050 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(video_full_range_flag)</span>
<span class="lineNum">    1051 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(colour_description_present_flag)</span>
<span class="lineNum">    1052 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(colour_primaries)</span>
<span class="lineNum">    1053 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(transfer_characteristic)</span>
<span class="lineNum">    1054 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(matrix_coeffs)</span>
<span class="lineNum">    1055 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(rep_format_idx);</span>
<span class="lineNum">    1056 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(sps_ext_or_max_sub_layers_minus1)</span>
<span class="lineNum">    1057 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(max_sub_layers_minus1)</span>
<span class="lineNum">    1058 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(update_rep_format_flag)</span>
<span class="lineNum">    1059 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(sub_layer_ordering_info_present_flag)</span>
<span class="lineNum">    1060 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(scaling_list_enable_flag)</span>
<span class="lineNum">    1061 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(infer_scaling_list_flag)</span>
<span class="lineNum">    1062 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(scaling_list_ref_layer_id)</span>
<span class="lineNum">    1063 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(scaling_list_data_present_flag)</span>
<span class="lineNum">    1064 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(asymmetric_motion_partitions_enabled_flag)</span>
<span class="lineNum">    1065 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(pcm_enabled_flag)</span>
<span class="lineNum">    1066 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(strong_intra_smoothing_enable_flag)</span>
<span class="lineNum">    1067 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(vui_parameters_present_flag)</span>
<span class="lineNum">    1068 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(log2_diff_max_min_luma_coding_block_size)</span>
<span class="lineNum">    1069 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(log2_min_transform_block_size)</span>
<span class="lineNum">    1070 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(log2_min_luma_coding_block_size)</span>
<span class="lineNum">    1071 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(log2_max_transform_block_size)</span>
<span class="lineNum">    1072 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(max_transform_hierarchy_depth_inter)</span>
<span class="lineNum">    1073 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(max_transform_hierarchy_depth_intra)</span>
<span class="lineNum">    1074 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(pcm_sample_bit_depth_luma_minus1)</span>
<span class="lineNum">    1075 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(pcm_sample_bit_depth_chroma_minus1)</span>
<span class="lineNum">    1076 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(pcm_loop_filter_disable_flag)</span>
<span class="lineNum">    1077 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(log2_min_pcm_luma_coding_block_size_minus3)</span>
<span class="lineNum">    1078 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(log2_diff_max_min_pcm_luma_coding_block_size)</span>
<span class="lineNum">    1079 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(overscan_info_present)</span>
<span class="lineNum">    1080 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(overscan_appropriate)</span>
<span class="lineNum">    1081 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(video_signal_type_present_flag)</span>
<span class="lineNum">    1082 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(video_format)</span>
<span class="lineNum">    1083 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(chroma_loc_info_present_flag)</span>
<span class="lineNum">    1084 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(chroma_sample_loc_type_top_field)</span>
<span class="lineNum">    1085 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(chroma_sample_loc_type_bottom_field)</span>
<span class="lineNum">    1086 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(neutra_chroma_indication_flag)</span>
<span class="lineNum">    1087 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(field_seq_flag)</span>
<span class="lineNum">    1088 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(frame_field_info_present_flag)</span>
<span class="lineNum">    1089 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(default_display_window_flag)</span>
<span class="lineNum">    1090 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(left_offset)</span>
<span class="lineNum">    1091 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(right_offset)</span>
<span class="lineNum">    1092 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(top_offset)</span>
<span class="lineNum">    1093 </span><span class="lineCov">         77 :                 CHECK_SPS_VAL(bottom_offset)</span>
<span class="lineNum">    1094 </span>            :         }
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineCov">       4928 :         for (i=0; i&lt;64; i++) {</span>
<span class="lineNum">    1097 </span>            :                 HEVC_PPS *pps_base = &amp;state_base-&gt;pps[i];
<span class="lineNum">    1098 </span>            :                 HEVC_PPS *pps_o = &amp;state_o-&gt;pps[i];
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            : #define CHECK_PPS_VAL(__name)   \
<span class="lineNum">    1101 </span>            :                         if (pps_base-&gt;__name != pps_o-&gt;__name ) { \
<span class="lineNum">    1102 </span>            :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] &quot;#__name&quot; differs in PPS, undefined results\n&quot;));\
<span class="lineNum">    1103 </span>            :                                 all_ok = GF_FALSE;\
<span class="lineNum">    1104 </span>            :                         }\
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span><span class="lineCov">       4928 :                 if (!pps_base-&gt;state &amp;&amp; !pps_o-&gt;state) continue;</span>
<span class="lineNum">    1107 </span><span class="lineCov">         77 :                 if (!pps_base-&gt;state &amp;&amp; pps_o-&gt;state) {</span>
<span class="lineNum">    1108 </span>            :                         all_ok = GF_FALSE;
<span class="lineNum">    1109 </span>            :                         break;
<span class="lineNum">    1110 </span>            :                 }
<span class="lineNum">    1111 </span><span class="lineCov">         77 :                 if (pps_base-&gt;state &amp;&amp; !pps_o-&gt;state) {</span>
<span class="lineNum">    1112 </span>            :                         all_ok = GF_FALSE;
<span class="lineNum">    1113 </span>            :                         break;
<span class="lineNum">    1114 </span>            :                 }
<span class="lineNum">    1115 </span>            :                 //we don't check tile config nor init qp since we rewrite these
<span class="lineNum">    1116 </span>            : //              CHECK_PPS_VAL(loop_filter_across_tiles_enabled_flag)
<span class="lineNum">    1117 </span>            : //              CHECK_PPS_VAL(pic_init_qp_minus26)
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(dependent_slice_segments_enabled_flag)</span>
<span class="lineNum">    1120 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(num_extra_slice_header_bits)</span>
<span class="lineNum">    1121 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(num_ref_idx_l0_default_active)</span>
<span class="lineNum">    1122 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(num_ref_idx_l1_default_active)</span>
<span class="lineNum">    1123 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(slice_segment_header_extension_present_flag)</span>
<span class="lineNum">    1124 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(output_flag_present_flag)</span>
<span class="lineNum">    1125 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(lists_modification_present_flag)</span>
<span class="lineNum">    1126 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(cabac_init_present_flag)</span>
<span class="lineNum">    1127 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(weighted_pred_flag)</span>
<span class="lineNum">    1128 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(weighted_bipred_flag)</span>
<span class="lineNum">    1129 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(slice_chroma_qp_offsets_present_flag)</span>
<span class="lineNum">    1130 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(deblocking_filter_override_enabled_flag)</span>
<span class="lineNum">    1131 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(loop_filter_across_slices_enabled_flag)</span>
<span class="lineNum">    1132 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(entropy_coding_sync_enabled_flag)</span>
<span class="lineNum">    1133 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(sign_data_hiding_flag)</span>
<span class="lineNum">    1134 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(constrained_intra_pred_flag)</span>
<span class="lineNum">    1135 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(transform_skip_enabled_flag)</span>
<span class="lineNum">    1136 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(cu_qp_delta_enabled_flag)</span>
<span class="lineNum">    1137 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(transquant_bypass_enable_flag)</span>
<span class="lineNum">    1138 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(diff_cu_qp_delta_depth)</span>
<span class="lineNum">    1139 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(pic_cb_qp_offset)</span>
<span class="lineNum">    1140 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(pic_cr_qp_offset)</span>
<span class="lineNum">    1141 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(deblocking_filter_control_present_flag)</span>
<span class="lineNum">    1142 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(pic_disable_deblocking_filter_flag)</span>
<span class="lineNum">    1143 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(pic_scaling_list_data_present_flag)</span>
<span class="lineNum">    1144 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(beta_offset_div2)</span>
<span class="lineNum">    1145 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(tc_offset_div2)</span>
<span class="lineNum">    1146 </span><span class="lineCov">         77 :                 CHECK_PPS_VAL(log2_parallel_merge_level_minus2)</span>
<span class="lineNum">    1147 </span>            :         }
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span><span class="lineCov">         77 :         if (src_base) gf_free(src_base);</span>
<span class="lineNum">    1150 </span><span class="lineCov">         77 :         if (src_o) gf_free(src_o);</span>
<span class="lineNum">    1151 </span><span class="lineCov">         77 :         if (all_ok || !ctx-&gt;strict) return GF_OK;</span>
<span class="lineNum">    1152 </span>            :         return GF_BAD_PARAM;
<span class="lineNum">    1153 </span>            : }
<a name="1154"><span class="lineNum">    1154 </span>            : </a>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineCov">         25 : static GF_Err hevcmerge_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)</span>
<span class="lineNum">    1157 </span>            : {
<span class="lineNum">    1158 </span>            :         Bool grid_config_changed = GF_FALSE;
<span class="lineNum">    1159 </span>            :         u32 cfg_crc = 0, pid_width, pid_height;
<span class="lineNum">    1160 </span>            :         const GF_PropertyValue *p, *dsi;
<span class="lineNum">    1161 </span>            :         GF_Err e;
<span class="lineNum">    1162 </span>            :         u8 j, i;
<span class="lineNum">    1163 </span><span class="lineCov">         25 :         GF_HEVCMergeCtx *ctx = (GF_HEVCMergeCtx*)gf_filter_get_udta(filter);</span>
<span class="lineNum">    1164 </span>            :         HEVCTilePidCtx *tile_pid;
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineCov">         25 :         if (ctx-&gt;in_error)</span>
<span class="lineNum">    1167 </span>            :                 return GF_BAD_PARAM;
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineCov">         25 :         if (is_remove) {</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :                 tile_pid = gf_filter_pid_get_udta(pid);</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :                 gf_list_del_item(ctx-&gt;pids, tile_pid);</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :                 gf_free(tile_pid);</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :                 if (!gf_list_count(ctx-&gt;pids)) {</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                         if (ctx-&gt;opid) {</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                                 gf_filter_pid_remove(ctx-&gt;opid);</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :                                 ctx-&gt;opid = NULL;</span>
<span class="lineNum">    1177 </span>            :                         }
<span class="lineNum">    1178 </span>            :                         return GF_OK;
<span class="lineNum">    1179 </span>            :                 }
<span class="lineNum">    1180 </span>            :                 grid_config_changed = GF_TRUE;
<span class="lineNum">    1181 </span>            :                 goto reconfig_grid;
<span class="lineNum">    1182 </span>            :         }
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineCov">         25 :         if (!gf_filter_pid_check_caps(pid))</span>
<span class="lineNum">    1185 </span>            :                 return GF_NOT_SUPPORTED;
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineCov">         25 :         p = gf_filter_pid_get_property(pid, GF_PROP_PID_WIDTH);</span>
<span class="lineNum">    1188 </span><span class="lineCov">         25 :         if (!p) return GF_OK;</span>
<span class="lineNum">    1189 </span><span class="lineCov">         25 :         pid_width = p-&gt;value.uint;</span>
<span class="lineNum">    1190 </span><span class="lineCov">         25 :         p = gf_filter_pid_get_property(pid, GF_PROP_PID_HEIGHT);</span>
<span class="lineNum">    1191 </span><span class="lineCov">         25 :         if (!p) return GF_OK;</span>
<span class="lineNum">    1192 </span><span class="lineCov">         25 :         pid_height = p-&gt;value.uint;</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineCov">         25 :         dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);</span>
<span class="lineNum">    1195 </span><span class="lineCov">         25 :         if (!dsi) return GF_OK;</span>
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span><span class="lineCov">         25 :         tile_pid = gf_filter_pid_get_udta(pid);</span>
<span class="lineNum">    1198 </span>            :         //not set, first time we see this pid
<span class="lineNum">    1199 </span><span class="lineCov">         25 :         if (!tile_pid) {</span>
<span class="lineNum">    1200 </span><span class="lineCov">         25 :                 GF_SAFEALLOC(tile_pid, HEVCTilePidCtx);</span>
<span class="lineNum">    1201 </span><span class="lineCov">         25 :                 if (!tile_pid) return GF_OUT_OF_MEM;</span>
<span class="lineNum">    1202 </span>            :                 
<span class="lineNum">    1203 </span><span class="lineCov">         25 :                 gf_filter_pid_set_udta(pid, tile_pid);</span>
<span class="lineNum">    1204 </span><span class="lineCov">         25 :                 tile_pid-&gt;pid = pid;</span>
<span class="lineNum">    1205 </span><span class="lineCov">         25 :                 tile_pid-&gt;hevc_state.full_slice_header_parse = GF_TRUE;</span>
<span class="lineNum">    1206 </span><span class="lineCov">         25 :                 gf_list_add(ctx-&gt;pids, tile_pid);</span>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span><span class="lineCov">         25 :                 gf_filter_pid_set_framing_mode(pid, GF_TRUE);</span>
<span class="lineNum">    1209 </span>            :         }
<span class="lineNum">    1210 </span>            :         assert(tile_pid);
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineCov">         25 :         p = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);</span>
<span class="lineNum">    1213 </span><span class="lineCov">         25 :         if (p) tile_pid-&gt;timescale = p-&gt;value.uint;</span>
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            :         //check if config (vps/sps/pps) has changed - if not, we ignore the reconfig
<span class="lineNum">    1216 </span>            :         //note that we don't copy all properties of input pids to the output in this case
<span class="lineNum">    1217 </span>            :         cfg_crc = 0;
<span class="lineNum">    1218 </span><span class="lineCov">         25 :         if (dsi-&gt;value.data.ptr &amp;&amp; dsi-&gt;value.data.size) {</span>
<span class="lineNum">    1219 </span><span class="lineCov">         25 :                 cfg_crc = gf_crc_32(dsi-&gt;value.data.ptr, dsi-&gt;value.data.size);</span>
<span class="lineNum">    1220 </span>            :         }
<span class="lineNum">    1221 </span><span class="lineCov">         25 :         if (cfg_crc == tile_pid-&gt;dsi_crc)</span>
<span class="lineNum">    1222 </span>            :                 return GF_OK;
<span class="lineNum">    1223 </span><span class="lineCov">         25 :         tile_pid-&gt;dsi_crc = cfg_crc;</span>
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span>            :         //update this pid's config by parsing sps/vps/pps and check if we need to change anything
<span class="lineNum">    1226 </span><span class="lineCov">         25 :         GF_HEVCConfig *hvcc = gf_odf_hevc_cfg_read(dsi-&gt;value.data.ptr, dsi-&gt;value.data.size, GF_FALSE);</span>
<span class="lineNum">    1227 </span><span class="lineCov">         25 :         if (!hvcc) return GF_NON_COMPLIANT_BITSTREAM;</span>
<span class="lineNum">    1228 </span><span class="lineCov">         25 :         tile_pid-&gt;nalu_size_length = hvcc-&gt;nal_unit_size;</span>
<span class="lineNum">    1229 </span><span class="lineCov">         25 :         ctx-&gt;hevc_nalu_size_length = 4;</span>
<span class="lineNum">    1230 </span>            :         e = GF_OK;
<span class="lineNum">    1231 </span><span class="lineCov">        100 :         for (i = 0; i &lt; gf_list_count(hvcc-&gt;param_array); i++) {</span>
<span class="lineNum">    1232 </span><span class="lineCov">         75 :                 GF_NALUFFParamArray *ar = (GF_NALUFFParamArray *) gf_list_get(hvcc-&gt;param_array, i);</span>
<span class="lineNum">    1233 </span><span class="lineCov">        150 :                 for (j = 0; j &lt; gf_list_count(ar-&gt;nalus); j++) {</span>
<span class="lineNum">    1234 </span><span class="lineCov">         75 :                         GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar-&gt;nalus, j);</span>
<span class="lineNum">    1235 </span>            :                         s32 idx = 0;
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineCov">         75 :                         if (ar-&gt;type == GF_HEVC_NALU_SEQ_PARAM) {</span>
<span class="lineNum">    1238 </span><span class="lineCov">         25 :                                 idx = gf_hevc_read_sps(sl-&gt;data, sl-&gt;size, &amp;tile_pid-&gt;hevc_state);</span>
<span class="lineNum">    1239 </span><span class="lineCov">         25 :                                 if (idx&gt;=0) {</span>
<span class="lineNum">    1240 </span><span class="lineCov">         25 :                                         if (!ctx-&gt;max_CU_width) {</span>
<span class="lineNum">    1241 </span><span class="lineCov">          5 :                                                 ctx-&gt;max_CU_width = tile_pid-&gt;hevc_state.sps[idx].max_CU_width;</span>
<span class="lineNum">    1242 </span><span class="lineCov">         20 :                                         } else if (ctx-&gt;max_CU_width != tile_pid-&gt;hevc_state.sps[idx].max_CU_width) {</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Cannot merge tiles not using the same max CU width (%d vs %d)\n&quot;, ctx-&gt;max_CU_width, tile_pid-&gt;hevc_state.sps[idx].max_CU_width));</span>
<span class="lineNum">    1244 </span>            :                                                 e = GF_BAD_PARAM;
<span class="lineNum">    1245 </span>            :                                                 break;
<span class="lineNum">    1246 </span>            :                                         }
<span class="lineNum">    1247 </span><span class="lineCov">         25 :                                         if (!ctx-&gt;max_CU_height) {</span>
<span class="lineNum">    1248 </span><span class="lineCov">          5 :                                                 ctx-&gt;max_CU_height = tile_pid-&gt;hevc_state.sps[idx].max_CU_height;</span>
<span class="lineNum">    1249 </span><span class="lineCov">         20 :                                         } else if (ctx-&gt;max_CU_height != tile_pid-&gt;hevc_state.sps[idx].max_CU_height) {</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :                                                 GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (&quot;[HEVCMerge] Cannot merge tiles not using the same max CU height (%d vs %d)\n&quot;, ctx-&gt;max_CU_height, tile_pid-&gt;hevc_state.sps[idx].max_CU_height));</span>
<span class="lineNum">    1251 </span>            :                                                 e = GF_BAD_PARAM;
<span class="lineNum">    1252 </span>            :                                                 break;
<span class="lineNum">    1253 </span>            :                                         }
<span class="lineNum">    1254 </span>            :                                 }
<span class="lineNum">    1255 </span>            :                         }
<span class="lineNum">    1256 </span><span class="lineCov">         50 :                         else if (ar-&gt;type == GF_HEVC_NALU_VID_PARAM) {</span>
<span class="lineNum">    1257 </span><span class="lineCov">         25 :                                 idx = gf_hevc_read_vps(sl-&gt;data, sl-&gt;size, &amp;tile_pid-&gt;hevc_state);</span>
<span class="lineNum">    1258 </span>            :                         }
<span class="lineNum">    1259 </span><span class="lineCov">         25 :                         else if (ar-&gt;type == GF_HEVC_NALU_PIC_PARAM) {</span>
<span class="lineNum">    1260 </span><span class="lineCov">         25 :                                 idx = gf_hevc_read_pps(sl-&gt;data, sl-&gt;size, &amp;tile_pid-&gt;hevc_state);</span>
<span class="lineNum">    1261 </span>            :                         }
<span class="lineNum">    1262 </span><span class="lineCov">         75 :                         if (idx &lt; 0) {</span>
<span class="lineNum">    1263 </span>            :                                 // WARNING
<span class="lineNum">    1264 </span>            :                                 e = GF_NON_COMPLIANT_BITSTREAM;
<span class="lineNum">    1265 </span>            :                                 break;
<span class="lineNum">    1266 </span>            :                         }
<span class="lineNum">    1267 </span>            :                 }
<span class="lineNum">    1268 </span><span class="lineCov">         75 :                 if (e) break;</span>
<span class="lineNum">    1269 </span>            :         }
<span class="lineNum">    1270 </span><span class="lineCov">         25 :         gf_odf_hevc_cfg_del(hvcc);</span>
<span class="lineNum">    1271 </span><span class="lineCov">         25 :         if (e) return e;</span>
<span class="lineNum">    1272 </span><span class="lineCov">         25 :         if (!ctx-&gt;opid) {</span>
<span class="lineNum">    1273 </span><span class="lineCov">          5 :                 ctx-&gt;opid = gf_filter_pid_new(filter);</span>
<span class="lineNum">    1274 </span><span class="lineCov">          5 :                 gf_filter_pid_copy_properties(ctx-&gt;opid, pid);</span>
<span class="lineNum">    1275 </span>            :                 //remove all SRD related properties
<span class="lineNum">    1276 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD, NULL);</span>
<span class="lineNum">    1277 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD_REF, NULL);</span>
<span class="lineNum">    1278 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_SRD_MAP, NULL);</span>
<span class="lineNum">    1279 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_CROP_POS, NULL);</span>
<span class="lineNum">    1280 </span>            :                 //TODO, we might want to compute a cumulate of these properties on the output ?
<span class="lineNum">    1281 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_ORIG_SIZE, NULL);</span>
<span class="lineNum">    1282 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_DOWN_SIZE, NULL);</span>
<span class="lineNum">    1283 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_DOWN_RATE, NULL);</span>
<span class="lineNum">    1284 </span><span class="lineCov">          5 :                 gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_DOWN_BYTES, NULL);</span>
<span class="lineNum">    1285 </span>            :         }
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span><span class="lineCov">         25 :         if ((pid_width != tile_pid-&gt;width) || (pid_height != tile_pid-&gt;height)) {</span>
<span class="lineNum">    1288 </span><span class="lineCov">         25 :                 tile_pid-&gt;width = pid_width;</span>
<span class="lineNum">    1289 </span><span class="lineCov">         25 :                 tile_pid-&gt;height = pid_height;</span>
<span class="lineNum">    1290 </span>            :                 grid_config_changed = GF_TRUE;
<span class="lineNum">    1291 </span>            :         }
<span class="lineNum">    1292 </span>            :         //todo further testing we might want to force a grid reconfig even if same width / height
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">         25 :         p = gf_filter_pid_get_property(pid, GF_PROP_PID_CROP_POS);</span>
<span class="lineNum">    1295 </span><span class="lineCov">         25 :         if (p) {</span>
<span class="lineNum">    1296 </span>            :                 s32 pos_x, pos_y;
<span class="lineNum">    1297 </span><span class="lineCov">         25 :                 if (!tile_pid-&gt;has_pos)</span>
<span class="lineNum">    1298 </span>            :                         grid_config_changed = GF_TRUE;
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineCov">         25 :                 tile_pid-&gt;has_pos = GF_TRUE;</span>
<span class="lineNum">    1301 </span><span class="lineCov">         25 :                 if (p-&gt;value.vec2i.x&gt;0) {</span>
<span class="lineNum">    1302 </span><span class="lineCov">         15 :                         pos_x = p-&gt;value.vec2i.x / ctx-&gt;max_CU_width;</span>
<span class="lineNum">    1303 </span><span class="lineCov">         15 :                         if (pos_x * ctx-&gt;max_CU_width != p-&gt;value.vec2i.x) {</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] CropOrigin X %d is not a multiple of max CU width %d, adjusting to next boundary\n&quot;, p-&gt;value.vec2i.x, ctx-&gt;max_CU_width));</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :                                 pos_x++;</span>
<span class="lineNum">    1306 </span>            :                         }
<span class="lineNum">    1307 </span><span class="lineCov">         15 :                         pos_x *= ctx-&gt;max_CU_width;</span>
<span class="lineNum">    1308 </span>            :                 } else {
<span class="lineNum">    1309 </span>            :                         pos_x = p-&gt;value.vec2i.x;
<span class="lineNum">    1310 </span>            :                 }
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span><span class="lineCov">         25 :                 if (p-&gt;value.vec2i.y&gt;0) {</span>
<span class="lineNum">    1313 </span><span class="lineCov">         15 :                         pos_y = p-&gt;value.vec2i.y / ctx-&gt;max_CU_height;</span>
<span class="lineNum">    1314 </span><span class="lineCov">         15 :                         if (pos_y * ctx-&gt;max_CU_height != p-&gt;value.vec2i.y) {</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] CropOrigin Y %d is not a multiple of max CU height %d, adjusting to next boundary\n&quot;, p-&gt;value.vec2i.y, ctx-&gt;max_CU_height));</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :                                 pos_y++;</span>
<span class="lineNum">    1317 </span>            :                         }
<span class="lineNum">    1318 </span><span class="lineCov">         15 :                         pos_y *= ctx-&gt;max_CU_height;</span>
<span class="lineNum">    1319 </span>            :                 } else {
<span class="lineNum">    1320 </span>            :                         pos_y = p-&gt;value.vec2i.y;
<span class="lineNum">    1321 </span>            :                 }
<span class="lineNum">    1322 </span><span class="lineCov">         25 :                 if ((pos_x != tile_pid-&gt;pos_x) || (pos_y != tile_pid-&gt;pos_y))</span>
<span class="lineNum">    1323 </span>            :                         grid_config_changed = GF_TRUE;
<span class="lineNum">    1324 </span><span class="lineCov">         25 :                 tile_pid-&gt;pos_x = pos_x;</span>
<span class="lineNum">    1325 </span><span class="lineCov">         25 :                 tile_pid-&gt;pos_y = pos_y;</span>
<span class="lineNum">    1326 </span>            :         } else {
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                 if (tile_pid-&gt;has_pos)</span>
<span class="lineNum">    1328 </span>            :                         grid_config_changed = GF_TRUE;
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                 tile_pid-&gt;has_pos = GF_FALSE;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                 tile_pid-&gt;pos_x = tile_pid-&gt;pos_y = 0;</span>
<span class="lineNum">    1331 </span>            :         }
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span><span class="lineCov">         25 : reconfig_grid:</span>
<span class="lineNum">    1334 </span>            :         // Update grid
<span class="lineNum">    1335 </span><span class="lineCov">         25 :         if (grid_config_changed) {</span>
<span class="lineNum">    1336 </span><span class="lineCov">         25 :                 e = hevcmerge_rebuild_grid(ctx, pid);</span>
<span class="lineNum">    1337 </span><span class="lineCov">         25 :                 if (e) {</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :                         ctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :                         return e;</span>
<span class="lineNum">    1340 </span>            :                 }
<span class="lineNum">    1341 </span>            :         }
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span>            :         //check SPS/PPS are compatible - for now we only warn but still process
<span class="lineNum">    1344 </span><span class="lineCov">         25 :         tile_pid = gf_list_get(ctx-&gt;pids, 0);</span>
<span class="lineNum">    1345 </span><span class="lineCov">        102 :         for (i=1; i&lt;gf_list_count(ctx-&gt;pids); i++) {</span>
<span class="lineNum">    1346 </span><span class="lineCov">         77 :                 HEVCTilePidCtx *apidctx = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    1347 </span><span class="lineCov">         77 :                 e = hevcmerge_check_sps_pps(ctx, tile_pid, apidctx);</span>
<span class="lineNum">    1348 </span><span class="lineCov">         77 :                 if (e) {</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                         apidctx-&gt;in_error = GF_TRUE;</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                         return e;</span>
<span class="lineNum">    1351 </span>            :                 }
<span class="lineNum">    1352 </span>            :         }
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span><span class="lineCov">         25 :         gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_WIDTH, &amp;PROP_UINT(ctx-&gt;out_width));</span>
<span class="lineNum">    1355 </span><span class="lineCov">         25 :         gf_filter_pid_set_property(ctx-&gt;opid, GF_PROP_PID_HEIGHT, &amp;PROP_UINT(ctx-&gt;out_height));</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            :         //recreate DSI based on first in the ordered set of pid we have
<span class="lineNum">    1358 </span>            :         //this avoids cases where the input pid order changes due to scheduling, and they don't have exactly the same xPS
<span class="lineNum">    1359 </span><span class="lineCov">         25 :         tile_pid = gf_list_get(ctx-&gt;ordered_pids, 0);</span>
<span class="lineNum">    1360 </span><span class="lineCov">         25 :         ctx-&gt;base_pps_init_qp_delta_minus26 = tile_pid-&gt;hevc_state.pps-&gt;pic_init_qp_minus26;</span>
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineCov">         25 :         u32 nb_CTUs = ((ctx-&gt;out_width + ctx-&gt;max_CU_width - 1) / ctx-&gt;max_CU_width) * ((ctx-&gt;out_height + ctx-&gt;max_CU_height - 1) / ctx-&gt;max_CU_height);</span>
<span class="lineNum">    1363 </span><span class="lineCov">         25 :         ctx-&gt;nb_bits_per_address_dst = 0;</span>
<span class="lineNum">    1364 </span><span class="lineCov">        181 :         while (nb_CTUs &gt; (u32)(1 &lt;&lt; ctx-&gt;nb_bits_per_address_dst)) {</span>
<span class="lineNum">    1365 </span><span class="lineCov">        131 :                 ctx-&gt;nb_bits_per_address_dst++;</span>
<span class="lineNum">    1366 </span>            :         }
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span><span class="lineCov">         25 :         dsi = gf_filter_pid_get_property(tile_pid-&gt;pid, GF_PROP_PID_DECODER_CONFIG);</span>
<span class="lineNum">    1369 </span>            :         assert(dsi);
<span class="lineNum">    1370 </span><span class="lineCov">         25 :         return hevcmerge_rewrite_config(ctx, ctx-&gt;opid, dsi-&gt;value.data.ptr, dsi-&gt;value.data.size);</span>
<a name="1371"><span class="lineNum">    1371 </span>            : }</a>
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineCov">       3872 : static GF_Err hevcmerge_process(GF_Filter *filter)</span>
<span class="lineNum">    1374 </span>            : {
<span class="lineNum">    1375 </span>            :         char *data;
<span class="lineNum">    1376 </span>            :         u32 pos, nal_length, data_size, i;
<span class="lineNum">    1377 </span>            :         s32 current_poc=0;
<span class="lineNum">    1378 </span>            :         u8 temporal_id, layer_id, nal_unit_type;
<span class="lineNum">    1379 </span>            :         u32 nb_eos, nb_ipid;
<span class="lineNum">    1380 </span>            :         Bool found_sei_prefix=GF_FALSE, found_sei_suffix=GF_FALSE;
<span class="lineNum">    1381 </span>            :         u64 min_dts = GF_FILTER_NO_TS;
<span class="lineNum">    1382 </span>            :         u32 min_dts_timescale=0;
<span class="lineNum">    1383 </span>            :         GF_FilterPacket *output_pck = NULL;
<span class="lineNum">    1384 </span><span class="lineCov">       3872 :         GF_HEVCMergeCtx *ctx = (GF_HEVCMergeCtx*) gf_filter_get_udta (filter);</span>
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span><span class="lineCov">       3872 :         if (ctx-&gt;in_error)</span>
<span class="lineNum">    1387 </span>            :                 return GF_BAD_PARAM;
<span class="lineNum">    1388 </span>            :         nb_eos = 0;
<span class="lineNum">    1389 </span><span class="lineCov">       3872 :         nb_ipid = gf_list_count(ctx-&gt;pids);</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            :         //probe input for at least one packet on each pid
<span class="lineNum">    1392 </span><span class="lineCov">      22977 :         for (i = 0; i &lt; nb_ipid; i++) {</span>
<span class="lineNum">    1393 </span>            :                 u64 dts;
<span class="lineNum">    1394 </span>            :                 GF_FilterPacket *pck_src;
<span class="lineNum">    1395 </span><span class="lineCov">      19222 :                 HEVCTilePidCtx *tile_pid = gf_list_get(ctx-&gt;pids, i);</span>
<span class="lineNum">    1396 </span><span class="lineCov">      19222 :                 if (tile_pid-&gt;in_error) {</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :                         nb_eos++;</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1399 </span>            :                 }
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineCov">      19222 :                 pck_src = gf_filter_pid_get_packet(tile_pid-&gt;pid);</span>
<span class="lineNum">    1402 </span><span class="lineCov">      19222 :                 if (!pck_src) {</span>
<span class="lineNum">    1403 </span><span class="lineCov">        142 :                         if (gf_filter_pid_is_eos(tile_pid-&gt;pid)) {</span>
<span class="lineNum">    1404 </span><span class="lineCov">         25 :                                 nb_eos++;</span>
<span class="lineNum">    1405 </span><span class="lineCov">         25 :                                 continue;</span>
<span class="lineNum">    1406 </span>            :                         }
<span class="lineNum">    1407 </span>            :                         return GF_OK;
<span class="lineNum">    1408 </span>            :                 }
<span class="lineNum">    1409 </span><span class="lineCov">      19080 :                 dts = gf_filter_pck_get_dts(pck_src);</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span><span class="lineCov">      19080 :                 if (dts * min_dts_timescale &lt; min_dts * tile_pid-&gt;timescale) {</span>
<span class="lineNum">    1412 </span>            :                         min_dts = dts;
<span class="lineNum">    1413 </span>            :                         min_dts_timescale = tile_pid-&gt;timescale;
<span class="lineNum">    1414 </span>            :                 }
<span class="lineNum">    1415 </span>            :         }
<span class="lineNum">    1416 </span><span class="lineCov">       3755 :         if (nb_eos == nb_ipid) {</span>
<span class="lineNum">    1417 </span><span class="lineCov">          5 :                 gf_filter_pid_set_eos(ctx-&gt;opid);</span>
<span class="lineNum">    1418 </span><span class="lineCov">          5 :                 return GF_EOS;</span>
<span class="lineNum">    1419 </span>            :         }
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span>            :         //reassemble based on the ordered list of pids
<span class="lineNum">    1422 </span><span class="lineCov">      18750 :         for (i = 0; i &lt; nb_ipid; i++) {</span>
<span class="lineNum">    1423 </span>            :                 u64 dts;
<span class="lineNum">    1424 </span>            :                 GF_FilterPacket *pck_src;
<span class="lineNum">    1425 </span><span class="lineCov">      18750 :                 HEVCTilePidCtx *tile_pid = gf_list_get(ctx-&gt;ordered_pids, i);</span>
<span class="lineNum">    1426 </span>            :                 assert(tile_pid);
<span class="lineNum">    1427 </span><span class="lineCov">      18750 :                 if (tile_pid-&gt;in_error)</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1429 </span><span class="lineCov">      18750 :                 pck_src = gf_filter_pid_get_packet(tile_pid-&gt;pid);</span>
<span class="lineNum">    1430 </span><span class="lineCov">      18750 :                 if (nb_eos) {</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :                         if (pck_src) {</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :                                 tile_pid-&gt;nb_pck++;</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :                                 GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] pids of unequal duration, skipping packet %d on pid %d\n&quot;, tile_pid-&gt;nb_pck, i+1));</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :                                 gf_filter_pid_drop_packet(tile_pid-&gt;pid);</span>
<span class="lineNum">    1435 </span>            :                         }
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1437 </span>            :                 }
<span class="lineNum">    1438 </span><span class="lineCov">      18750 :                 if (!pck_src) {</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :                         GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] no data on pid %d while merging, eos detected %d\n&quot;, i+1, gf_filter_pid_is_eos(tile_pid-&gt;pid) ));</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1441 </span>            :                 }
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineCov">      18750 :                 dts = gf_filter_pck_get_dts(pck_src);</span>
<span class="lineNum">    1444 </span><span class="lineCov">      18750 :                 if (dts * min_dts_timescale != min_dts * tile_pid-&gt;timescale) continue;</span>
<span class="lineNum">    1445 </span><span class="lineCov">      18750 :                 data = (char *)gf_filter_pck_get_data(pck_src, &amp;data_size); // data contains only a packet</span>
<span class="lineNum">    1446 </span>            :                 // TODO: this is a clock signaling, for now just trash ..
<span class="lineNum">    1447 </span><span class="lineCov">      18750 :                 if (!data) {</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :                         gf_filter_pid_drop_packet(tile_pid-&gt;pid);</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1450 </span>            :                 }
<span class="lineNum">    1451 </span><span class="lineCov">      18750 :                 tile_pid-&gt;nb_pck++;</span>
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span>            :                 //parse the access unit for this pid
<span class="lineNum">    1454 </span><span class="lineCov">      18750 :                 gf_bs_reassign_buffer(ctx-&gt;bs_au_in, data, data_size);</span>
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span><span class="lineCov">      75025 :                 while (gf_bs_available(ctx-&gt;bs_au_in)) {</span>
<span class="lineNum">    1457 </span>            :                         u8 *output_nal;
<span class="lineNum">    1458 </span>            :                         u8 *nal_pck;
<span class="lineNum">    1459 </span>            :                         u32 nal_pck_size;
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span><span class="lineCov">      37525 :                         nal_length = gf_bs_read_int(ctx-&gt;bs_au_in, tile_pid-&gt;nalu_size_length * 8);</span>
<span class="lineNum">    1462 </span><span class="lineCov">      37525 :                         pos = (u32) gf_bs_get_position(ctx-&gt;bs_au_in);</span>
<span class="lineNum">    1463 </span><span class="lineCov">      37525 :                         gf_hevc_parse_nalu(data + pos, nal_length, &amp;tile_pid-&gt;hevc_state, &amp;nal_unit_type, &amp;temporal_id, &amp;layer_id);</span>
<span class="lineNum">    1464 </span><span class="lineCov">      37525 :                         gf_bs_skip_bytes(ctx-&gt;bs_au_in, nal_length); //skip nal in bs</span>
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span>            :                         //VCL nal, rewrite slice header
<span class="lineNum">    1467 </span><span class="lineCov">      37525 :                         if (nal_unit_type &lt; 32) {</span>
<span class="lineNum">    1468 </span><span class="lineCov">      18750 :                                 if (!i) current_poc = tile_pid-&gt;hevc_state.s_info.poc;</span>
<span class="lineNum">    1469 </span><span class="lineCov">      15000 :                                 else if (current_poc != tile_pid-&gt;hevc_state.s_info.poc) {</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :                                         GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, (&quot;[HEVCMerge] merging AU %u with different POC (%d vs %d), undefined results.\n&quot;, tile_pid-&gt;nb_pck, current_poc, tile_pid-&gt;hevc_state.s_info.poc));</span>
<span class="lineNum">    1471 </span>            :                                 }
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineCov">      18750 :                                 nal_pck_size = hevcmerge_rewrite_slice(ctx, tile_pid, data + pos, nal_length);</span>
<span class="lineNum">    1474 </span><span class="lineCov">      18750 :                                 nal_pck = ctx-&gt;buffer_nal;</span>
<span class="lineNum">    1475 </span>            :                         }
<span class="lineNum">    1476 </span>            :                         //NON-vcl, copy for SEI or drop (we should not have any SPS/PPS/VPS in the bitstream, they are in the decoder config prop)
<span class="lineNum">    1477 </span>            :                         else {
<span class="lineNum">    1478 </span><span class="lineCov">      18775 :                                 gf_hevc_parse_nalu(data + pos, nal_length, &amp;tile_pid-&gt;hevc_state, &amp;nal_unit_type, &amp;temporal_id, &amp;layer_id);</span>
<span class="lineNum">    1479 </span>            :                                 // Copy SEI_PREFIX only for the first sample.
<span class="lineNum">    1480 </span><span class="lineCov">      18775 :                                 if (nal_unit_type == GF_HEVC_NALU_SEI_PREFIX &amp;&amp; !found_sei_prefix) {</span>
<span class="lineNum">    1481 </span>            :                                         found_sei_prefix = GF_TRUE;
<span class="lineNum">    1482 </span>            :                                         nal_pck = data + pos;
<span class="lineNum">    1483 </span>            :                                         nal_pck_size = nal_length;
<span class="lineNum">    1484 </span>            :                                 }
<span class="lineNum">    1485 </span>            :                                 // Copy SEI_SUFFIX only as last nalu of the sample.
<span class="lineNum">    1486 </span><span class="lineCov">      18770 :                                 else if (nal_unit_type == GF_HEVC_NALU_SEI_SUFFIX &amp;&amp; ((i+1 == nb_ipid) || !found_sei_suffix) ) {</span>
<span class="lineNum">    1487 </span>            :                                         found_sei_suffix = GF_TRUE;
<span class="lineNum">    1488 </span><span class="lineCov">       7500 :                                         if (ctx-&gt;sei_suffix_alloc&lt;nal_length) {</span>
<span class="lineNum">    1489 </span><span class="lineCov">          5 :                                                 ctx-&gt;sei_suffix_alloc = nal_length;</span>
<span class="lineNum">    1490 </span><span class="lineCov">          5 :                                                 ctx-&gt;sei_suffix_buf = gf_realloc(ctx-&gt;sei_suffix_buf, nal_length);</span>
<span class="lineNum">    1491 </span>            :                                         }
<span class="lineNum">    1492 </span><span class="lineCov">       7500 :                                         ctx-&gt;sei_suffix_len = nal_length;</span>
<span class="lineNum">    1493 </span><span class="lineCov">       7500 :                                         memcpy(ctx-&gt;sei_suffix_buf, data+pos, nal_length);</span>
<span class="lineNum">    1494 </span><span class="lineCov">      26270 :                                         continue;</span>
<span class="lineNum">    1495 </span>            :                                 }
<span class="lineNum">    1496 </span><span class="lineCov">      11270 :                                 else continue;</span>
<span class="lineNum">    1497 </span>            :                         }
<span class="lineNum">    1498 </span><span class="lineCov">      18755 :                         if (!output_pck) {</span>
<span class="lineNum">    1499 </span><span class="lineCov">       3750 :                                 output_pck = gf_filter_pck_new_alloc(ctx-&gt;opid, ctx-&gt;hevc_nalu_size_length + nal_pck_size, &amp;output_nal);</span>
<span class="lineNum">    1500 </span><span class="lineCov">       3750 :                                 if (!output_pck) return GF_OUT_OF_MEM;</span>
<span class="lineNum">    1501 </span>            :                                 
<span class="lineNum">    1502 </span>            :                                 // todo: might need to rewrite crypto info
<span class="lineNum">    1503 </span><span class="lineCov">       3750 :                                 gf_filter_pck_merge_properties(pck_src, output_pck);</span>
<span class="lineNum">    1504 </span>            :                         }
<span class="lineNum">    1505 </span>            :                         else {
<span class="lineNum">    1506 </span>            :                                 u8 *data_start;
<span class="lineNum">    1507 </span>            :                                 u32 new_size;
<span class="lineNum">    1508 </span><span class="lineCov">      15005 :                                 gf_filter_pck_expand(output_pck, ctx-&gt;hevc_nalu_size_length + nal_pck_size, &amp;data_start, &amp;output_nal, &amp;new_size);</span>
<span class="lineNum">    1509 </span>            :                         }
<span class="lineNum">    1510 </span><span class="lineCov">      18755 :                         hevcmerge_write_nal(ctx, output_nal, nal_pck, nal_pck_size);</span>
<span class="lineNum">    1511 </span>            :                 }
<span class="lineNum">    1512 </span><span class="lineCov">      18750 :                 gf_filter_pid_drop_packet(tile_pid-&gt;pid);</span>
<span class="lineNum">    1513 </span>            :         }
<span class="lineNum">    1514 </span>            :         // end of loop on inputs
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            :         //if we had a SEI suffix, append it
<span class="lineNum">    1517 </span><span class="lineCov">       3750 :         if (ctx-&gt;sei_suffix_len) {</span>
<span class="lineNum">    1518 </span><span class="lineCov">       3750 :                 if (output_pck) {</span>
<span class="lineNum">    1519 </span>            :                         u8 *output_nal;
<span class="lineNum">    1520 </span>            :                         u8 *data_start;
<span class="lineNum">    1521 </span>            :                         u32 new_size;
<span class="lineNum">    1522 </span><span class="lineCov">       3750 :                         gf_filter_pck_expand(output_pck, ctx-&gt;hevc_nalu_size_length + ctx-&gt;sei_suffix_len, &amp;data_start, &amp;output_nal, &amp;new_size);</span>
<span class="lineNum">    1523 </span><span class="lineCov">       3750 :                         hevcmerge_write_nal(ctx, output_nal, ctx-&gt;sei_suffix_buf, ctx-&gt;sei_suffix_len);</span>
<span class="lineNum">    1524 </span>            :                 }
<span class="lineNum">    1525 </span><span class="lineCov">       3750 :                 ctx-&gt;sei_suffix_len = 0;</span>
<span class="lineNum">    1526 </span>            :         }
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span><span class="lineCov">       3750 :         if (output_pck)</span>
<span class="lineNum">    1529 </span><span class="lineCov">       3750 :                 gf_filter_pck_send(output_pck);</span>
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            :         return GF_OK;
<a name="1532"><span class="lineNum">    1532 </span>            : }</a>
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineCov">          5 : static GF_Err hevcmerge_initialize(GF_Filter *filter)</span>
<span class="lineNum">    1535 </span>            : {
<span class="lineNum">    1536 </span><span class="lineCov">          5 :         GF_LOG(GF_LOG_DEBUG, GF_LOG_CODEC, (&quot;[HEVCMerge] hevcmerge_initialize started.\n&quot;));</span>
<span class="lineNum">    1537 </span><span class="lineCov">          5 :         GF_HEVCMergeCtx *ctx = (GF_HEVCMergeCtx *)gf_filter_get_udta(filter);</span>
<span class="lineNum">    1538 </span><span class="lineCov">          5 :         ctx-&gt;bs_au_in = gf_bs_new((char *)ctx, 1, GF_BITSTREAM_READ);</span>
<span class="lineNum">    1539 </span><span class="lineCov">          5 :         ctx-&gt;bs_nal_in = gf_bs_new((char *)ctx, 1, GF_BITSTREAM_READ);</span>
<span class="lineNum">    1540 </span><span class="lineCov">          5 :         ctx-&gt;pids = gf_list_new();</span>
<span class="lineNum">    1541 </span><span class="lineCov">          5 :         ctx-&gt;ordered_pids = gf_list_new();</span>
<span class="lineNum">    1542 </span><span class="lineCov">          5 :         return GF_OK;</span>
<a name="1543"><span class="lineNum">    1543 </span>            : }</a>
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span><span class="lineCov">          5 : static void hevcmerge_finalize(GF_Filter *filter)</span>
<span class="lineNum">    1546 </span>            : {
<span class="lineNum">    1547 </span><span class="lineCov">          5 :         GF_LOG(GF_LOG_DEBUG, GF_LOG_CODEC, (&quot;[HEVCMerge] hevcmerge_finalize.\n&quot;));</span>
<span class="lineNum">    1548 </span><span class="lineCov">          5 :         GF_HEVCMergeCtx *ctx = (GF_HEVCMergeCtx *)gf_filter_get_udta(filter);</span>
<span class="lineNum">    1549 </span><span class="lineCov">          5 :         if (ctx-&gt;buffer_nal) gf_free(ctx-&gt;buffer_nal);</span>
<span class="lineNum">    1550 </span><span class="lineCov">          5 :         if (ctx-&gt;buffer_nal_no_epb) gf_free(ctx-&gt;buffer_nal_no_epb);</span>
<span class="lineNum">    1551 </span><span class="lineCov">          5 :         if (ctx-&gt;buffer_nal_in_no_epb) gf_free(ctx-&gt;buffer_nal_in_no_epb);</span>
<span class="lineNum">    1552 </span><span class="lineCov">          5 :         gf_bs_del(ctx-&gt;bs_au_in);</span>
<span class="lineNum">    1553 </span><span class="lineCov">          5 :         gf_bs_del(ctx-&gt;bs_nal_in);</span>
<span class="lineNum">    1554 </span><span class="lineCov">          5 :         if (ctx-&gt;bs_nal_out)</span>
<span class="lineNum">    1555 </span><span class="lineCov">          5 :                 gf_bs_del(ctx-&gt;bs_nal_out);</span>
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span><span class="lineCov">          5 :         if (ctx-&gt;grid) gf_free(ctx-&gt;grid);</span>
<span class="lineNum">    1558 </span><span class="lineCov">         30 :         while (gf_list_count(ctx-&gt;pids)) {</span>
<span class="lineNum">    1559 </span><span class="lineCov">         25 :                 HEVCTilePidCtx *pctx = gf_list_pop_back(ctx-&gt;pids);</span>
<span class="lineNum">    1560 </span><span class="lineCov">         25 :                 gf_free(pctx);</span>
<span class="lineNum">    1561 </span>            :         }
<span class="lineNum">    1562 </span><span class="lineCov">          5 :         gf_list_del(ctx-&gt;pids);</span>
<span class="lineNum">    1563 </span><span class="lineCov">          5 :         gf_list_del(ctx-&gt;ordered_pids);</span>
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span><span class="lineCov">          5 :         if (ctx-&gt;sei_suffix_buf) gf_free(ctx-&gt;sei_suffix_buf);</span>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineCov">          5 : }</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span>            : static const GF_FilterCapability HEVCMergeCaps[] =
<span class="lineNum">    1570 </span>            : {
<span class="lineNum">    1571 </span>            :         CAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),
<span class="lineNum">    1572 </span>            :         CAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_HEVC),
<span class="lineNum">    1573 </span>            :         CAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),
<span class="lineNum">    1574 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),
<span class="lineNum">    1575 </span>            :         CAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_HEVC)
<span class="lineNum">    1576 </span>            : };
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            : #define OFFS(_n)        #_n, offsetof(GF_HEVCMergeCtx, _n)
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            : static const GF_FilterArgs HEVCMergeArgs[] =
<span class="lineNum">    1581 </span>            : {
<span class="lineNum">    1582 </span>            :         { OFFS(strict), &quot;strict comparison of SPS and PPS of input pids - see filter help&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1583 </span>            :         { OFFS(mrows), &quot;signal multiple rows in tile grid when possible&quot;, GF_PROP_BOOL, &quot;false&quot;, NULL, GF_FS_ARG_HINT_ADVANCED},
<span class="lineNum">    1584 </span>            :         {0}
<span class="lineNum">    1585 </span>            : };
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span>            : GF_FilterRegister HEVCMergeRegister = {
<span class="lineNum">    1588 </span>            :         .name = &quot;hevcmerge&quot;,
<span class="lineNum">    1589 </span>            :         GF_FS_SET_DESCRIPTION(&quot;HEVC Tile merger&quot;)
<span class="lineNum">    1590 </span>            :         GF_FS_SET_HELP(&quot;This filter merges a set of HEVC PIDs into a single motion-constrained tiled HEVC PID.\n&quot;
<span class="lineNum">    1591 </span>            :                 &quot;The filter creates a tiling grid with a single row and as many columns as needed.\n&quot;
<span class="lineNum">    1592 </span>            :                 &quot;If [-mrows]() is set and tiles properly align on the final grid, multiple rows will be declared in the PPS.\n&quot;
<span class="lineNum">    1593 </span>            :                 &quot;Positioning of tiles can be automatic (implicit) or explicit.\n&quot;
<span class="lineNum">    1594 </span>            :                 &quot;The filter will check the SPS and PPS configurations of input PID and warn if they are not aligned but will still process them unless [-strict]() is set.\n&quot;
<span class="lineNum">    1595 </span>            :                 &quot;The filter assumes that all input PIDs are synchronized (frames share the same timestamp) and will reassemble frames with the same dts. If pids are of unequal duration, the filter will drop frames as soon as one pid is over.\n&quot;
<span class="lineNum">    1596 </span>            :                 &quot;## Implicit Positioning\n&quot;
<span class="lineNum">    1597 </span>            :                 &quot;In implicit positioning, results may vary based on the order of input pids declaration.\n&quot;
<span class="lineNum">    1598 </span>            :                 &quot;In this mode the filter will automatically allocate new columns for tiles with height not a multiple of max CU height.\n&quot;
<span class="lineNum">    1599 </span>            :                 &quot;## Explicit Positioning\n&quot;
<span class="lineNum">    1600 </span>            :                 &quot;In explicit positioning, the `CropOrigin` property on input PIDs is used to setup the tile grid. In this case, tiles shall not overlap in the final output.\n&quot;
<span class="lineNum">    1601 </span>            :                 &quot;If `CropOrigin` is used, it shall be set on all input sources.\n&quot;
<span class="lineNum">    1602 </span>            :                 &quot;If positive coordinates are used, they specify absolute positioning in pixels of the tiles. The coordinates are automatically adjusted to the next multiple of max CU width and height.\n&quot;
<span class="lineNum">    1603 </span>            :                 &quot;If negative coordinates are used, they specify relative positioning (eg `0x-1` indicates to place the tile below the tile 0x0).\n&quot;
<span class="lineNum">    1604 </span>            :                 &quot;In this mode, it is the caller responsibility to set coordinates so that all tiles in a column have the same width and only the last row/column uses non-multiple of max CU width/height values. The filter will complain and abort if this is not respected.\n&quot;
<span class="lineNum">    1605 </span>            :                 &quot;- If an horizontal blank is detected in the layout, an empty column in the tiling grid will be inserted.\n&quot;
<span class="lineNum">    1606 </span>            :                 &quot;- If a vertical blank is detected in the layout, it is ignored.\n&quot;
<span class="lineNum">    1607 </span>            :                 &quot;  \n&quot;
<span class="lineNum">    1608 </span>            :                 &quot;## Spatial Relationship Description (SRD)\n&quot;
<span class="lineNum">    1609 </span>            :                 &quot;\n&quot;
<span class="lineNum">    1610 </span>            :                 &quot;The filter will create an `SRDMap` property in the output PID if `SRDRef` and `SRD` or `CropOrigin` are set on all input PIDs.\n&quot;
<span class="lineNum">    1611 </span>            :                 &quot;The `SRDMap` allows forwarding the logical sources `SRD` in the merged PID.\n&quot;
<span class="lineNum">    1612 </span>            :                 &quot;The output pid `SRDRef` is set to the output video size.\n&quot;
<span class="lineNum">    1613 </span>            :                 &quot;The input `SRDRef` and `SRD` are usually specified in DASH MPD, but can be manually assigned to inputs.\n&quot;
<span class="lineNum">    1614 </span>            :                 &quot;- `SRDRef` gives the size of the referential used for the input `SRD` (usually matches the original video size, but not always)\n&quot;
<span class="lineNum">    1615 </span>            :                 &quot;- `SRD` gives the size and position of the input in the original video, expressed in `SRDRef` referential of the input.\n&quot;
<span class="lineNum">    1616 </span>            :                 &quot;The inputs do not need to have matching `SRDRef`.&quot;
<span class="lineNum">    1617 </span>            :                 &quot;EX src1:SRD=0x0x640x480:SRDRef=1280x720\n&quot;
<span class="lineNum">    1618 </span>            :                 &quot;This indicates that `src1` contains a video located at 0,0, with a size of 640x480 pixels in a virtual source of 1280x720 pixels.\n&quot;
<span class="lineNum">    1619 </span>            :                 &quot;EX src2:SRD=640x0x640x480:SRDRef=1280x720\n&quot;
<span class="lineNum">    1620 </span>            :                 &quot;This indicates that `src1` contains a video located at 640,0, with a size of 640x480 pixels in a virtual source of 1280x720 pixels.\n&quot;
<span class="lineNum">    1621 </span>            :                 &quot; \n&quot;
<span class="lineNum">    1622 </span>            :                 &quot;Each merged input is described by 8 intergers in the output `SRDMap`:\n&quot;
<span class="lineNum">    1623 </span>            :                 &quot;- the source `SRD` is rescaled in the output `SRDRef` to form the first part (4 integers) of the `SRDMap` (i.e. __where was the input ?__)\n&quot;
<span class="lineNum">    1624 </span>            :                 &quot;- the source location in the reconstructed video forms the second part (4 integers) of the `SRDMap` (i.e. __where are the input pixels in the output ?__)\n&quot;
<span class="lineNum">    1625 </span>            :                 &quot;Assuming the two sources are encoded at 320x240 and merged as src2 above src1, the output will be a 320x480 video with a `SRDMap` of {0,160,160,240,0,0,320,240,0,0,160,240,0,240,320,240}\n&quot;
<span class="lineNum">    1626 </span>            :                 &quot;Note: merged inputs are always listed in `SRDMap` in their tile order in the output bitstream.\n&quot;
<span class="lineNum">    1627 </span>            :                 &quot;\n&quot;
<span class="lineNum">    1628 </span>            :                 &quot;Alternatively to using `SRD` and `SRDRef`, it is possible to specify `CropOrigin` property on the inputs, in which case:\n&quot;
<span class="lineNum">    1629 </span>            :                 &quot;- the `CropOrigin` gives the location in the source\n&quot;
<span class="lineNum">    1630 </span>            :                 &quot;- the input size gives the size in the source, and no rescaling of referential is done\n&quot;
<span class="lineNum">    1631 </span>            :                 &quot;EX src1:CropOrigin=0x0  src1:CropOrigin=640x0 \n&quot;
<span class="lineNum">    1632 </span>            :                 &quot;Assuming the two sources are encoded at 320x240 and merged as src1 above src2, the output will be a 320x480 video with a `SRDMap` of {0,0,320,240,0,0,320,240,640,0,320,240,0,240,320,240}\n&quot;
<span class="lineNum">    1633 </span>            :         )
<span class="lineNum">    1634 </span>            :         .private_size = sizeof(GF_HEVCMergeCtx),
<span class="lineNum">    1635 </span>            :         SETCAPS(HEVCMergeCaps),
<span class="lineNum">    1636 </span>            :         .flags = GF_FS_REG_EXPLICIT_ONLY,
<span class="lineNum">    1637 </span>            :         .initialize = hevcmerge_initialize,
<span class="lineNum">    1638 </span>            :         .finalize = hevcmerge_finalize,
<span class="lineNum">    1639 </span>            :         .args = HEVCMergeArgs,
<span class="lineNum">    1640 </span>            :         .configure_pid = hevcmerge_configure_pid,
<span class="lineNum">    1641 </span>            :         .process = hevcmerge_process,
<span class="lineNum">    1642 </span>            :         .max_extra_pids = -1,
<a name="1643"><span class="lineNum">    1643 </span>            : };</a>
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span><span class="lineCov">       2877 : const GF_FilterRegister *hevcmerge_register(GF_FilterSession *session)</span>
<span class="lineNum">    1646 </span>            : {
<span class="lineNum">    1647 </span><span class="lineCov">       2877 :         return &amp;HEVCMergeRegister;</span>
<span class="lineNum">    1648 </span>            : }
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span>            : #else
<span class="lineNum">    1651 </span>            : const GF_FilterRegister *hevcmerge_register(GF_FilterSession *session)
<span class="lineNum">    1652 </span>            : {
<span class="lineNum">    1653 </span>            :         return NULL;
<span class="lineNum">    1654 </span>            : }
<span class="lineNum">    1655 </span>            : #endif // GPAC_DISABLE_AV_PARSERS
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
