<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - ietf/rtp_pck_mpeg4.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">ietf</a> - rtp_pck_mpeg4.c<span style="font-size: 80%;"> (source / <a href="rtp_pck_mpeg4.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">306</td>
            <td class="headerCovTableEntry">343</td>
            <td class="headerCovTableEntryMed">89.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-04-29 23:48:07</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryMed">85.7 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *                      GPAC - Multimedia Framework C SDK
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *                      Authors: Jean Le Feuvre
<span class="lineNum">       5 </span>            :  *                      Copyright (c) Telecom ParisTech 2000-2012
<span class="lineNum">       6 </span>            :  *                                      All rights reserved
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *  GPAC is free software; you can redistribute it and/or modify
<span class="lineNum">      11 </span>            :  *  it under the terms of the GNU Lesser General Public License as published by
<span class="lineNum">      12 </span>            :  *  the Free Software Foundation; either version 2, or (at your option)
<span class="lineNum">      13 </span>            :  *  any later version.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  *  GPAC is distributed in the hope that it will be useful,
<span class="lineNum">      16 </span>            :  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      17 </span>            :  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      18 </span>            :  *  GNU Lesser General Public License for more details.
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  *  You should have received a copy of the GNU Lesser General Public
<span class="lineNum">      21 </span>            :  *  License along with this library; see the file COPYING.  If not, write to
<span class="lineNum">      22 </span>            :  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &lt;gpac/internal/ietf_dev.h&gt;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #ifndef GPAC_DISABLE_STREAMING
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;gpac/constants.h&gt;
<a name="31"><span class="lineNum">      31 </span>            : </a>
<span class="lineNum">      32 </span>            : //get the size of the RSLH section given the GF_SLHeader and the SLMap
<span class="lineNum">      33 </span><span class="lineCov">      25192 : static u32 gf_rtp_build_au_hdr_size(GP_RTPPacketizer *builder, GF_SLHeader *slh)</span>
<span class="lineNum">      34 </span>            : {
<span class="lineNum">      35 </span>            :         u32 nbBits = 0;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            :         /*sel enc*/
<span class="lineNum">      38 </span><span class="lineCov">      25192 :         if (builder-&gt;flags &amp; GP_RTP_PCK_SELECTIVE_ENCRYPTION) nbBits += 8;</span>
<span class="lineNum">      39 </span>            :         /*Note: ISMACryp ALWAYS indicates IV (BSO) and KEYIDX, even when sample is not encrypted. This is
<span class="lineNum">      40 </span>            :         quite a waste when using selective encryption....*/
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :         /*IV*/
<span class="lineNum">      43 </span><span class="lineCov">      25192 :         nbBits += builder-&gt;first_sl_in_rtp ? 8*builder-&gt;slMap.IV_length : 8*builder-&gt;slMap.IV_delta_length;</span>
<span class="lineNum">      44 </span>            :         /*keyIndicator*/
<span class="lineNum">      45 </span><span class="lineCov">      25192 :         if (builder-&gt;first_sl_in_rtp || (builder-&gt;flags &amp; GP_RTP_PCK_KEY_IDX_PER_AU)) {</span>
<span class="lineNum">      46 </span><span class="lineCov">      14502 :                 nbBits += 8*builder-&gt;slMap.KI_length;</span>
<span class="lineNum">      47 </span>            :         }
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :         /*no input header specified, compute the MAX size*/
<span class="lineNum">      50 </span><span class="lineCov">      25192 :         if (!slh) {</span>
<span class="lineNum">      51 </span>            :                 /*size length*/
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :                 if (!builder-&gt;slMap.ConstantSize) nbBits += builder-&gt;slMap.SizeLength;</span>
<span class="lineNum">      53 </span>            :                 /*AU index length*/
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :                 nbBits += builder-&gt;first_sl_in_rtp ? builder-&gt;slMap.IndexLength : builder-&gt;slMap.IndexDeltaLength;</span>
<span class="lineNum">      55 </span>            :                 /*CTS flag*/
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :                 if (builder-&gt;slMap.CTSDeltaLength) {</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :                         nbBits += 1;</span>
<span class="lineNum">      58 </span>            :                         /*all non-first packets have the CTS written if asked*/
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :                         if (!builder-&gt;first_sl_in_rtp) nbBits += builder-&gt;slMap.CTSDeltaLength;</span>
<span class="lineNum">      60 </span>            :                 }
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :                 if (builder-&gt;slMap.DTSDeltaLength) nbBits += 1 + builder-&gt;slMap.DTSDeltaLength;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :                 if (builder-&gt;flags &amp; GP_RTP_PCK_SELECTIVE_ENCRYPTION) nbBits += 8;</span>
<span class="lineNum">      63 </span>            :                 return nbBits;
<span class="lineNum">      64 </span>            :         }
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :         /*size length*/
<span class="lineNum">      67 </span><span class="lineCov">      25192 :         if (!builder-&gt;slMap.ConstantSize) nbBits += builder-&gt;slMap.SizeLength;</span>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :         /*AU index*/
<span class="lineNum">      70 </span><span class="lineCov">      25192 :         if (builder-&gt;first_sl_in_rtp) {</span>
<span class="lineNum">      71 </span><span class="lineCov">      14502 :                 if (builder-&gt;slMap.IndexLength) nbBits += builder-&gt;slMap.IndexLength;</span>
<span class="lineNum">      72 </span>            :         } else {
<span class="lineNum">      73 </span><span class="lineCov">      10690 :                 if (builder-&gt;slMap.IndexDeltaLength) nbBits += builder-&gt;slMap.IndexDeltaLength;</span>
<span class="lineNum">      74 </span>            :         }
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :         /*CTS Flag*/
<span class="lineNum">      77 </span><span class="lineCov">      25192 :         if (builder-&gt;slMap.CTSDeltaLength) {</span>
<span class="lineNum">      78 </span>            :                 /*CTS not written if first SL*/
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :                 if (builder-&gt;first_sl_in_rtp) slh-&gt;compositionTimeStampFlag = 0;</span>
<span class="lineNum">      80 </span>            :                 /*but CTS flag is always written*/
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :                 nbBits += 1;</span>
<span class="lineNum">      82 </span>            :         } else {
<span class="lineNum">      83 </span><span class="lineCov">      25192 :                 slh-&gt;compositionTimeStampFlag = 0;</span>
<span class="lineNum">      84 </span>            :         }
<span class="lineNum">      85 </span>            :         /*CTS*/
<span class="lineNum">      86 </span><span class="lineCov">      25192 :         if (slh-&gt;compositionTimeStampFlag) nbBits += builder-&gt;slMap.CTSDeltaLength;</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :         /*DTS Flag*/
<span class="lineNum">      89 </span><span class="lineCov">      25192 :         if (builder-&gt;slMap.DTSDeltaLength) {</span>
<span class="lineNum">      90 </span><span class="lineCov">       3157 :                 nbBits += 1;</span>
<span class="lineNum">      91 </span>            :         } else {
<span class="lineNum">      92 </span><span class="lineCov">      22035 :                 slh-&gt;decodingTimeStampFlag = 0;</span>
<span class="lineNum">      93 </span>            :         }
<span class="lineNum">      94 </span>            :         /*DTS*/
<span class="lineNum">      95 </span><span class="lineCov">      25192 :         if (slh-&gt;decodingTimeStampFlag) nbBits += builder-&gt;slMap.DTSDeltaLength;</span>
<span class="lineNum">      96 </span>            :         /*RAP indication*/
<span class="lineNum">      97 </span><span class="lineCov">      25192 :         if (builder-&gt;slMap.RandomAccessIndication) nbBits ++;</span>
<span class="lineNum">      98 </span>            :         /*streamState indication*/
<span class="lineNum">      99 </span><span class="lineCov">      25192 :         nbBits += builder-&gt;slMap.StreamStateIndication;</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span><span class="lineCov">      25192 :         return nbBits;</span>
<span class="lineNum">     102 </span>            : }
<span class="lineNum">     103 </span>            : 
<a name="104"><span class="lineNum">     104 </span>            : </a>
<span class="lineNum">     105 </span>            : /*write the AU header section - return the nb of BITS written for AU header*/
<span class="lineNum">     106 </span><span class="lineCov">      20996 : u32 gf_rtp_build_au_hdr_write(GP_RTPPacketizer *builder, u32 PayloadSize, u32 RTP_TS)</span>
<span class="lineNum">     107 </span>            : {
<span class="lineNum">     108 </span>            :         u32 nbBits = 0;
<span class="lineNum">     109 </span>            :         s32 delta;
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :         /*selective encryption*/
<span class="lineNum">     112 </span><span class="lineCov">      20996 :         if (builder-&gt;flags &amp; GP_RTP_PCK_SELECTIVE_ENCRYPTION) {</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :                 gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;is_encrypted, 1);</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :                 gf_bs_write_int(builder-&gt;pck_hdr, 0, 7);</span>
<span class="lineNum">     115 </span>            :                 nbBits = 8;
<span class="lineNum">     116 </span>            :         }
<span class="lineNum">     117 </span>            :         /*IV*/
<span class="lineNum">     118 </span><span class="lineCov">      20996 :         if (builder-&gt;first_sl_in_rtp) {</span>
<span class="lineNum">     119 </span><span class="lineCov">      14502 :                 if (builder-&gt;slMap.IV_length) {</span>
<span class="lineNum">     120 </span><span class="lineCov">       1016 :                         gf_bs_write_long_int(builder-&gt;pck_hdr, builder-&gt;IV, 8*builder-&gt;slMap.IV_length);</span>
<span class="lineNum">     121 </span><span class="lineCov">       1016 :                         nbBits += 8*builder-&gt;slMap.IV_length;</span>
<span class="lineNum">     122 </span>            :                 }
<span class="lineNum">     123 </span>            :         } else if (builder-&gt;slMap.IV_delta_length) {
<span class="lineNum">     124 </span>            :                 /*NOT SUPPORTED!!! this only applies to interleaving*/
<span class="lineNum">     125 </span>            :         }
<span class="lineNum">     126 </span>            :         /*key*/
<span class="lineNum">     127 </span><span class="lineCov">      20996 :         if (builder-&gt;slMap.KI_length) {</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :                 if (builder-&gt;first_sl_in_rtp || (builder-&gt;flags &amp; GP_RTP_PCK_KEY_IDX_PER_AU)) {</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :                         if (builder-&gt;key_indicator) gf_bs_write_data(builder-&gt;pck_hdr, builder-&gt;key_indicator, builder-&gt;slMap.KI_length);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :                         else gf_bs_write_int(builder-&gt;pck_hdr, 0, 8*builder-&gt;slMap.KI_length);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :                         nbBits += 8*builder-&gt;slMap.KI_length;</span>
<span class="lineNum">     132 </span>            :                 }
<span class="lineNum">     133 </span>            :         }
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :         /*size length*/
<span class="lineNum">     137 </span><span class="lineCov">      20996 :         if (builder-&gt;slMap.ConstantSize) {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :                 if (PayloadSize != builder-&gt;slMap.ConstantSize) return nbBits;</span>
<span class="lineNum">     139 </span><span class="lineCov">      20996 :         } else if (builder-&gt;slMap.SizeLength) {</span>
<span class="lineNum">     140 </span>            :                 /*write the AU size - if not enough bytes (real-time cases) set size to 0*/
<span class="lineNum">     141 </span><span class="lineCov">      10712 :                 if (builder-&gt;sl_header.accessUnitLength &gt;= (1&lt;&lt;builder-&gt;slMap.SizeLength)) {</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :                         gf_bs_write_int(builder-&gt;pck_hdr, 0, builder-&gt;slMap.SizeLength);</span>
<span class="lineNum">     143 </span>            :                 } else {
<span class="lineNum">     144 </span><span class="lineCov">      10712 :                         gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;sl_header.accessUnitLength, builder-&gt;slMap.SizeLength);</span>
<span class="lineNum">     145 </span>            :                 }
<span class="lineNum">     146 </span><span class="lineCov">      10712 :                 nbBits += builder-&gt;slMap.SizeLength;</span>
<span class="lineNum">     147 </span>            :         }
<span class="lineNum">     148 </span>            :         /*AU index*/
<span class="lineNum">     149 </span><span class="lineCov">      20996 :         if (builder-&gt;first_sl_in_rtp) {</span>
<span class="lineNum">     150 </span><span class="lineCov">      14502 :                 if (builder-&gt;slMap.IndexLength) {</span>
<span class="lineNum">     151 </span><span class="lineCov">       4218 :                         gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;sl_header.AU_sequenceNumber, builder-&gt;slMap.IndexLength);</span>
<span class="lineNum">     152 </span><span class="lineCov">       4218 :                         nbBits += builder-&gt;slMap.IndexLength;</span>
<span class="lineNum">     153 </span>            :                 }
<span class="lineNum">     154 </span>            :         } else {
<span class="lineNum">     155 </span><span class="lineCov">       6494 :                 if (builder-&gt;slMap.IndexDeltaLength) {</span>
<span class="lineNum">     156 </span>            :                         //check interleaving, otherwise force default (which is currently always the case)
<span class="lineNum">     157 </span><span class="lineCov">       6494 :                         delta = builder-&gt;sl_header.AU_sequenceNumber - builder-&gt;last_au_sn;</span>
<span class="lineNum">     158 </span><span class="lineCov">       6494 :                         delta -= 1;</span>
<span class="lineNum">     159 </span><span class="lineCov">       6494 :                         gf_bs_write_int(builder-&gt;pck_hdr, delta, builder-&gt;slMap.IndexDeltaLength);</span>
<span class="lineNum">     160 </span><span class="lineCov">       6494 :                         nbBits += builder-&gt;slMap.IndexDeltaLength;</span>
<span class="lineNum">     161 </span>            :                 }
<span class="lineNum">     162 </span>            :         }
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :         /*CTS Flag*/
<span class="lineNum">     165 </span><span class="lineCov">      20996 :         if (builder-&gt;slMap.CTSDeltaLength) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :                 if (builder-&gt;first_sl_in_rtp) {</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :                         builder-&gt;sl_header.compositionTimeStampFlag = 0;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :                         builder-&gt;sl_header.compositionTimeStamp = RTP_TS;</span>
<span class="lineNum">     169 </span>            :                 }
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :                 gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;sl_header.compositionTimeStampFlag, 1);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :                 nbBits += 1;</span>
<span class="lineNum">     172 </span>            :         }
<span class="lineNum">     173 </span>            :         /*CTS*/
<span class="lineNum">     174 </span><span class="lineCov">      20996 :         if (builder-&gt;sl_header.compositionTimeStampFlag) {</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :                 delta = (u32) builder-&gt;sl_header.compositionTimeStamp - RTP_TS;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :                 gf_bs_write_int(builder-&gt;pck_hdr, delta, builder-&gt;slMap.CTSDeltaLength);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                 nbBits += builder-&gt;slMap.CTSDeltaLength;</span>
<span class="lineNum">     178 </span>            :         }
<span class="lineNum">     179 </span>            :         /*DTS Flag*/
<span class="lineNum">     180 </span><span class="lineCov">      20996 :         if (builder-&gt;slMap.DTSDeltaLength) {</span>
<span class="lineNum">     181 </span><span class="lineCov">       3157 :                 gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;sl_header.decodingTimeStampFlag, 1);</span>
<span class="lineNum">     182 </span><span class="lineCov">       3157 :                 nbBits += 1;</span>
<span class="lineNum">     183 </span>            :         }
<span class="lineNum">     184 </span>            :         /*DTS*/
<span class="lineNum">     185 </span><span class="lineCov">      20996 :         if (builder-&gt;sl_header.decodingTimeStampFlag) {</span>
<span class="lineNum">     186 </span><span class="lineCov">       3157 :                 delta = (u32) (builder-&gt;sl_header.compositionTimeStamp - builder-&gt;sl_header.decodingTimeStamp);</span>
<span class="lineNum">     187 </span><span class="lineCov">       3157 :                 gf_bs_write_int(builder-&gt;pck_hdr, delta, builder-&gt;slMap.DTSDeltaLength);</span>
<span class="lineNum">     188 </span><span class="lineCov">       3157 :                 nbBits += builder-&gt;slMap.DTSDeltaLength;</span>
<span class="lineNum">     189 </span>            :         }
<span class="lineNum">     190 </span>            :         /*RAP indication*/
<span class="lineNum">     191 </span><span class="lineCov">      20996 :         if (builder-&gt;slMap.RandomAccessIndication) {</span>
<span class="lineNum">     192 </span><span class="lineCov">        956 :                 gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;sl_header.randomAccessPointFlag, 1);</span>
<span class="lineNum">     193 </span><span class="lineCov">        956 :                 nbBits ++;</span>
<span class="lineNum">     194 </span>            :         }
<span class="lineNum">     195 </span>            :         /*stream state - write AUSeqNum*/
<span class="lineNum">     196 </span><span class="lineCov">      20996 :         if (builder-&gt;slMap.StreamStateIndication) {</span>
<span class="lineNum">     197 </span><span class="lineCov">          5 :                 gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;sl_header.AU_sequenceNumber, builder-&gt;slMap.StreamStateIndication);</span>
<span class="lineNum">     198 </span><span class="lineCov">          5 :                 nbBits += builder-&gt;slMap.StreamStateIndication;</span>
<span class="lineNum">     199 </span>            :         }
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :         return nbBits;
<span class="lineNum">     202 </span>            : }
<a name="203"><span class="lineNum">     203 </span>            : </a>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineCov">      18214 : GF_Err gp_rtp_builder_do_mpeg4(GP_RTPPacketizer *builder, u8 *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)</span>
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span>            :         u8 *sl_buffer, *payl_buffer;
<span class="lineNum">     208 </span>            :         u32 sl_buffer_size, payl_buffer_size;
<span class="lineNum">     209 </span>            :         u32 auh_size_tmp, bytesLeftInPacket, infoSize, pckSize;
<span class="lineNum">     210 </span>            :         u64 pos;
<span class="lineNum">     211 </span>            :         u8 flush_pck, no_split;
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :         flush_pck = 0;
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :         bytesLeftInPacket = data_size;
<span class="lineNum">     216 </span>            :         /*flush everything*/
<span class="lineNum">     217 </span><span class="lineCov">      18214 :         if (!data) {</span>
<span class="lineNum">     218 </span><span class="lineCov">         45 :                 if (builder-&gt;payload) goto flush_packet;</span>
<span class="lineNum">     219 </span>            :                 return GF_OK;
<span class="lineNum">     220 </span>            :         }
<span class="lineNum">     221 </span><span class="lineCov">      18169 :         if (builder-&gt;payload &amp;&amp; builder-&gt;force_flush) goto flush_packet;</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :         //go till done
<span class="lineNum">     224 </span><span class="lineCov">      43377 :         while (bytesLeftInPacket) {</span>
<span class="lineNum">     225 </span>            :                 no_split = 0;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineCov">      25192 :                 if (builder-&gt;sl_header.accessUnitStartFlag) {</span>
<span class="lineNum">     228 </span>            :                         //init SL
<span class="lineNum">     229 </span><span class="lineCov">      22365 :                         if (builder-&gt;sl_header.compositionTimeStamp != builder-&gt;sl_header.decodingTimeStamp) {</span>
<span class="lineNum">     230 </span><span class="lineCov">        844 :                                 builder-&gt;sl_header.decodingTimeStampFlag = 1;</span>
<span class="lineNum">     231 </span>            :                         }
<span class="lineNum">     232 </span><span class="lineCov">      22365 :                         builder-&gt;sl_header.compositionTimeStampFlag = 1;</span>
<span class="lineNum">     233 </span><span class="lineCov">      22365 :                         builder-&gt;sl_header.accessUnitLength = FullAUSize;</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :                         //init some vars - based on the available size and the TS
<span class="lineNum">     236 </span>            :                         //we decide if we go with the same RTP TS serie or not
<span class="lineNum">     237 </span><span class="lineCov">      22365 :                         if (builder-&gt;payload) {</span>
<span class="lineNum">     238 </span>            :                                 //don't store more than what we can (that is 2^slMap-&gt;CTSDelta - 1)
<span class="lineNum">     239 </span><span class="lineCov">      10690 :                                 if ( (builder-&gt;flags &amp; GP_RTP_PCK_SIGNAL_TS)</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                                         &amp;&amp; (builder-&gt;sl_header.compositionTimeStamp - builder-&gt;rtp_header.TimeStamp &gt;= (u32) ( 1 &lt;&lt; builder-&gt;slMap.CTSDeltaLength) ) ) {</span>
<span class="lineNum">     241 </span>            :                                         goto flush_packet;
<span class="lineNum">     242 </span>            :                                 }
<span class="lineNum">     243 </span>            :                                 //don't split AU if # TS , start a new RTP pck
<span class="lineNum">     244 </span><span class="lineCov">      10690 :                                 if (builder-&gt;sl_header.compositionTimeStamp != builder-&gt;rtp_header.TimeStamp)</span>
<span class="lineNum">     245 </span>            :                                         no_split = 1;
<span class="lineNum">     246 </span>            :                         }
<span class="lineNum">     247 </span>            :                 }
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :                 /*new RTP Packet*/
<span class="lineNum">     250 </span><span class="lineCov">      25192 :                 if (!builder-&gt;payload) {</span>
<span class="lineNum">     251 </span>            :                         /*first SL in RTP*/
<span class="lineNum">     252 </span><span class="lineCov">      14502 :                         builder-&gt;first_sl_in_rtp = GF_TRUE;</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :                         /*if this is the end of an AU we will set it to 0 as soon as an AU is splitted*/
<span class="lineNum">     255 </span><span class="lineCov">      14502 :                         builder-&gt;rtp_header.Marker = 1;</span>
<span class="lineNum">     256 </span><span class="lineCov">      14502 :                         builder-&gt;rtp_header.PayloadType = builder-&gt;PayloadType;</span>
<span class="lineNum">     257 </span><span class="lineCov">      14502 :                         builder-&gt;rtp_header.SequenceNumber += 1;</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineCov">      14502 :                         builder-&gt;rtp_header.TimeStamp = (u32) builder-&gt;sl_header.compositionTimeStamp;</span>
<span class="lineNum">     260 </span>            :                         /*prepare the mapped headers*/
<span class="lineNum">     261 </span><span class="lineCov">      14502 :                         builder-&gt;pck_hdr = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);</span>
<span class="lineNum">     262 </span><span class="lineCov">      14502 :                         builder-&gt;payload = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);</span>
<span class="lineNum">     263 </span><span class="lineCov">      14502 :                         builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :                         /*in multiSL there is a MSLHSize structure on 2 bytes*/
<span class="lineNum">     266 </span><span class="lineCov">      14502 :                         builder-&gt;auh_size = 0;</span>
<span class="lineNum">     267 </span><span class="lineCov">      14502 :                         if (builder-&gt;has_AU_header) {</span>
<span class="lineNum">     268 </span><span class="lineCov">       8156 :                                 builder-&gt;auh_size = 16;</span>
<span class="lineNum">     269 </span><span class="lineCov">       8156 :                                 gf_bs_write_int(builder-&gt;pck_hdr, 0, 16);</span>
<span class="lineNum">     270 </span>            :                         }
<span class="lineNum">     271 </span>            :                         flush_pck = 0;
<span class="lineNum">     272 </span>            :                         /*and create packet*/
<span class="lineNum">     273 </span><span class="lineCov">      14502 :                         builder-&gt;OnNewPacket(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     274 </span>            :                 }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :                 //make sure we are not interleaving too much - this should never happen actually
<span class="lineNum">     277 </span><span class="lineCov">      25192 :                 if (builder-&gt;slMap.IndexDeltaLength</span>
<span class="lineNum">     278 </span><span class="lineCov">      14908 :                         &amp;&amp; !builder-&gt;first_sl_in_rtp</span>
<span class="lineNum">     279 </span><span class="lineCov">      10690 :                         &amp;&amp; (builder-&gt;sl_header.AU_sequenceNumber - builder-&gt;last_au_sn &gt;= (u32) 1&lt;&lt;builder-&gt;slMap.IndexDeltaLength)) {</span>
<span class="lineNum">     280 </span>            :                         //we cannot write this packet here
<span class="lineNum">     281 </span>            :                         goto flush_packet;
<span class="lineNum">     282 </span>            :                 }
<span class="lineNum">     283 </span>            :                 /*check max ptime*/
<span class="lineNum">     284 </span><span class="lineCov">      25192 :                 if (builder-&gt;max_ptime &amp;&amp; ( (u32) builder-&gt;sl_header.compositionTimeStamp &gt;= builder-&gt;rtp_header.TimeStamp + builder-&gt;max_ptime) )</span>
<span class="lineNum">     285 </span>            :                         goto flush_packet;
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineCov">      25192 :                 auh_size_tmp = gf_rtp_build_au_hdr_size(builder, &amp;builder-&gt;sl_header);</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineCov">      25192 :                 infoSize = auh_size_tmp + builder-&gt;auh_size;</span>
<span class="lineNum">     290 </span><span class="lineCov">      25192 :                 infoSize /= 8;</span>
<span class="lineNum">     291 </span>            :                 /*align*/
<span class="lineNum">     292 </span><span class="lineCov">      25192 :                 if ( (builder-&gt;auh_size + auh_size_tmp) % 8) infoSize += 1;</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineCov">      25192 :                 if (bytesLeftInPacket + infoSize + builder-&gt;bytesInPacket &lt;= builder-&gt;Path_MTU) {</span>
<span class="lineNum">     296 </span>            :                         //End of our data chunk
<span class="lineNum">     297 </span>            :                         pckSize = bytesLeftInPacket;
<span class="lineNum">     298 </span><span class="lineCov">      18169 :                         builder-&gt;sl_header.accessUnitEndFlag = IsAUEnd;</span>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineCov">      18169 :                         builder-&gt;auh_size += auh_size_tmp;</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineCov">      18169 :                         builder-&gt;sl_header.paddingFlag = builder-&gt;sl_header.paddingBits ? 1 : 0;</span>
<span class="lineNum">     303 </span>            :                 } else {
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :                         //AU cannot fit in packet. If no split, start a new packet
<span class="lineNum">     306 </span><span class="lineCov">       7023 :                         if (no_split) goto flush_packet;</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">       2827 :                         builder-&gt;auh_size += auh_size_tmp;</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineCov">       2827 :                         pckSize = builder-&gt;Path_MTU - (infoSize + builder-&gt;bytesInPacket);</span>
<span class="lineNum">     311 </span>            :                         //that's the end of the rtp packet
<span class="lineNum">     312 </span>            :                         flush_pck = 1;
<span class="lineNum">     313 </span>            :                         //but not of the AU -&gt; marker is 0
<span class="lineNum">     314 </span><span class="lineCov">       2827 :                         builder-&gt;rtp_header.Marker = 0;</span>
<span class="lineNum">     315 </span>            :                 }
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineCov">      20996 :                 gf_rtp_build_au_hdr_write(builder, pckSize, builder-&gt;rtp_header.TimeStamp);</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :                 //notify the user of our data structure
<span class="lineNum">     320 </span><span class="lineCov">      20996 :                 if (builder-&gt;OnDataReference)</span>
<span class="lineNum">     321 </span><span class="lineCov">      20498 :                         builder-&gt;OnDataReference(builder-&gt;cbk_obj, pckSize, data_size - bytesLeftInPacket);</span>
<span class="lineNum">     322 </span>            :                 else
<span class="lineNum">     323 </span><span class="lineCov">        498 :                         gf_bs_write_data(builder-&gt;payload, data + (data_size - bytesLeftInPacket), pckSize);</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineCov">      20996 :                 bytesLeftInPacket -= pckSize;</span>
<span class="lineNum">     327 </span><span class="lineCov">      20996 :                 builder-&gt;bytesInPacket += pckSize;</span>
<span class="lineNum">     328 </span>            :                 /*update IV*/
<span class="lineNum">     329 </span><span class="lineCov">      20996 :                 builder-&gt;IV += pckSize;</span>
<span class="lineNum">     330 </span><span class="lineCov">      20996 :                 builder-&gt;sl_header.paddingFlag = 0;</span>
<span class="lineNum">     331 </span><span class="lineCov">      20996 :                 builder-&gt;sl_header.accessUnitStartFlag = 0;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :                 //we are splitting a payload, auto increment SL seq num
<span class="lineNum">     334 </span><span class="lineCov">      20996 :                 if (bytesLeftInPacket) {</span>
<span class="lineNum">     335 </span><span class="lineCov">       2827 :                         builder-&gt;sl_header.packetSequenceNumber += 1;</span>
<span class="lineNum">     336 </span><span class="lineCov">      18169 :                 } else if (! (builder-&gt;flags &amp; GP_RTP_PCK_USE_MULTI) ) {</span>
<span class="lineNum">     337 </span><span class="lineCov">       7458 :                         builder-&gt;rtp_header.Marker = 1;</span>
<span class="lineNum">     338 </span>            :                         flush_pck = 1;
<span class="lineNum">     339 </span>            :                 }
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :                 //first SL in RTP is done
<span class="lineNum">     342 </span><span class="lineCov">      20996 :                 builder-&gt;first_sl_in_rtp = GF_FALSE;</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :                 //store current sl
<span class="lineNum">     345 </span><span class="lineCov">      20996 :                 builder-&gt;last_au_sn = builder-&gt;sl_header.AU_sequenceNumber;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineCov">      31707 :                 if (!flush_pck) continue;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :                 //done with the packet
<span class="lineNum">     350 </span><span class="lineCov">      14497 : flush_packet:</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">      14497 :                 gf_bs_align(builder-&gt;pck_hdr);</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :                 /*no aux data yet*/
<span class="lineNum">     355 </span><span class="lineCov">      14497 :                 if (builder-&gt;slMap.AuxiliaryDataSizeLength)  {</span>
<span class="lineNum">     356 </span>            :                         //write RSLH after the MSLH
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                         gf_bs_write_int(builder-&gt;pck_hdr, 0, builder-&gt;slMap.AuxiliaryDataSizeLength);</span>
<span class="lineNum">     358 </span>            :                 }
<span class="lineNum">     359 </span>            :                 /*rewrite the size header*/
<span class="lineNum">     360 </span><span class="lineCov">      14497 :                 if (builder-&gt;has_AU_header) {</span>
<span class="lineNum">     361 </span><span class="lineCov">       8151 :                         pos = gf_bs_get_position(builder-&gt;pck_hdr);</span>
<span class="lineNum">     362 </span><span class="lineCov">       8151 :                         gf_bs_seek(builder-&gt;pck_hdr, 0);</span>
<span class="lineNum">     363 </span><span class="lineCov">       8151 :                         builder-&gt;auh_size -= 16;</span>
<span class="lineNum">     364 </span><span class="lineCov">       8151 :                         gf_bs_write_int(builder-&gt;pck_hdr, builder-&gt;auh_size, 16);</span>
<span class="lineNum">     365 </span><span class="lineCov">       8151 :                         gf_bs_seek(builder-&gt;pck_hdr, pos);</span>
<span class="lineNum">     366 </span>            :                 }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">      14497 :                 sl_buffer = NULL;</span>
<span class="lineNum">     369 </span><span class="lineCov">      14497 :                 gf_bs_get_content(builder-&gt;pck_hdr, &amp;sl_buffer, &amp;sl_buffer_size);</span>
<span class="lineNum">     370 </span>            :                 //delete our bitstream
<span class="lineNum">     371 </span><span class="lineCov">      14497 :                 gf_bs_del(builder-&gt;pck_hdr);</span>
<span class="lineNum">     372 </span><span class="lineCov">      14497 :                 builder-&gt;pck_hdr = NULL;</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineCov">      14497 :                 payl_buffer = NULL;</span>
<span class="lineNum">     375 </span><span class="lineCov">      14497 :                 payl_buffer_size = 0;</span>
<span class="lineNum">     376 </span><span class="lineCov">      14497 :                 if (!builder-&gt;OnDataReference)</span>
<span class="lineNum">     377 </span><span class="lineCov">        130 :                         gf_bs_get_content(builder-&gt;payload, &amp;payl_buffer, &amp;payl_buffer_size);</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">      14497 :                 gf_bs_del(builder-&gt;payload);</span>
<span class="lineNum">     380 </span><span class="lineCov">      14497 :                 builder-&gt;payload = NULL;</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :                 /*notify header*/
<span class="lineNum">     383 </span><span class="lineCov">      14497 :                 builder-&gt;OnData(builder-&gt;cbk_obj, sl_buffer, sl_buffer_size, GF_TRUE);</span>
<span class="lineNum">     384 </span>            :                 /*notify payload*/
<span class="lineNum">     385 </span><span class="lineCov">      14497 :                 if (payl_buffer) {</span>
<span class="lineNum">     386 </span><span class="lineCov">        130 :                         builder-&gt;OnData(builder-&gt;cbk_obj, payl_buffer, payl_buffer_size, GF_FALSE);</span>
<span class="lineNum">     387 </span><span class="lineCov">        130 :                         gf_free(payl_buffer);</span>
<span class="lineNum">     388 </span>            :                 }
<span class="lineNum">     389 </span>            :                 /*flush packet*/
<span class="lineNum">     390 </span><span class="lineCov">      14497 :                 builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     391 </span><span class="lineCov">      14497 :                 gf_free(sl_buffer);</span>
<span class="lineNum">     392 </span>            :         }
<span class="lineNum">     393 </span>            :         //packet is done, update AU markers
<span class="lineNum">     394 </span><span class="lineCov">      18185 :         if (IsAUEnd) {</span>
<span class="lineNum">     395 </span><span class="lineCov">      18185 :                 builder-&gt;sl_header.accessUnitStartFlag = 1;</span>
<span class="lineNum">     396 </span><span class="lineCov">      18185 :                 builder-&gt;sl_header.accessUnitEndFlag = 0;</span>
<span class="lineNum">     397 </span>            :         }
<span class="lineNum">     398 </span>            :         return GF_OK;
<span class="lineNum">     399 </span>            : }
<a name="400"><span class="lineNum">     400 </span>            : </a>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineCov">       3721 : GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)</span>
<span class="lineNum">     403 </span>            : {
<span class="lineNum">     404 </span>            :         u32 do_flush, bytesLeft, size, nal_type;
<span class="lineNum">     405 </span>            :         char shdr[2];
<span class="lineNum">     406 </span>            :         char stap_hdr;
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :         do_flush = 0;
<span class="lineNum">     409 </span><span class="lineCov">       3721 :         if (!nalu) do_flush = 1;</span>
<span class="lineNum">     410 </span>            :         /*we only do STAP or SINGLE modes*/
<span class="lineNum">     411 </span><span class="lineCov">       3705 :         else if (builder-&gt;sl_header.accessUnitStartFlag) do_flush = 1;</span>
<span class="lineNum">     412 </span>            :         /*we must NOT fragment a NALU*/
<span class="lineNum">     413 </span><span class="lineCov">       1529 :         else if (builder-&gt;bytesInPacket + nalu_size &gt;= builder-&gt;Path_MTU) do_flush = 2;</span>
<span class="lineNum">     414 </span>            :         /*aggregation is disabled*/
<span class="lineNum">     415 </span><span class="lineCov">        722 :         else if (! (builder-&gt;flags &amp; GP_RTP_PCK_USE_MULTI) ) do_flush = 2;</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineCov">       3721 :         if (builder-&gt;bytesInPacket &amp;&amp; do_flush) {</span>
<span class="lineNum">     418 </span><span class="lineCov">       1228 :                 builder-&gt;rtp_header.Marker = (do_flush==1) ? 1 : 0;</span>
<span class="lineNum">     419 </span><span class="lineCov">       1228 :                 builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     420 </span><span class="lineCov">       1228 :                 builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     421 </span>            :         }
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineCov">       3721 :         if (!nalu) return GF_OK;</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :         /*need a new RTP packet*/
<span class="lineNum">     426 </span><span class="lineCov">       3705 :         if (!builder-&gt;bytesInPacket) {</span>
<span class="lineNum">     427 </span><span class="lineCov">       3705 :                 builder-&gt;rtp_header.PayloadType = builder-&gt;PayloadType;</span>
<span class="lineNum">     428 </span><span class="lineCov">       3705 :                 builder-&gt;rtp_header.Marker = 0;</span>
<span class="lineNum">     429 </span><span class="lineCov">       3705 :                 builder-&gt;rtp_header.TimeStamp = (u32) builder-&gt;sl_header.compositionTimeStamp;</span>
<span class="lineNum">     430 </span><span class="lineCov">       3705 :                 builder-&gt;rtp_header.SequenceNumber += 1;</span>
<span class="lineNum">     431 </span><span class="lineCov">       3705 :                 builder-&gt;OnNewPacket(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     432 </span><span class="lineCov">       3705 :                 builder-&gt;avc_non_idr = GF_TRUE;</span>
<span class="lineNum">     433 </span>            :         }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            :         /*check NAL type to see if disposable or not*/
<span class="lineNum">     436 </span><span class="lineCov">       3705 :         nal_type = nalu[0] &amp; 0x1F;</span>
<span class="lineNum">     437 </span>            :         switch (nal_type) {
<span class="lineNum">     438 </span>            :         case GF_AVC_NALU_NON_IDR_SLICE:
<span class="lineNum">     439 </span>            :         case GF_AVC_NALU_ACCESS_UNIT:
<span class="lineNum">     440 </span>            :         case GF_AVC_NALU_END_OF_SEQ:
<span class="lineNum">     441 </span>            :         case GF_AVC_NALU_END_OF_STREAM:
<span class="lineNum">     442 </span>            :         case GF_AVC_NALU_FILLER_DATA:
<span class="lineNum">     443 </span>            :                 break;
<span class="lineNum">     444 </span><span class="lineCov">       1579 :         default:</span>
<span class="lineNum">     445 </span><span class="lineCov">       1579 :                 builder-&gt;avc_non_idr = GF_FALSE;</span>
<span class="lineNum">     446 </span><span class="lineCov">       1579 :                 break;</span>
<span class="lineNum">     447 </span>            :         }
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :         /*at this point we're sure the NALU fits in current packet OR must be splitted*/
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :         /*pb: we don't know if next NALU from this AU will be small enough to fit in the packet, so we always
<span class="lineNum">     452 </span>            :         go for stap...*/
<span class="lineNum">     453 </span><span class="lineCov">       3705 :         if (builder-&gt;bytesInPacket+nalu_size&lt;builder-&gt;Path_MTU) {</span>
<span class="lineNum">     454 </span>            :                 Bool use_stap = GF_TRUE;
<span class="lineNum">     455 </span>            :                 /*if this is the AU end and no NALU in packet, go for single mode*/
<span class="lineNum">     456 </span><span class="lineCov">       2678 :                 if (IsAUEnd &amp;&amp; !builder-&gt;bytesInPacket) use_stap = GF_FALSE;</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :                 if (use_stap) {
<span class="lineNum">     459 </span>            :                         /*declare STAP-A NAL*/
<span class="lineNum">     460 </span><span class="lineCov">       1228 :                         if (!builder-&gt;bytesInPacket) {</span>
<span class="lineNum">     461 </span>            :                                 /*copy over F and NRI from first nal in packet and assign type*/
<span class="lineNum">     462 </span><span class="lineCov">       1228 :                                 stap_hdr = (nalu[0] &amp; 0xE0) | 24;</span>
<span class="lineNum">     463 </span><span class="lineCov">       1228 :                                 builder-&gt;OnData(builder-&gt;cbk_obj, (char *) &amp;stap_hdr, 1, GF_FALSE);</span>
<span class="lineNum">     464 </span><span class="lineCov">       1228 :                                 builder-&gt;bytesInPacket = 1;</span>
<span class="lineNum">     465 </span>            :                         }
<span class="lineNum">     466 </span>            :                         /*add NALU size*/
<span class="lineNum">     467 </span><span class="lineCov">       1228 :                         shdr[0] = nalu_size&gt;&gt;8;</span>
<span class="lineNum">     468 </span><span class="lineCov">       1228 :                         shdr[1] = nalu_size&amp;0x00ff;</span>
<span class="lineNum">     469 </span><span class="lineCov">       1228 :                         builder-&gt;OnData(builder-&gt;cbk_obj, (char *)shdr, 2, GF_FALSE);</span>
<span class="lineNum">     470 </span><span class="lineCov">       1228 :                         builder-&gt;bytesInPacket += 2;</span>
<span class="lineNum">     471 </span>            :                 }
<span class="lineNum">     472 </span>            :                 /*add data*/
<span class="lineNum">     473 </span><span class="lineCov">       2678 :                 if (builder-&gt;OnDataReference)</span>
<span class="lineNum">     474 </span><span class="lineCov">       2561 :                         builder-&gt;OnDataReference(builder-&gt;cbk_obj, nalu_size, 0);</span>
<span class="lineNum">     475 </span>            :                 else
<span class="lineNum">     476 </span><span class="lineCov">        117 :                         builder-&gt;OnData(builder-&gt;cbk_obj, nalu, nalu_size, GF_FALSE);</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">       2678 :                 builder-&gt;bytesInPacket += nalu_size;</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineCov">       2678 :                 if (IsAUEnd) {</span>
<span class="lineNum">     481 </span><span class="lineCov">       1450 :                         builder-&gt;rtp_header.Marker = 1;</span>
<span class="lineNum">     482 </span><span class="lineCov">       1450 :                         builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     483 </span><span class="lineCov">       1450 :                         builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     484 </span>            :                 }
<span class="lineNum">     485 </span>            :         }
<span class="lineNum">     486 </span>            :         /*fragmentation unit*/
<span class="lineNum">     487 </span>            :         else {
<span class="lineNum">     488 </span>            :                 u32 offset;
<span class="lineNum">     489 </span>            :                 assert(nalu_size&gt;=builder-&gt;Path_MTU);
<span class="lineNum">     490 </span>            :                 assert(!builder-&gt;bytesInPacket);
<span class="lineNum">     491 </span>            :                 /*FU payload doesn't have the NAL hdr*/
<span class="lineNum">     492 </span><span class="lineCov">       1027 :                 bytesLeft = nalu_size - 1;</span>
<span class="lineNum">     493 </span>            :                 offset = 1;
<span class="lineNum">     494 </span><span class="lineCov">       4583 :                 while (bytesLeft) {</span>
<span class="lineNum">     495 </span><span class="lineCov">       2529 :                         if (2 + bytesLeft &gt; builder-&gt;Path_MTU) {</span>
<span class="lineNum">     496 </span><span class="lineCov">       1502 :                                 size = builder-&gt;Path_MTU - 2;</span>
<span class="lineNum">     497 </span>            :                         } else {
<span class="lineNum">     498 </span>            :                                 size = bytesLeft;
<span class="lineNum">     499 </span>            :                         }
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :                         /*copy over F and NRI from nal in packet and assign type*/
<span class="lineNum">     502 </span><span class="lineCov">       2529 :                         shdr[0] = (nalu[0] &amp; 0xE0) | 28;</span>
<span class="lineNum">     503 </span>            :                         /*copy over NAL type from nal and set start bit and end bit*/
<span class="lineNum">     504 </span><span class="lineCov">       2529 :                         shdr[1] = (nalu[0] &amp; 0x1F);</span>
<span class="lineNum">     505 </span>            :                         /*start bit*/
<span class="lineNum">     506 </span><span class="lineCov">       2529 :                         if (offset==1) shdr[1] |= 0x80;</span>
<span class="lineNum">     507 </span>            :                         /*end bit*/
<span class="lineNum">     508 </span><span class="lineCov">       1502 :                         else if (size == bytesLeft) shdr[1] |= 0x40;</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineCov">       2529 :                         builder-&gt;OnData(builder-&gt;cbk_obj, (char *)shdr, 2, GF_FALSE);</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :                         /*add data*/
<span class="lineNum">     513 </span><span class="lineCov">       2529 :                         if (builder-&gt;OnDataReference)</span>
<span class="lineNum">     514 </span><span class="lineCov">       2477 :                                 builder-&gt;OnDataReference(builder-&gt;cbk_obj, size, offset);</span>
<span class="lineNum">     515 </span>            :                         else
<span class="lineNum">     516 </span><span class="lineCov">         52 :                                 builder-&gt;OnData(builder-&gt;cbk_obj, nalu+offset, size, GF_FALSE);</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineCov">       2529 :                         offset += size;</span>
<span class="lineNum">     519 </span><span class="lineCov">       2529 :                         bytesLeft -= size;</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :                         /*flush no matter what (FUs cannot be agreggated)*/
<span class="lineNum">     522 </span><span class="lineCov">       2529 :                         builder-&gt;rtp_header.Marker = (IsAUEnd &amp;&amp; !bytesLeft) ? 1 : 0;</span>
<span class="lineNum">     523 </span><span class="lineCov">       2529 :                         builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     524 </span><span class="lineCov">       2529 :                         builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">       2529 :                         if (bytesLeft) {</span>
<span class="lineNum">     527 </span><span class="lineCov">       1502 :                                 builder-&gt;rtp_header.PayloadType = builder-&gt;PayloadType;</span>
<span class="lineNum">     528 </span><span class="lineCov">       1502 :                                 builder-&gt;rtp_header.TimeStamp = (u32) builder-&gt;sl_header.compositionTimeStamp;</span>
<span class="lineNum">     529 </span><span class="lineCov">       1502 :                                 builder-&gt;rtp_header.SequenceNumber += 1;</span>
<span class="lineNum">     530 </span><span class="lineCov">       1502 :                                 builder-&gt;OnNewPacket(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     531 </span>            :                         }
<span class="lineNum">     532 </span>            :                 }
<span class="lineNum">     533 </span>            :         }
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :         return GF_OK;
<a name="536"><span class="lineNum">     536 </span>            : }</a>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">       2786 : GF_Err gp_rtp_builder_do_hevc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)</span>
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span>            :         u32 do_flush, bytesLeft, size;
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            :         do_flush = 0;
<span class="lineNum">     543 </span><span class="lineCov">       2786 :         if (!nalu) do_flush = 1;</span>
<span class="lineNum">     544 </span><span class="lineCov">       2783 :         else if (builder-&gt;sl_header.accessUnitStartFlag) do_flush = 1;</span>
<span class="lineNum">     545 </span>            :         /*we must NOT fragment a NALU*/
<span class="lineNum">     546 </span><span class="lineCov">       2504 :         else if (builder-&gt;bytesInPacket + nalu_size + 4 &gt;= builder-&gt;Path_MTU) do_flush = 2; //2 bytes PayloadHdr for AP + 2 bytes NAL size</span>
<span class="lineNum">     547 </span>            :         /*aggregation is disabled*/
<span class="lineNum">     548 </span><span class="lineCov">       2199 :         else if (! (builder-&gt;flags &amp; GP_RTP_PCK_USE_MULTI) ) do_flush = 2;</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineCov">       2786 :         if (builder-&gt;bytesInPacket &amp;&amp; do_flush) {</span>
<span class="lineNum">     551 </span><span class="lineCov">        539 :                 builder-&gt;rtp_header.Marker = (do_flush==1) ? 1 : 0;</span>
<span class="lineNum">     552 </span>            :                 /*insert payload_hdr in case of AP*/
<span class="lineNum">     553 </span><span class="lineCov">        539 :                 if (strlen(builder-&gt;hevc_payload_hdr)) {</span>
<span class="lineNum">     554 </span><span class="lineCov">        299 :                         builder-&gt;OnData(builder-&gt;cbk_obj, (char *)builder-&gt;hevc_payload_hdr, 2, GF_TRUE);</span>
<span class="lineNum">     555 </span>            :                         memset(builder-&gt;hevc_payload_hdr, 0, 2);
<span class="lineNum">     556 </span>            :                 }
<span class="lineNum">     557 </span><span class="lineCov">        539 :                 builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     558 </span><span class="lineCov">        539 :                 builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     559 </span>            :         }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineCov">       2786 :         if (!nalu) return GF_OK;</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            :         /*need a new RTP packet*/
<span class="lineNum">     564 </span><span class="lineCov">       2783 :         if (!builder-&gt;bytesInPacket) {</span>
<span class="lineNum">     565 </span><span class="lineCov">        845 :                 builder-&gt;rtp_header.PayloadType = builder-&gt;PayloadType;</span>
<span class="lineNum">     566 </span><span class="lineCov">        845 :                 builder-&gt;rtp_header.TimeStamp = (u32) builder-&gt;sl_header.compositionTimeStamp;</span>
<span class="lineNum">     567 </span><span class="lineCov">        845 :                 builder-&gt;rtp_header.SequenceNumber += 1;</span>
<span class="lineNum">     568 </span><span class="lineCov">        845 :                 builder-&gt;OnNewPacket(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     569 </span>            :         }
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :         /*at this point we're sure the NALU fits in current packet OR must be splitted*/
<span class="lineNum">     572 </span>            :         /*check that we should use single NALU packet mode or aggreation packets mode*/
<span class="lineNum">     573 </span><span class="lineCov">       2783 :         if (builder-&gt;bytesInPacket+nalu_size+4 &lt; builder-&gt;Path_MTU) {</span>
<span class="lineNum">     574 </span><span class="lineCov">       2756 :                 Bool use_AP = (builder-&gt;flags &amp; GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE;</span>
<span class="lineNum">     575 </span>            :                 /*if this is the AU end and no NALU in packet, go for single NALU packet mode*/
<span class="lineNum">     576 </span><span class="lineCov">       2756 :                 if (IsAUEnd &amp;&amp; !builder-&gt;bytesInPacket) use_AP = GF_FALSE;</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">       2727 :                 if (use_AP) {</span>
<span class="lineNum">     579 </span>            :                         char nal_s[2];
<span class="lineNum">     580 </span>            :                         /*declare PayloadHdr for AP*/
<span class="lineNum">     581 </span><span class="lineCov">       2487 :                         if (!builder-&gt;bytesInPacket) {</span>
<span class="lineNum">     582 </span>            :                                 /*copy F bit and assign type*/
<span class="lineNum">     583 </span><span class="lineCov">        549 :                                 builder-&gt;hevc_payload_hdr[0] = (nalu[0] &amp; 0x81) | (48 &lt;&lt; 1);</span>
<span class="lineNum">     584 </span>            :                                 /*copy LayerId and TID*/
<span class="lineNum">     585 </span><span class="lineCov">        549 :                                 builder-&gt;hevc_payload_hdr[1] = nalu[1];</span>
<span class="lineNum">     586 </span>            :                         }
<span class="lineNum">     587 </span>            :                         else {
<span class="lineNum">     588 </span>            :                                 /*F bit of AP is 0 if the F nit of each aggreated NALU is 0; otherwise its must be 1*/
<span class="lineNum">     589 </span>            :                                 /*LayerId and TID must ne the lowest value of LayerId and TID of all aggreated NALU*/
<span class="lineNum">     590 </span>            :                                 u8 cur_LayerId, cur_TID, new_LayerId, new_TID;
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineCov">       1938 :                                 builder-&gt;hevc_payload_hdr[0] |= (nalu[0] &amp; 0x80);</span>
<span class="lineNum">     593 </span><span class="lineCov">       1938 :                                 cur_LayerId = ((builder-&gt;hevc_payload_hdr[0] &amp; 0x01) &lt;&lt; 5) + ((builder-&gt;hevc_payload_hdr[1] &amp; 0xF8) &gt;&gt; 3);</span>
<span class="lineNum">     594 </span><span class="lineCov">       1938 :                                 new_LayerId = ((nalu[0] &amp; 0x01) &lt;&lt; 5) + ((nalu[1] &amp; 0xF8) &gt;&gt; 3);</span>
<span class="lineNum">     595 </span><span class="lineCov">       1938 :                                 if (cur_LayerId &gt; new_LayerId) {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :                                         builder-&gt;hevc_payload_hdr[0] = (builder-&gt;hevc_payload_hdr[0] &amp; 0xFE) | (nalu[0] &amp; 0x01);</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :                                         builder-&gt;hevc_payload_hdr[1] = (builder-&gt;hevc_payload_hdr[1] &amp; 0x07) | (nalu[1] &amp; 0xF8);</span>
<span class="lineNum">     598 </span>            :                                 }
<span class="lineNum">     599 </span><span class="lineCov">       1938 :                                 cur_TID = builder-&gt;hevc_payload_hdr[1] &amp; 0x07;</span>
<span class="lineNum">     600 </span><span class="lineCov">       1938 :                                 new_TID = nalu[1] &amp; 0x07;</span>
<span class="lineNum">     601 </span><span class="lineCov">       1938 :                                 if (cur_TID &gt; new_TID) {</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                                         builder-&gt;hevc_payload_hdr[1] = (builder-&gt;hevc_payload_hdr[1] &amp; 0xF8) | (nalu[1] &amp; 0x07);</span>
<span class="lineNum">     603 </span>            :                                 }
<span class="lineNum">     604 </span>            :                         }
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :                         /*add NALU size*/
<span class="lineNum">     607 </span><span class="lineCov">       2487 :                         nal_s[0] = nalu_size&gt;&gt;8;</span>
<span class="lineNum">     608 </span><span class="lineCov">       2487 :                         nal_s[1] = nalu_size&amp;0x00ff;</span>
<span class="lineNum">     609 </span><span class="lineCov">       2487 :                         builder-&gt;OnData(builder-&gt;cbk_obj, (char *)nal_s, 2, GF_FALSE);</span>
<span class="lineNum">     610 </span><span class="lineCov">       2487 :                         builder-&gt;bytesInPacket += 2;</span>
<span class="lineNum">     611 </span>            :                 }
<span class="lineNum">     612 </span>            :                 /*add data*/
<span class="lineNum">     613 </span><span class="lineCov">       2756 :                 if (builder-&gt;OnDataReference)</span>
<span class="lineNum">     614 </span><span class="lineCov">       2489 :                         builder-&gt;OnDataReference(builder-&gt;cbk_obj, nalu_size, 0);</span>
<span class="lineNum">     615 </span>            :                 else
<span class="lineNum">     616 </span><span class="lineCov">        267 :                         builder-&gt;OnData(builder-&gt;cbk_obj, nalu, nalu_size, GF_FALSE);</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">       2756 :                 builder-&gt;bytesInPacket += nalu_size;</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">       2756 :                 if (IsAUEnd) {</span>
<span class="lineNum">     621 </span><span class="lineCov">        279 :                         builder-&gt;rtp_header.Marker = 1;</span>
<span class="lineNum">     622 </span><span class="lineCov">        279 :                         if (strlen(builder-&gt;hevc_payload_hdr)) {</span>
<span class="lineNum">     623 </span><span class="lineCov">        250 :                                 builder-&gt;OnData(builder-&gt;cbk_obj, (char *)builder-&gt;hevc_payload_hdr, 2, GF_TRUE);</span>
<span class="lineNum">     624 </span>            :                                 memset(builder-&gt;hevc_payload_hdr, 0, 2);
<span class="lineNum">     625 </span>            :                         }
<span class="lineNum">     626 </span><span class="lineCov">        279 :                         builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     627 </span><span class="lineCov">        279 :                         builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     628 </span>            :                 }
<span class="lineNum">     629 </span>            :         }
<span class="lineNum">     630 </span>            :         /*fragmentation unit*/
<span class="lineNum">     631 </span>            :         else {
<span class="lineNum">     632 </span>            :                 u32 offset;
<span class="lineNum">     633 </span>            :                 char payload_hdr[2];
<span class="lineNum">     634 </span>            :                 char shdr;
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :                 assert(nalu_size + 4 &gt;=builder-&gt;Path_MTU);
<span class="lineNum">     637 </span>            :                 assert(!builder-&gt;bytesInPacket);
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :                 /*FU payload doesn't have the NAL hdr (2 bytes*/
<span class="lineNum">     640 </span><span class="lineCov">         27 :                 bytesLeft = nalu_size - 2;</span>
<span class="lineNum">     641 </span>            :                 offset = 2;
<span class="lineNum">     642 </span><span class="lineCov">        158 :                 while (bytesLeft) {</span>
<span class="lineNum">     643 </span><span class="lineCov">        104 :                         if (3 + bytesLeft &gt; builder-&gt;Path_MTU) {</span>
<span class="lineNum">     644 </span><span class="lineCov">         77 :                                 size = builder-&gt;Path_MTU - 3;</span>
<span class="lineNum">     645 </span>            :                         } else {
<span class="lineNum">     646 </span>            :                                 size = bytesLeft;
<span class="lineNum">     647 </span>            :                         }
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            :                         /*declare PayloadHdr for FU*/
<span class="lineNum">     650 </span>            :                         memset(payload_hdr, 0, 2);
<span class="lineNum">     651 </span>            :                         /*copy F bit and assign type*/
<span class="lineNum">     652 </span><span class="lineCov">        104 :                         payload_hdr[0] = (nalu[0] &amp; 0x81) | (49 &lt;&lt; 1);</span>
<span class="lineNum">     653 </span>            :                         /*copy LayerId and TID*/
<span class="lineNum">     654 </span><span class="lineCov">        104 :                         payload_hdr[1] = nalu[1];</span>
<span class="lineNum">     655 </span><span class="lineCov">        104 :                         builder-&gt;OnData(builder-&gt;cbk_obj, (char *)payload_hdr, 2, GF_FALSE);</span>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            :                         /*declare FU header*/
<span class="lineNum">     658 </span>            :                         shdr = 0;
<span class="lineNum">     659 </span>            :                         /*assign type*/
<span class="lineNum">     660 </span><span class="lineCov">        104 :                         shdr |= (nalu[0] &amp; 0x7E) &gt;&gt; 1;</span>
<span class="lineNum">     661 </span>            :                         /*start bit*/
<span class="lineNum">     662 </span><span class="lineCov">        104 :                         if (offset==2) shdr |= 0x80;</span>
<span class="lineNum">     663 </span>            :                         /*end bit*/
<span class="lineNum">     664 </span><span class="lineCov">         77 :                         else if (size == bytesLeft) shdr |= 0x40;</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span><span class="lineCov">        104 :                         builder-&gt;OnData(builder-&gt;cbk_obj, &amp;shdr, 1, GF_FALSE);</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :                         /*add data*/
<span class="lineNum">     669 </span><span class="lineCov">        104 :                         if (builder-&gt;OnDataReference)</span>
<span class="lineNum">     670 </span><span class="lineCov">         90 :                                 builder-&gt;OnDataReference(builder-&gt;cbk_obj, size, offset);</span>
<span class="lineNum">     671 </span>            :                         else
<span class="lineNum">     672 </span><span class="lineCov">         14 :                                 builder-&gt;OnData(builder-&gt;cbk_obj, nalu+offset, size, GF_FALSE);</span>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineCov">        104 :                         offset += size;</span>
<span class="lineNum">     675 </span><span class="lineCov">        104 :                         bytesLeft -= size;</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            :                         /*flush no matter what (FUs cannot be agreggated)*/
<span class="lineNum">     678 </span><span class="lineCov">        104 :                         builder-&gt;rtp_header.Marker = (IsAUEnd &amp;&amp; !bytesLeft) ? 1 : 0;</span>
<span class="lineNum">     679 </span><span class="lineCov">        104 :                         builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     680 </span><span class="lineCov">        104 :                         builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineCov">        104 :                         if (bytesLeft) {</span>
<span class="lineNum">     683 </span><span class="lineCov">         77 :                                 builder-&gt;rtp_header.PayloadType = builder-&gt;PayloadType;</span>
<span class="lineNum">     684 </span><span class="lineCov">         77 :                                 builder-&gt;rtp_header.TimeStamp = (u32) builder-&gt;sl_header.compositionTimeStamp;</span>
<span class="lineNum">     685 </span><span class="lineCov">         77 :                                 builder-&gt;rtp_header.SequenceNumber += 1;</span>
<span class="lineNum">     686 </span><span class="lineCov">         77 :                                 builder-&gt;OnNewPacket(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     687 </span>            :                         }
<span class="lineNum">     688 </span>            :                 }
<span class="lineNum">     689 </span>            :         }
<span class="lineNum">     690 </span>            :         return GF_OK;
<a name="691"><span class="lineNum">     691 </span>            : }</a>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineNoCov">          0 : void latm_flush(GP_RTPPacketizer *builder)</span>
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span><span class="lineCov">         10 :         if (builder-&gt;bytesInPacket) {</span>
<span class="lineNum">     696 </span><span class="lineCov">          9 :                 builder-&gt;OnPacketDone(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     697 </span><span class="lineCov">          9 :                 builder-&gt;bytesInPacket = 0;</span>
<span class="lineNum">     698 </span>            :         }
<span class="lineNum">     699 </span><span class="lineCov">         10 :         builder-&gt;rtp_header.TimeStamp = (u32) builder-&gt;sl_header.compositionTimeStamp;</span>
<a name="700"><span class="lineNum">     700 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineCov">         49 : GF_Err gp_rtp_builder_do_latm(GP_RTPPacketizer *builder, u8 *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize, u32 duration)</span>
<span class="lineNum">     703 </span>            : {
<span class="lineNum">     704 </span>            :         u32 size, latm_hdr_size, i, data_offset;
<span class="lineNum">     705 </span>            :         Bool fragmented;
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineCov">         49 :         if (!data) {</span>
<span class="lineNum">     708 </span>            :                 latm_flush(builder);
<span class="lineNum">     709 </span><span class="lineCov">          2 :                 return GF_OK;</span>
<span class="lineNum">     710 </span>            :         }
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineCov">         47 :         if ((builder-&gt;flags &amp; GP_RTP_PCK_USE_MULTI) &amp;&amp; builder-&gt;max_ptime) {</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :                 if ((u32) builder-&gt;sl_header.compositionTimeStamp + duration &gt;= builder-&gt;rtp_header.TimeStamp + builder-&gt;max_ptime)</span>
<span class="lineNum">     714 </span>            :                         latm_flush(builder);
<span class="lineNum">     715 </span>            :         }
<span class="lineNum">     716 </span>            :         /*compute max size for frame, flush current if this doesn't fit*/
<span class="lineNum">     717 </span><span class="lineCov">         47 :         latm_hdr_size = (data_size / 255) + 1;</span>
<span class="lineNum">     718 </span><span class="lineCov">         47 :         if (latm_hdr_size+data_size &gt; builder-&gt;Path_MTU - builder-&gt;bytesInPacket) {</span>
<span class="lineNum">     719 </span>            :                 latm_flush(builder);
<span class="lineNum">     720 </span>            :         }
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :         data_offset = 0;
<span class="lineNum">     723 </span>            :         fragmented = GF_FALSE;
<span class="lineNum">     724 </span><span class="lineCov">         94 :         while (data_size &gt; 0) {</span>
<span class="lineNum">     725 </span>            :                 u8 *latm_hdr;
<span class="lineNum">     726 </span><span class="lineCov">         47 :                 latm_hdr_size = (data_size / 255) + 1;</span>
<span class="lineNum">     727 </span>            :                 /*fragmenting*/
<span class="lineNum">     728 </span><span class="lineCov">         47 :                 if (latm_hdr_size + data_size &gt; builder-&gt;Path_MTU) {</span>
<span class="lineNum">     729 </span>            :                         assert(!builder-&gt;bytesInPacket);
<span class="lineNum">     730 </span>            :                         fragmented = GF_TRUE;
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :                         latm_hdr_size = (builder-&gt;Path_MTU / 255) + 1;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :                         size = builder-&gt;Path_MTU - latm_hdr_size;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                         builder-&gt;rtp_header.Marker = 0;</span>
<span class="lineNum">     734 </span>            :                 }
<span class="lineNum">     735 </span>            :                 /*last fragment or full AU*/
<span class="lineNum">     736 </span>            :                 else {
<span class="lineNum">     737 </span>            :                         fragmented = GF_FALSE;
<span class="lineNum">     738 </span>            :                         size = data_size;
<span class="lineNum">     739 </span><span class="lineCov">         47 :                         builder-&gt;rtp_header.Marker = 1;</span>
<span class="lineNum">     740 </span>            :                 }
<span class="lineNum">     741 </span><span class="lineCov">         47 :                 data_size -= size;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :                 /*create new RTP Packet if needed*/
<span class="lineNum">     744 </span><span class="lineCov">         47 :                 if (!builder-&gt;bytesInPacket) {</span>
<span class="lineNum">     745 </span><span class="lineCov">          9 :                         builder-&gt;rtp_header.SequenceNumber += 1;</span>
<span class="lineNum">     746 </span><span class="lineCov">          9 :                         builder-&gt;rtp_header.TimeStamp = (u32) builder-&gt;sl_header.compositionTimeStamp;</span>
<span class="lineNum">     747 </span><span class="lineCov">          9 :                         builder-&gt;OnNewPacket(builder-&gt;cbk_obj, &amp;builder-&gt;rtp_header);</span>
<span class="lineNum">     748 </span>            :                 }
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            :                 /* compute AudioMuxUnit header */
<span class="lineNum">     751 </span><span class="lineCov">         47 :                 latm_hdr_size = (size / 255) + 1;</span>
<span class="lineNum">     752 </span><span class="lineCov">         47 :                 latm_hdr = (unsigned char *)gf_malloc( sizeof(char) * latm_hdr_size);</span>
<span class="lineNum">     753 </span><span class="lineCov">         47 :                 for (i=0; i&lt;latm_hdr_size-1; i++)  latm_hdr[i] = 255;</span>
<span class="lineNum">     754 </span><span class="lineCov">         47 :                 latm_hdr[latm_hdr_size-1] = size % 255;</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :                 /*add LATM header IN ORDER in case we aggregate audioMuxElements in RTP*/
<span class="lineNum">     757 </span><span class="lineCov">         47 :                 builder-&gt;OnData(builder-&gt;cbk_obj, (char*) latm_hdr, latm_hdr_size, GF_FALSE);</span>
<span class="lineNum">     758 </span><span class="lineCov">         47 :                 builder-&gt;bytesInPacket += latm_hdr_size;</span>
<span class="lineNum">     759 </span><span class="lineCov">         47 :                 gf_free(latm_hdr);</span>
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :                 /*add payload*/
<span class="lineNum">     762 </span><span class="lineCov">         47 :                 if (builder-&gt;OnDataReference) {</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                         builder-&gt;OnDataReference(builder-&gt;cbk_obj, size, data_offset);</span>
<span class="lineNum">     764 </span>            :                 } else
<span class="lineNum">     765 </span><span class="lineCov">         47 :                         builder-&gt;OnData(builder-&gt;cbk_obj, data, size, GF_FALSE);</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineCov">         47 :                 builder-&gt;bytesInPacket += size;</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">         47 :                 data_offset += size;</span>
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :                 /*fragmented AU, always flush packet*/
<span class="lineNum">     772 </span><span class="lineCov">         47 :                 if (!builder-&gt;rtp_header.Marker) latm_flush(builder);</span>
<span class="lineNum">     773 </span>            :         }
<span class="lineNum">     774 </span>            :         /*if the AU has been fragmented or we don't use RTP aggregation, flush*/
<span class="lineNum">     775 </span><span class="lineCov">         47 :         if (! (builder-&gt;flags &amp; GP_RTP_PCK_USE_MULTI) ) fragmented = GF_TRUE;</span>
<span class="lineNum">     776 </span><span class="lineCov">         47 :         if (fragmented) latm_flush(builder);</span>
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            :         return GF_OK;
<span class="lineNum">     779 </span>            : }
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : #endif /*GPAC_DISABLE_STREAMING*/
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
